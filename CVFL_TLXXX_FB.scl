TYPE "MODE_OFF_DIAG_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      INSTANCE_NAME : String[40];   // Multiple instance name of block
      OVERFLOW_PIC : Byte;   // Symbol location if overflow pictures have been created
      FG_NR : Int;   // No. of FG with which the element is associated
      SG_NR : Int;   // No. of SG with which the element is associated
      DIAG_INFO : Int;   // Additional information: 1: ProdEnd: Release / 2: ProdEnd: No release
   END_STRUCT;

END_TYPE

TYPE "MESS_LIST_PTR_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      "DB" : DB_ANY;   // DB number
      NR : UInt;   // Message number
   END_STRUCT;

END_TYPE

TYPE "MODE_OFF_DIAG_UDT"
VERSION : 0.1
   STRUCT
      COUNT : Int;   // Number of actuators that are not in the selected home position
      STATE : USInt;   // Status shown by the list: 1: Devices not outputting a shutdown release, 2: Devices switching off, 3: Devices switching on
      MAX_INDEX_STACK : USInt := 4;   // Maximum stack fill
      HMI_OFFSET : Int;   // Offset in list. 0 means display as of first entry
      STACK : Array[0..4] of "MODE_OFF_DIAG_DETAIL_UDT";   // List with detailed information on individual elements
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_DIAG_STOP_UDT"
VERSION : 0.1
   STRUCT
      MAX_INDEX_STACK : USInt := 4;   // Maximum stack fill
      COUNT : USInt;   // Current number of elements that prevent the STOP
      STACK : Array[0..4] of Struct   // List with detailed information on individual elements
         INSTANCE_NAME : String[30];   // Multiple instance name of block
         OVERFLOW_PIC : Byte;   // Symbol location if overflow pictures have been created
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "MESS_IPST_PRIORITY_UDT"
VERSION : 0.1
   STRUCT
      A : Bool;   // Order-related standstill
      B : Bool;   // Production line-internal systemic
      E : Bool;   // System-related disposal fault
      I : Bool;   // TPM
      M : Bool;   // Message
      O : Bool;   // Organizational
      P : Bool;   // Pause
      Q : Bool;   // Quality-related standstill
      S : Bool;   // System-related supply fault
      T : Bool;   // Technical fault
      W : Bool;   // Warning
      Y : Bool;   // Self-diagnosis
   END_STRUCT;

END_TYPE

TYPE "MODE_DEVICES_SINGLE_UDT"
VERSION : 0.1
   STRUCT
      SWITCHABLE_EXIST : Bool;   // Switchable device available on level
      ON : Bool;   // Devices that are switched on exist in the FG
      SWITCH_ON_ACTIVE : Bool;   // Device switch-on active
      OFF : Bool;   // Devices in the FG that are switched off
      SWITCH_OFF_ACTIVE : Bool;   // Switching off devices active
   END_STRUCT;

END_TYPE

TYPE "MEDIA_PN_DEV_STATE_FG_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      REF_ERROR : Bool;   // No device configured with this device name
      CONF : Bool;   // DeviceStates Mode 1
      ERROR : Bool;   // DeviceStates Mode 2
      DEACTIVATED : Bool;   // DeviceStates Mode 3
      EXIST : Bool;   // DeviceStates Mode 4
      NOT_EXIST : Bool;   // At least one device in the level is not available
      NO_MODE_MANIPULATION : Bool;   // On device error: no error immediate stop / no bus error in the level
      PROBLEM : Bool;   // DeviceStates Mode 5
      PROFIENERGY_AVAILABLE : Bool;   // PROFIenergy-capable device in the level
      PROFIENERGY_ACTIVE : Bool;   // PROFIenergy active in the level
      COUNTER_DEVICES : UInt;   // Number of devices in these levels
   END_STRUCT;

END_TYPE

TYPE "MESS_HANDLE_SINGLE_HEADER_UDT"
VERSION : 0.1
   STRUCT
      "TYPE" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[30];   // Name of reporting block
      LOCATION { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[40];   // Instance name of reporting block
   END_STRUCT;

END_TYPE

TYPE "MODE_LINE_PLC_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      EXIST : Bool;   // PLC exists
      AKZ : String[10];   // AKZ name of PLC
   END_STRUCT;

END_TYPE

TYPE "MEDIA_PN_DEV_STATE_PLC_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      REF_ERROR : Bool;   // No device configured with this device name
      REF_ERROR_AT_LEAST_ONE_SG : Bool;
      CONF : Bool;   // DeviceStates Mode 1
      CONF_AT_LEAST_ONE_SG : Bool;
      ERROR : Bool;   // DeviceStates Mode 2
      ERROR_AT_LEAST_ONE_SG : Bool;
      DEACTIVATED : Bool;   // DeviceStates Mode 3
      DEACTIVATED_AT_LEAST_ONE_SG : Bool;
      EXIST : Bool;   // DeviceStates Mode 4
      EXIST_AT_LEAST_ONE_SG : Bool;
      NOT_EXIST : Bool;   // At least one device in the level is not available
      NOT_EXIST_AT_LEAST_ONE_SG : Bool;   // At least one device in the subordinate level is not available
      NO_MODE_MANIPULATION : Bool;   // On device error: no error immediate stop / no bus error in the level
      NO_MODE_MANIPULATION_AT_LEAST_ONE_SG : Bool;   // On device error: no error immediate stop / no bus error in the subordinate levels
      PROBLEM : Bool;   // DeviceStates Mode 5
      PROBLEM_AT_LEAST_ONE_SG : Bool;
      PROFIENERGY_AVAILABLE : Bool;   // PROFIenergy-capable device in the level
      PROFIENERGY_AVAILABLE_AT_LEAST_ONE_SG : Bool;   // PROFIenergy-capable device in the subordinate level
      PROFIENERGY_ACTIVE : Bool;   // PROFIenergy active in the level
      PROFIENERGY_ACTIVE_AT_LEAST_ONE_SG : Bool;   // PROFIenergy active in the subordinate level
      COUNTER_DEVICES : UInt;   // Number of devices in these levels
      COUNTER_DEVICES_SG_FG : UInt;   // Number of devices in SG + FG levels
   END_STRUCT;

END_TYPE

TYPE "MESS_LIST_PTR_UDT"
VERSION : 0.1
   STRUCT
      ITEM : Array[0..2] of "MESS_LIST_PTR_DETAIL_UDT";
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_DIALOG_UDT"
VERSION : 0.1
   STRUCT
      PREFIX : String[128];   // Variable prefix for the block
   END_STRUCT;

END_TYPE

TYPE "MESS_3_LANGUAGE_UDT"
VERSION : 0.1
   STRUCT
      LANG : Array[1..3] of WString[80];   // Message texts in 3 languages
   END_STRUCT;

END_TYPE

TYPE "MEDIA_PN_DEV_STATE_SG_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      REF_ERROR : Bool;   // No device configured with this device name
      REF_ERROR_AT_LEAST_ONE_FG : Bool;
      CONF : Bool;   // DeviceStates Mode 1
      CONF_AT_LEAST_ONE_FG : Bool;
      ERROR : Bool;   // DeviceStates Mode 2
      ERROR_AT_LEAST_ONE_FG : Bool;
      DEACTIVATED : Bool;   // DeviceStates Mode 3
      DEACTIVATED_AT_LEAST_ONE_FG : Bool;
      EXIST : Bool;   // DeviceStates Mode 4
      EXIST_AT_LEAST_ONE_FG : Bool;
      NOT_EXIST : Bool;   // At least one device in the level is not available
      NOT_EXIST_AT_LEAST_ONE_FG : Bool;   // At least one device in the subordinate level is not available
      NO_MODE_MANIPULATION : Bool;   // On device error: no error immediate stop / no bus error in the level
      NO_MODE_MANIPULATION_AT_LEAST_ONE_FG : Bool;   // On device error: no error immediate stop / no bus error in the subordinate levels
      PROBLEM : Bool;   // DeviceStates Mode 5
      PROBLEM_AT_LEAST_ONE_FG : Bool;
      PROFIENERGY_AVAILABLE : Bool;   // PROFIenergy-capable device in the level
      PROFIENERGY_AVAILABLE_AT_LEAST_ONE_FG : Bool;   // PROFIenergy-capable device in the subordinate level
      PROFIENERGY_ACTIVE : Bool;   // PROFIenergy active in the level
      PROFIENERGY_ACTIVE_AT_LEAST_ONE_FG : Bool;   // PROFIenergy active in the subordinate level
      COUNTER_DEVICES : UInt;   // Number of devices in these levels
      COUNTER_DEVICES_FG : UInt;   // Number of devices in the subordinate FGs
   END_STRUCT;

END_TYPE

TYPE "MODE_DEVICES_MULTI_UDT"
VERSION : 0.1
   STRUCT
      SWITCHABLE_EXIST : Bool;   // Switchable device available on level
      ON : Bool;   // All devices in the level are switched on
      ON_AT_LEAST_ONE : Bool;   // At least one device of the level is switched on
      SWITCH_ON_ACTIVE : Bool;   // Activation of at least one device active
      OFF : Bool;   // All devices in the level are switched off
      OFF_AT_LEAST_ONE : Bool;   // At least one device of the level is switched off
      SWITCH_OFF_ACTIVE : Bool;   // At least one device of the level is switching off
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_DETAIL_DIALOG_UDT"
VERSION : 0.1
   STRUCT
      IN_HMI : Struct
         HMI_OFFSET : Int;   // Scroll variable of HMI
      END_STRUCT;
      OUT_HMI : Struct
         SHOW_DIALOG : Bool;   // A dialog is active
         MAX_DIALOGS : UInt;   // Number of all dialogs
         COUNT : UInt;   // Number of dialogs active
         ACT_DIALOG : UInt;   // Index of first dialog that is displayed
         ERROR : Bool;   // Dialog is configured as an error
         MESSAGE : Bool;   // Dialog is configured as a message
         STACK : Array[0..4] of "MODE_FG_DIALOG_UDT";
      END_STRUCT;
      INTERNAL : Struct
         COUNTER_DIALOGS_TOTAL : UInt;   // Scroll variable of HMI
         COUNTER_DIALOGS_ACTIVE : UInt;   // Total dialogs present
         HMI_SHOW_DIALOG : Int;   // Offset for displaying dialog in HMI
         ACTIVE_AT_LEAST_ONE : Bool;   // At least one dialog is active
         ERROR : Bool;   // Dialog is configured as an error
         MESSAGE : Bool;   // Dialog is configured as a message
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_DETAIL_IN_COMMISSIONING_UDT"
VERSION : 0.1
   STRUCT
      NO_MODE_MANIPULATION { ExternalVisible := 'False'} : Bool;   // Do not output messages, error bits are not evaluated
      NO_MESSAGE { ExternalVisible := 'False'} : Bool;   // Do not output message
      NO_OUTPUT { ExternalVisible := 'False'} : Bool;   // Outputs are not switched
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_DETAIL_IN_UDT"
VERSION : 0.1
   STRUCT
      ERROR_POWER_LOAD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_POWER_LOGIC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_AIR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_WATER { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_GAS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_OIL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_BUS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_SAFETY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_DROP_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_SEOC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "R" reset, if not fulfilled
      REQ_CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // User: "S" Controlled Stop request
      SEOC_REL_GATE_ACCESS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Feedback of all elements as to whether a release for opening the safety gate exists with HNTE
      SEOC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // User: "S" HNTE request
      SEOC_NOT_DROP_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // User: TRUE Start not dropped in case of GRST!
      MESSAGE_PERI_NOT_READY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      WARNING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      OVERFLOW_PIC_RED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Overflow pictures > red color shift // bit 0: Figure 1
      OVERFLOW_PIC_YELLOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Overflow pictures > yellow color shift // bit 0: Figure 1
      ERROR_SEQUENCE_FLOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault material flow disposal or supply within FG
      AUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: BA automatic (without operator release)
      START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: BA automatic or resequencing start (without operator release)
      DROP_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: Delete start (without operator release)
      MAN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: BA manual (without operator release)
      RESEQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: Activate resequencing
      RESEQ_INTERLOCK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release resequencing mode
      RESEQ_ENABLE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing is possible
      RESEQ_POSSIBLE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Resequencing of a phase is possible
      RESEQ_FINISH { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Resequencing is completed
      RESEQ_ALL_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // All FGs of a group are in resequencing operating mode
      SHOW_DIALOG_ERROR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Dialog with error is active
      SHOW_DIALOG_MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Dialog with message is active
      QUIT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: Acknowledgment (without operator release)
      FG_EMPTY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG empty
      FG_HOME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG in home position
      PANEL_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // >>Visu: at least one panel displays this FG
      PANEL_NR_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // >>Visu: Panel number currently viewing the FG
      PROD_END { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of production reached for FG
      PROD_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Production interruption reached for FG
      DEVICES { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_DEVICES_SINGLE_UDT";   // Information about FG devices
      IPST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_IPST_PRIORITY_UDT";   // IPS-T priorities of faults active in the level
      DIAG_CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_FG_DIAG_STOP_UDT";   // List with elements preventing controlled stop
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_DETAIL_IN_HMI_UDT"
VERSION : 0.1
   STRUCT
      AUT : DWord;   // BUTTON_AUTOMATIK
      START : DWord;   // BUTTON AUTOMATIC or resequencing START
      REQ_CONTR_STOP : DWord;   // BUTTON_ANFORDERUNG CONTROLLED_STOP
      DROP_START : DWord;   // BUTTON_START_LOESCHEN
      MAN : DWord;   // BUTTON_HAND
      REQ_RESEQ : DWord;   // BUTTON request resequencing
      SEOC_ON : DWord;   // BUTTON_HNTE_EIN
      SEOC_OFF : DWord;   // BUTTON_HNTE_AUS
      RUN_EMPTY : DWord;   // BUTTON_LEERFAHREN
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_DETAIL_IN_HMI_FROM_UP_LEV_UDT"
VERSION : 0.1
   STRUCT
      AUT { ExternalVisible := 'False'} : Bool;
      START { ExternalVisible := 'False'} : Bool;
      REQ_CONTR_STOP { ExternalVisible := 'False'} : Bool;
      DROP_START { ExternalVisible := 'False'} : Bool;
      MAN { ExternalVisible := 'False'} : Bool;
      QUIT { ExternalVisible := 'False'} : Bool;
      REQ_RESEQ { ExternalVisible := 'False'} : Bool;   // Request resequencing of SG/PLC
      SEOC_ON { ExternalVisible := 'False'} : Bool;
      SEOC_OFF { ExternalVisible := 'False'} : Bool;
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_DETAIL_OUT_UDT"
VERSION : 0.1
   STRUCT
      SG_NR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // FG exists, associated SG no.
      FG_EMPTY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG is empty
      AUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode automatic
      AUT_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode automatic start
      MAN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual operating mode
      RESEQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing
      RESEQ_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing start
      RESEQ_ENABLE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing is possible
      RESEQ_INTERLOCK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release resequencing mode
      RESEQ_POSSIBLE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Resequencing of a phase is possible
      RESEQ_FINISH { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Resequencing is completed
      RESEQ_ALL_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // All FGs of the group are in resequencing operating mode
      SHOW_DIALOG_ERROR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Dialog with error is active
      SHOW_DIALOG_MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Dialog with message is active
      PERI_READY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Peripherals OK
      MAN_RELEASE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Movement release available
      MAN_ADVANCE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // BUTTON MANUAL ADVANCE (with operator release)
      MAN_RETRACT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // BUTTON MANUAL RETRACT (with operator release)
      FAST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // BUTTON FAST (with operator release)
      OP_RELEASE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operator release using panel[xx]
      OP_RELEASE_PANEL_NR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Panel number of panel which has operator release for FG
      PANEL_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // >>Visu: at least one panel displays this FG
      PANEL_NR_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // >>Visu: Panel number currently viewing the FG
      HOME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG in home position
      HOME_RESET_EDGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Edge
      HOME_RESET_PULSE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PULSE [300 ms]
      QUIT_EDGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Edge
      QUIT_PULSE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PULSE [300 ms]
      HMI_BUTTON_EDGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // FG header edge button
         AUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG header edge button AUT
         MAN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG header edge button MAN
         START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG header edge button START
         REQ_CONTR_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG header edge button REQ_CONTR_STOP/STOP
         RESEQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG header edge button RESEQ
      END_STRUCT;
      SEOC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop after end of cycle (Stop End of Cycle)
      SERVICE_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Setup active
      ENDPOS_IGNORED_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Override limit switch
      RUN_EMPTY_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Empty run active
      DRY_RUN_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Peripherals OK
      CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG is in state: controlled stop
      REQ_CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG has a controlled stop request // Collective signal: higher + own levels (PLC+SG+FG)
      SEOC_REL_GATE_ACCESS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Complete SG has release to open safety gate for HNTE
      LIGHT_TEST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lamp test
      ERROR_POWER_LOAD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      ERROR_POWER_LOGIC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      ERROR_AIR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      ERROR_WATER { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      ERROR_GAS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      ERROR_OIL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      ERROR_BUS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      ERROR_SAFETY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      ERROR_DROP_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      ERROR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      ERROR_SEOC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      MESSAGE_PERI_NOT_READY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      WARNING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG+FG)
      ERROR_SEQUENCE_FLOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault material flow disposal or supply within FG
      CO_NO_MODE_MANIPULATION { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Do not output messages, error bits are not evaluated
      CO_NO_MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Do not output message
      CO_NO_OUTPUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outputs are not switched
      IPST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_IPST_PRIORITY_UDT";   // IPS-T priorities of faults active in the level
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_DETAIL_INTERNAL_UDT"
VERSION : 0.1
   STRUCT
      FG_NR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // = 0: FG not available!
      FG_NAME : String[20];
      SG_NR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;
   END_STRUCT;

END_TYPE

TYPE "MEDIA_PN_DEV_STATE_FG_UDT"
VERSION : 0.1
   STRUCT
      IN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MEDIA_PN_DEV_STATE_FG_DETAIL_UDT";
      OUT_HMI : "MEDIA_PN_DEV_STATE_FG_DETAIL_UDT";
   END_STRUCT;

END_TYPE

TYPE "SYS_PLC_LEVEL_CYCLE_TIME"
VERSION : 0.1
   STRUCT
      RUNTIME_MEM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal;   // Memory for determining the cycle time
      SG_MEM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // SG to runtime
      FG_MEM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // FG to runtime
      PLC : UInt;   // Cycle time of PLC without SGs, without FGs in 100 µs
      SG : Array[0.."CO_MODE_SG_MAX"] of UInt;   // Cycle time of SG without FGs in 100 µs
      "SG+FG" : Array[0.."CO_MODE_SG_MAX"] of UInt;   // Cycle time of SG incl. FGs in 100 µs
      FG : Array[0.."CO_MODE_FG_MAX"] of UInt;   // Cycle time of FG in 100 µs
   END_STRUCT;

END_TYPE

TYPE "PANEL_HMI_INTFACE_FROM_PANEL_UDT"
VERSION : 0.1
   STRUCT
      HEADER : Bool;   // VISU sets bit if HEADER level is selected
      LINE : Bool;   // VISU sets bit if LINE level is selected
      PLC : Bool;   // VISU sets bit if PLC level is selected
      SG : Int;   // VISU writes SG_NR if SG level is selected
      FG : Int;   // VISU writes FG_NR if FG level is selected
      RT_ACTIVE : Bool;   // VISU sets bit every 2 sec.
      SCREEN_CHANGE : Bool;   // VISU sets bit on mask change
      AREA_CHANGE : Bool;   // VISU sets bit on level change
      MULTISELECTION : Bool;   // VISU
      LANGUAGE : Int := 1;   // VISU sets internal language code to range [1..3]
      LOADED_SCREEN_NAME : String[40];   // VISU writes back active image name
      LIGHT_CHECK : Bool;   // VISU writes bit for lamp test
      EXCLUSIVE_MODE : Bool;   // VISU writes bit: TRUE = Exclusive Mode
      IP_ADDRESS_FIRST : Array[0..4] of USInt;   // VISU writes first IP address of panel
      IP_ADDRESS_SECOND : Array[0..4] of USInt;   // VISU writes second IP address of panel
      MAC_ADDRESS_FIRST : Array[0..5] of Byte;   // MAC address of first network card
      MAC_ADDRESS_SECOND : Array[0..5] of Byte;   // MAC address of second network card
      PC_NAME : String[32];   // VISU writes panel IP address
      RUNTIME_CURRENT_TIMESTAMP : String[32];   // VISU writes time stamp of runtime project (MCX file)
      RUNTIME_NOT_UP_TO_DATE : Bool;   // VISU writes: Runtime file not up-to-date
      WRONG_RT_PATH : Bool;   // VISU writes: Runtime is not started in the correct path (WINCCProjects)
      ERROR_PANEL_NR : Bool;   // VISU writes: PC name does not match panel FB instance name
      OPERATOR_ACTIVE : Bool;   // VISU writes: User is active / mouse movement
      POWER_SAVE_SCREEN_OFF : Bool;   // VISU writes: Energy-saving screen was switched off
      WAKE_UP : Bool;   // VISU writes: Panel wake-up from inactive state
      SLEEP_WOL : Bool;   // VISU writes: Shut down panel to Sleep WOL mode
   END_STRUCT;

END_TYPE

TYPE "PANEL_HMI_INTFACE_TO_PANEL_UDT"
VERSION : 0.1
   STRUCT
      INIT_HMI : Bool;   // PLC sets bit on PLC restart/Visu resets bit
      LOAD_DETAIL_SCREEN_OBJ_NAME : String[60];   // PLC writing object name of symbol for opening detailed image
      LOAD_SCREEN_NAME : String[40];   // PLC writing image name to select
      LOAD_SCREEN : Bool;   // PLC sets bit / Visu resets bit
      RT_ACTIVE : Bool;   // PLC sets bit (SA10s) if panel RT is reported as active
      SCREEN_CHANGE : Bool;   // PLC sets bit for screen change: Pulse 1 cycle
      AREA_CHANGE : Bool;   // PLC sets bit for PLC, SG, FG change: Pulse 1 cycle
      HOME_FG : USInt;   // PLC writing FG number for panel display on boot or via button selection
      HOME_SG : USInt;   // PLC writing SG number for panel display on boot or via button selection
      EXCLUSIVE_MODE : Bool;   // PLC writing bit: TRUE = Exclusive Mode
      PANEL_VIEW : Int;   // PLC writing configuration at panel FB: 0°, 90°, 180°, 270°
      TERMINATE_SCREENSAVER : Bool;   // PLC writing bit: TRUE [2s]
      PN_IO_SYSTEM : USInt;   // No. of Profinet master system [1..2]
      DEV_NR : UInt;   // Profinet panel device no.
      MEDIA_PN_DATA_VALID : Bool;   // PLC sets bit when PN I/O master systems' ramp-up is finished
      POWER_SAVE_SCREEN_OFF : Bool;   // Energy saving - switch off screen
      POWER_SAVE_PC_OFF : Bool;   // Energy saving - switch off PC
      POWER_SAVE_SCREEN_OFF_ACTIVE : Bool;   // Energy saving - switch off screen active
      POWER_SAVE_PC_OFF_ACTIVE : Bool;   // Energy saving - switch off PC active
      WAKE_UP_ACTIVE : Bool;   // Panel wake-up from energy-saving mode active
      ERROR : Bool;
      WARNING : Bool;
   END_STRUCT;

END_TYPE

TYPE "MEDIA_PN_DEV_STATE_SG_UDT"
VERSION : 0.1
   STRUCT
      IN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MEDIA_PN_DEV_STATE_SG_DETAIL_UDT";
      OUT_HMI : "MEDIA_PN_DEV_STATE_SG_DETAIL_UDT";
   END_STRUCT;

END_TYPE

TYPE "MESS_REGLINE_UDT"
VERSION : 0.1
   STRUCT
      APP_FLAG : Bool;   // Incoming
      DISAPP_FLAG : Bool;   // Outgoing
      CYCLE_ID : Int;   // Cycle ID: this is entered for each active message per cycle
      FIRST_UP_FAULT : Bool;   // TRUE: First-up value is not a consequence of a peripheral error
      "TYPE" : String[30];   // Type (block name)
      LOCATION : String[40];   // Location (multiple instance name)
      INSTANCENAME : String[40];   // Name of calling block
      OPERAND : String[30];   // Operand
      SG : Int;
      FG : Int;
      APP_TIME {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Incoming time
      DISAPP_TIME {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Outgoing time
      IPST_PRIO : Char;   // IPS-T priority
      IPST_SEND : Bool := true;   // Message must be sent to IPS-T
      ERROR_CLASS : Int;   // Fault message class
      MESS : "MESS_LIST_PTR_UDT";   // Fault message references to lists
      ASSOCIATED_NR : Int;   // Associated value for number
      ASSOCIATED_TEXT : String[16];   // Associated value for text
      PAGING : UInt;   // Paging
      CODE_VIEWER : Byte;   // Allow Code Viewer call in its different forms
      EPLAN_VIEWER : Byte;   // Allow EPLAN viewer call
      PN_DEVICE : Byte;   // Message relates to PN device with further functionality: Web server, PN diagnostics, etc.
      OVERFLOW_PIC : Byte;   // Location of reporting element, if overflow pictures present
   END_STRUCT;

END_TYPE

TYPE "MESS_REF_PTR_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      REF_DB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DB_ANY;   // Reference DB of list
      "FAMILY" : String[10];   // Family name of list
      GENERATE_DATE {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Time at which the list was generated
      COUNTER_USED : UInt;   // Number of blocks using this list
      "COUNTER" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Variable for determining the quantity. Incremented by one in the cycle each time the list is used
   END_STRUCT;

END_TYPE

TYPE "MESS_GET_TEXT_SEQ_UDT"
VERSION : 0.1
   STRUCT
      VALID : Bool;   // Text is valid
      UNKNOW : Bool;   // Text is not defined
      BUSY : Bool;   // Text requested from load memory
      ERROR : Bool;   // Error occurred
      DIAG : Word;   // Error message
      TEXT : "MESS_3_LANGUAGE_UDT";   // Message text
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_DETAIL_OUT_HMI_UDT"
VERSION : 0.1
   STRUCT
      SG_NR : USInt;   // FG exists, associated SG no.
      EMPTY : Bool;   // FG is empty
      AUT : Bool;   // Operating mode automatic
      AUT_START : Bool;   // Operating mode automatic start
      MAN : Bool;   // Manual operating mode
      PERI_READY : Bool;   // Peripherals OK
      MAN_RELEASE : Bool;   // Manual release present
      HOME : Bool;   // FG in home position
      SEOC : Bool;   // Stop after end of cycle (Stop End of Cycle)
      RESEQ : Bool;   // Operating mode resequencing
      RESEQ_START : Bool;   // Operating mode resequencing start
      RESEQ_ENABLE : Bool;   // Operating mode resequencing is possible
      RESEQ_INTERLOCK : Bool;   // Release resequencing mode
      RESEQ_INTERLOCK_AT_LEAST_ONE_SEQ : Bool;   // Release at least one sequence
      RESEQ_POSSIBLE : Bool;   // Resequencing of a phase is possible
      RESEQ_GROUPING_ACTIVE : Bool;   // Grouping active in resequencing
      RESEQ_SHOW_DIALOG_ERROR : Bool;   // Resequencing dialog with error active
      RESEQ_SHOW_DIALOG_MESSAGE : Bool;   // Resequencing dialog with message active
      RESEQ_ALL_FG : Bool;   // All FGs of the group are in resequencing operating mode
      SERVICE_MODE_ACTIVE : Bool;   // Setup active
      ENDPOS_IGNORED_MODE_ACTIVE : Bool;   // Override limit switch
      RUN_EMPTY_MODE_ACTIVE : Bool;   // Empty run active
      DRY_RUN_MODE_ACTIVE : Bool;   // Dry run
      REQ_CONTR_STOP_ACTIVE : Bool;   // Request for controlled stop active (HMI request)
      OP_RELEASE_PANEL_NR : USInt;   // Panel number of panel which has operator release for FG
      ERROR_POWER_LOAD : Bool;   // Only own level: FG!!!
      ERROR_POWER_LOGIC : Bool;   // Only own level: FG!!!
      ERROR_AIR : Bool;   // Only own level: FG!!!
      ERROR_WATER : Bool;   // Only own level: FG!!!
      ERROR_GAS : Bool;   // Only own level: FG!!!
      ERROR_OIL : Bool;   // Only own level: FG!!!
      ERROR_BUS : Bool;   // Only own level: FG!!!
      ERROR_SAFETY : Bool;   // Only own level: FG!!!
      ERROR_DROP_START : Bool;   // Only own level: FG!!!
      ERROR : Bool;   // Only own level: FG!!!
      ERROR_SEOC : Bool;   // Only own level: FG!!!
      ANY_ERROR : Bool;   // Only own level: FG!!! Collective signal!!!
      MESSAGE_PERI_NOT_READY : Bool;
      MESSAGE : Bool;   // Only own level: FG!!!
      WARNING : Bool;   // Only own level: FG!!!
      OVERFLOW_PIC_RED : Byte;   // Overflow pictures > red color shift // bit 0: Figure 1
      OVERFLOW_PIC_YELLOW : Byte;   // Overflow pictures > yellow color shift // bit 0: Figure 1
      REQ_CONTROLLED_STOP : Bool;   // Request for controlled stop active (IN interface) // only own level: FG!!!
      SEOC_REL_GATE_ACCESS : Bool;   // FG has release to open safety gate with HNTE
      ERROR_SEQUENCE_FLOW : Bool;   // Fault material flow disposal or supply within FG
      REQ_PROD_END : Bool;   // Request end of production for FG
      PROD_END : Bool;   // End of production reached for FG
      REQ_PROD_BREAK : Bool;   // Request production end
      PROD_BREAK : Bool;   // Production interruption reached for SG
      OFF_RELEASE : Bool;   // Release switch off FG
      OFF_REQUEST : Bool;   // Request switch off FG
      DEVICES : "MODE_DEVICES_SINGLE_UDT";   // Information about FG devices
      DIAG_CONTROLLED_STOP : "MODE_FG_DIAG_STOP_UDT";   // List with elements preventing controlled stop
   END_STRUCT;

END_TYPE

TYPE "MODE_SG_DETAIL_INTERNAL_UDT"
VERSION : 0.1
   STRUCT
      SG_NAME : String[16];
      SG_NR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;
   END_STRUCT;

END_TYPE

TYPE "MEDIA_PN_DEV_STATE_PLC_UDT"
VERSION : 0.1
   STRUCT
      IN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MEDIA_PN_DEV_STATE_PLC_DETAIL_UDT";
      OUT_HMI : "MEDIA_PN_DEV_STATE_PLC_DETAIL_UDT";
   END_STRUCT;

END_TYPE

TYPE "MODE_SG_DETAIL_IN_FEEDBACK_FG"
VERSION : 0.1
   STRUCT
      EMPTY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      AUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      AUT_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      AUT_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      AUT_START_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MAN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // MANUAL
      MAN_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MAN_RELEASE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // MANUAL
      MAN_RELEASE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      HOME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      RESEQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing
      RESEQ_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing in at least one FG
      RESEQ_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing start
      RESEQ_START_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing start in at least one FG
      RESEQ_INTERLOCK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release resequencing mode
      RESEQ_INTERLOCK_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release resequencing mode in least on FG
      RESEQ_ENABLE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing is possible
      RESEQ_ENABLE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing is possible in at least one FG
      RESEQ_POSSIBLE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Resequencing of a phase is possible
      RESEQ_POSSIBLE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Resequencing of a phase is possible in at least one FG
      SHOW_DIALOG_ERROR_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs!!! Collective signal!!!
      SHOW_DIALOG_MESSAGE_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs!!! Collective signal!!!
      SEOC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      SEOC_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      RUN_EMPTY_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      RUN_EMPTY_MODE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      DRY_RUN_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ERROR_SAFETY_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      ERROR_DROP_START_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      ERROR_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      ERROR_SEOC_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      MESSAGE_PERI_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MESSAGE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      WARNING_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      REQ_CONTR_STOP_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Is reset by FGs without Controlled Stop
      SEOC_REL_GATE_ACCESS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Is reset by FGs without open safety gate release at HNTE
      PROD_END { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of production reached for all FGs
      PROD_END_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of production reached for at least one FG
      PROD_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Production interruption reached for all FGs
      PROD_BREAK_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Production interruption reached for at least one FG
      OP_RELEASE_PANEL_NR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Panel number of panel which has operator release for FG
      OP_RELEASE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // At least one has FG operator release
      NO_OP_RELEASE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // At least one FG does not have an operator release
      OP_RELEASE_CHANGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Panel operator release has changed
      DEVICES { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_DEVICES_MULTI_UDT";   // Information about devices of own and subordinate levels
   END_STRUCT;

END_TYPE

TYPE "MODE_PLC_DETAIL_IN_UDT"
VERSION : 0.1
   STRUCT
      ERROR_POWER_LOAD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_POWER_LOGIC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_AIR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_WATER { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_GAS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_OIL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_BUS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_SAFETY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_DROP_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_SEOC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      MESSAGE_PERI_NOT_READY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      WARNING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      OVERFLOW_PIC_RED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Overflow pictures > red color shift // bit 0: Figure 1
      OVERFLOW_PIC_YELLOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Overflow pictures > yellow color shift // bit 0: Figure 1
      HEADER_MENU_PULLDOWN_RED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..5] of Word;   // General header: Button PullDown menu > red color change // Index 0: left Pulldown menu bit 0: top button
      HEADER_MENU_PULLDOWN_YELLOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..5] of Word;   // General header: Button PullDown menu > red color change // Index 0: left Pulldown menu bit 0: top button
      ERROR_SEQUENCE_FLOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault material flow disposal or supply at limits of PLC
      REQ_CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // User: "S" Controlled Stop request
      AUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: BA automatic (without operator release)
      START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: BA automatic or resequencing start (without operator release)
      DROP_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: Delete start (without operator release)
      MAN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: BA manual (without operator release)
      QUIT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: Acknowledgment (without operator release)
      PANEL_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // >>Visu: at least one panel displays the PLC level
      PANEL_NR_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // >>Visu: Panel number currently viewing the PLC level
      DEVICES { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_DEVICES_SINGLE_UDT";   // Information about devices of PLC level
      OFF_WITHOUT_ENDTIME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch off SG without final time
      OFF_WITH_ENDTIME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch off SG with final time
      PROD_END { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of production reached for PLC elements
      PROD_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Production interruption reached for PLC elements
      OFF_TIME {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   // Time at which the production line is to be switched off
      ON_TIME {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   // Time at which the production line must be ready for operation
      IPST_REQ_NOT_OFF_NEXT_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Do not switch off next pause (EVENT_IM 33)
      IPST_SWITCH_ON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch on (EVENT_IM 34)
      IPST_SWITCH_OFF { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch off (EVENT_IM 35)
      OFF_DIAG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_OFF_DIAG_UDT";   // Diagnostics stack device-related production line shutdown
      IPST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_IPST_PRIORITY_UDT";   // IPS-T priorities of faults active in the level
   END_STRUCT;

END_TYPE

TYPE "MEDIA_WOL_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      IN : Struct   // Signals to central block
         REQUEST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request send Wake on LAN telegram
         MAC_ADDRESS : Array[0..5] of Byte;   // MAC address of device
         "NAME" : String[30];   // Name of device
      END_STRUCT;
      OUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Signals from central block
         DONE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Telegram was successfully sent
         ERROR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Telegram sent with error
         BUSY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Currently sending telegram
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "MODE_SG_DETAIL_OUT_HMI_UDT"
VERSION : 0.1
   STRUCT
      EXIST : Bool;   // SG available
      EMPTY : Bool;
      AUT : Bool;
      AUT_AT_LEAST_ONE_FG : Bool;
      AUT_START : Bool;
      AUT_START_AT_LEAST_ONE_FG : Bool;
      MAN : Bool;   // MANUAL
      MAN_AT_LEAST_ONE_FG : Bool;
      MAN_RELEASE : Bool;   // MANUAL
      MAN_RELEASE_AT_LEAST_ONE_FG : Bool;
      HOME : Bool;   // SG in home position
      RESEQ : Bool;   // Operating mode resequencing
      RESEQ_AT_LEAST_ONE_FG : Bool;   // Operating mode resequencing in at least one FG
      RESEQ_START : Bool;   // Operating mode resequencing start
      RESEQ_START_AT_LEAST_ONE_FG : Bool;   // Operating mode resequencing start in at least one FG
      RESEQ_INTERLOCK : Bool;   // Release resequencing mode
      RESEQ_INTERLOCK_AT_LEAST_ONE_FG : Bool;   // Release resequencing mode in least on FG
      RESEQ_ENABLE : Bool;   // Operating mode resequencing is possible
      RESEQ_ENABLE_AT_LEAST_ONE_FG : Bool;   // Operating mode resequencing is possible in at least one FG
      RESEQ_POSSIBLE : Bool;   // Resequencing of a phase is possible
      RESEQ_POSSIBLE_AT_LEAST_ONE_FG : Bool;   // Resequencing of a phase is possible in at least one FG
      SHOW_DIALOG_ERROR_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs!!! Collective signal!!!
      SHOW_DIALOG_MESSAGE_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs!!! Collective signal!!!
      SEOC : Bool;
      SEOC_AT_LEAST_ONE_FG : Bool;
      RUN_EMPTY_MODE_ACTIVE : Bool;   // Separate mode at SG level
      RUN_EMPTY_MODE_AT_LEAST_ONE_FG : Bool;
      DRY_RUN_MODE_ACTIVE : Bool;   // A separate mode only from SG on
      REQ_CONTR_STOP_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs
      OP_RELEASE_PANEL_NR : USInt;   // Panel number of panel which has operator release for FG
      OP_RELEASE_AT_LEAST_ONE_FG : Bool;   // At least one has FG operator release
      OP_RELEASE_CHANGE_NR : UInt;   // Panel operator release has changed
      SEOC_REL_GATE_ACCESS : Bool;   // Complete SG has release to open safety gate for HNTE
      ERROR_POWER_LOAD : Bool;   // Only own level: SG!!!
      ERROR_POWER_LOGIC : Bool;   // Only own level: SG!!!
      ERROR_AIR : Bool;   // Only own level: SG!!!
      ERROR_WATER : Bool;   // Only own level: SG!!!
      ERROR_GAS : Bool;   // Only own level: SG!!!
      ERROR_OIL : Bool;   // Only own level: SG!!!
      ERROR_BUS : Bool;   // Only own level: SG!!!
      ERROR_SAFETY : Bool;   // Only own level: SG!!!
      ERROR_SAFETY_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs
      ERROR_DROP_START : Bool;   // Only own level: SG!!!
      ERROR_DROP_START_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs
      ERROR : Bool;   // Only own level: SG!!!
      ERROR_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs
      ERROR_SEOC : Bool;   // Only own level: SG!!!
      ERROR_SEOC_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs
      ANY_ERROR : Bool;   // Only own level: SG!!!
      ANY_ERROR_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs!!! Collective signal!!!
      MESSAGE_PERI_NOT_READY : Bool;
      MESSAGE_PERI_AT_LEAST_ONE_FG : Bool;
      MESSAGE : Bool;   // Only own level: SG!!!
      MESSAGE_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs
      WARNING : Bool;   // Only own level: SG!!!
      WARNING_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs
      OVERFLOW_PIC_RED : Byte;   // Overflow pictures > red color shift // bit 0: Figure 1
      OVERFLOW_PIC_YELLOW : Byte;   // Overflow pictures > yellow color shift // bit 0: Figure 1
      REQ_CONTROLLED_STOP : Bool;   // Request for controlled stop active (IN interface) // only own level: SG!!!
      ERROR_SEQUENCE_FLOW : Bool;   // Fault material flow disposal or supply fault at limits of SG
      UNPLANNED_BREAK : Bool;   // SG in unscheduled pause
      TPM : Bool;   // SG in scheduled maintenance
      REQ_PROD_END : Bool;   // Request end of production
      PROD_END : Bool;   // End of production reached for SG
      PROD_END_AT_LEAST_ONE_FG : Bool;   // End of production reached for at least one subordinate FG
      REQ_PROD_BREAK : Bool;   // Request production end
      PROD_BREAK : Bool;   // Production interruption reached for SG
      PROD_BREAK_AT_LEAST_ONE_FG : Bool;   // Production interruption reached for at least one subordinate FG
      OFF_RELEASE : Bool;   // Release switch off SG
      OFF_RELEASE_AT_LEAST_ONE_FG : Bool;   // Release switch off SG in at least one FG
      OFF_REQUEST : Bool;   // Request switch off SG
      OFF_WITHOUT_ENDTIME : Bool;   // Switch off SG without final time
      OFF_WITH_ENDTIME : Bool;   // Switch off SG with final time
      OFF_ENDTIME {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Mode end time
      BREAKTIME_BLOCKED : Time;   // Duration of production break due to the disposal fault
      BREAKTIME_STARVED : Time;   // Duration of production break due to the supply fault
      OFF_DIAG : "MODE_OFF_DIAG_UDT";   // Diagnostics stack device-related production line shutdown
      DEVICES : "MODE_DEVICES_MULTI_UDT";   // Information about devices of own and subordinate levels
   END_STRUCT;

END_TYPE

TYPE "MODE_PLC_DETAIL_IN_COMMISSIONING_UDT"
VERSION : 0.1
   STRUCT
      NO_MODE_MANIPULATION { ExternalVisible := 'False'} : Bool;   // Do not output messages, error bits are not evaluated
      NO_MESSAGE { ExternalVisible := 'False'} : Bool;   // Do not output message
      NO_OUTPUT { ExternalVisible := 'False'} : Bool;   // Outputs are not switched
   END_STRUCT;

END_TYPE

TYPE "MODE_PLC_DETAIL_OUT_UDT"
VERSION : 0.1
   STRUCT
      PLC_EMPTY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      HOME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Complete PLC in home position
      QUIT_EDGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Edge
      QUIT_PULSE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PULSE [300 ms]
      RUN_EMPTY_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Physically separate mode at PLC level
      CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Complete PLC is in state: Controlled stop
      REQ_CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PLC has a controlled stop request // Collective signal: higher + own level (PLC)
      LIGHT_TEST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lamp test
      ERROR_POWER_LOAD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      ERROR_POWER_LOGIC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      ERROR_AIR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      ERROR_WATER { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      ERROR_GAS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      ERROR_OIL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      ERROR_BUS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      ERROR_SAFETY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      ERROR_DROP_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      ERROR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      ERROR_SEOC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      MESSAGE_PERI_NOT_READY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      WARNING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC)
      ERROR_SEQUENCE_FLOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault material flow disposal or supply fault at limits of PLC
      CO_NO_MODE_MANIPULATION { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Do not output messages, error bits are not evaluated
      CO_NO_MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Do not output message
      CO_NO_OUTPUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outputs are not switched
      PANEL_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // >>Visu: at least one panel displays the PLC image
      PANEL_NR_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // >>Visu: Panel number currently viewing the PLC image
      PROD_END { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of production reached for SG
      REQ_PROD_END { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request end of production
      PROD_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Production interruption reached for PLC
      REQ_PROD_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request production end
      OFF_REQUEST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request switch off PLC
      OFF_RELEASE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release switch off PLC
      ON_REQUEST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request switch on PLC
      OFF_WITH_ENDTIME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch off SG with final time
      OFF_ENDTIME {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   // Mode end time
      PREWARNING_PROD_END { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Prewarning: Central shutdown via IPS-T
      REQ_NOT_OFF_NEXT_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request do not switch off next break
      IPST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_IPST_PRIORITY_UDT";   // IPS-T priorities of faults active in the level
   END_STRUCT;

END_TYPE

TYPE "MODE_PLC_DETAIL_IN_HMI_UDT"
VERSION : 0.1
   STRUCT
      AUT : DWord;   // BUTTON_AUTOMATIK
      START : DWord;   // BUTTON AUTOMATIC or resequencing START
      REQ_CONTR_STOP : DWord;   // BUTTON_ANFORDERUNG CONTROLLED_STOP
      DROP_START : DWord;   // BUTTON_START_LOESCHEN
      MAN : DWord;   // BUTTON_HAND
      REQ_RESEQ : DWord;   // BUTTON request resequencing
      SEOC_ON : DWord;   // BUTTON_HNTE_EIN
      SEOC_OFF : DWord;   // BUTTON_HNTE_AUS
      REQ_PROD_END_ON : DWord;   // BUTTON end of production on
      REQ_PROD_END_OFF : DWord;   // BUTTON end of production off
      REQ_PROD_BREAK_ON : DWord;   // BUTTON production interruption on
      REQ_PROD_BREAK_OFF : DWord;   // BUTTON production interruption off
      RUN_EMPTY : DWord;   // BUTTON_LEERFAHREN
      DRY_RUN_ON : DWord;   // BUTTON_BAUTEILLOS_EIN
      DRY_RUN_OFF : DWord;   // BUTTON_BAUTEILLOS_AUS
      UNPLANNED_BREAK_ON : DWord;   // BUTTON unscheduled pause on
      UNPLANNED_BREAK_OFF : DWord;   // BUTTON unscheduled pause off
      TPM_ON : DWord;   // BUTTON planned maintenance on
      TPM_OFF : DWord;   // BUTTON planned maintenance off
      OFF_WITHOUT_ENDTIME_ON : DWord;   // BUTTON deactivate SG without end time on
      OFF_WITHOUT_ENDTIME_OFF : DWord;   // BUTTON deactivate SG without end time off
      REQ_NOT_OFF_NEXT_BREAK : DWord;   // BUTTON request next pause no stop
      OFF_DIAG_HMI_OFFSET : Int;   // Offset in list. 0 means display as of first entry
   END_STRUCT;

END_TYPE

TYPE "MODE_LINE_DETAIL_OUT_HMI_UDT"
VERSION : 0.1
   STRUCT
      AUT : Bool;
      AUT_AT_LEAST_ONE_FG : Bool;
      AUT_START : Bool;
      AUT_START_AT_LEAST_ONE_FG : Bool;
      MAN : Bool;   // MANUAL
      MAN_AT_LEAST_ONE_FG : Bool;
      MAN_RELEASE : Bool;   // MANUAL
      MAN_RELEASE_AT_LEAST_ONE_FG : Bool;
      SEOC : Bool;
      SEOC_AT_LEAST_ONE_FG : Bool;
      HOME : Bool;   // Complete line in home position
      EMPTY : Bool;   // Complete line empty
      RUN_EMPTY_MODE_ACTIVE : Bool;   // Physically separate mode at line level
      REQ_CONTR_STOP_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs
   END_STRUCT;

END_TYPE

TYPE "MODE_PLC_DETAIL_IN_FEEDBACK_SG"
VERSION : 0.1
   STRUCT
      EMPTY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      AUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      AUT_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      AUT_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      AUT_START_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MAN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // MANUAL
      MAN_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MAN_RELEASE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // MANUAL
      MAN_RELEASE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      HOME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      RESEQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing
      RESEQ_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing in at least one FG
      RESEQ_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing start
      RESEQ_START_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing start in at least one FG
      RESEQ_INTERLOCK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release resequencing mode
      RESEQ_INTERLOCK_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release resequencing mode in least on FG
      RESEQ_ENABLE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing is possible
      RESEQ_ENABLE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Operating mode resequencing is possible in at least one FG
      RESEQ_POSSIBLE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Resequencing of a phase is possible
      RESEQ_POSSIBLE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Resequencing of a phase is possible in at least one FG
      SHOW_DIALOG_ERROR_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs!!! Collective signal!!!
      SHOW_DIALOG_MESSAGE_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs!!! Collective signal!!!
      SEOC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      SEOC_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      RUN_EMPTY_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      RUN_EMPTY_MODE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      DRY_RUN_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      DRY_RUN_MODE_ACTIVE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ERROR_SAFETY_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      ERROR_DROP_START_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      ERROR_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      ERROR_SEOC_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      MESSAGE_PERI_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MESSAGE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      WARNING_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault at subordinate FG level
      REQ_CONTR_STOP_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Is reset by SGs without Controlled Stop
      UNPLANNED_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Total PLC in unplanned pause
      UNPLANNED_BREAK_AT_LEAST_ONE_SG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // At least one SG is in an unscheduled pause
      TPM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Total PLC in planned maintenance
      TPM_AT_LEAST_ONE_SG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // At least one SG is in planned maintenance
      REQ_PROD_END { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request end of production for PLC
      REQ_PROD_END_AT_LEAST_ONE_SG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request end of production for at least one SG
      PROD_END { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of production reached for PLC
      PROD_END_AT_LEAST_ONE_SG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of production reached for at least one FG
      REQ_PROD_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request production interruption for PLC
      REQ_PROD_BREAK_AT_LEAST_ONE_SG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request production interruption in at least one SG
      PROD_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Production interruption reached for PLC
      PROD_BREAK_AT_LEAST_ONE_SG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Production interruption reached for at least one subordinate SG
      OFF_RELEASE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release switch-off from all SGs
      OFF_RELEASE_AT_LEAST_ONE_SG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release switch-off from at least one SG
      OFF_REQUEST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request switch off PLC
      OFF_REQUEST_AT_LEAST_ONE_SG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request switch off at least one SG
      OFF_WITH_ENDTIME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch off all SGs with a final time
      OFF_WITH_ENDTIME_AT_LEAST_ONE_SG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch off at least one SG with a final time
      OFF_WITHOUT_ENDTIME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch off all SGs without a final time
      OFF_WITHOUT_ENDTIME_AT_LEAST_ONE_SG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch off at least one SG without a final time
      ON_REQUEST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request switch on SG
      OP_RELEASE_PANEL_NR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // Panel number of panel which has operator release for FG
      OP_RELEASE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // At least one has FG operator release
      NO_OP_RELEASE_AT_LEAST_ONE_FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // At least one FG does not have an operator release
      OP_RELEASE_CHANGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Panel operator release has changed
      DEVICES { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_DEVICES_MULTI_UDT";   // Information about devices of own and subordinate levels
   END_STRUCT;

END_TYPE

TYPE "MODE_PLC_DETAIL_INTERNAL_UDT"
VERSION : 0.1
   STRUCT
      PLC_NAME : String[16];
      INSTANCENAME : String[40];   // Name of calling instance block -> Code Viewer
      MESS_HANDLE_HEADER : "MESS_HANDLE_SINGLE_HEADER_UDT";
   END_STRUCT;

END_TYPE

TYPE "MODE_LINE_DETAIL_OUT_UDT"
VERSION : 0.1
   STRUCT
      EMPTY { ExternalVisible := 'False'} : Bool;
      HOME { ExternalVisible := 'False'} : Bool;   // Complete line in home position
      RUN_EMPTY_MODE_ACTIVE { ExternalVisible := 'False'} : Bool;   // Physically separate mode at line level
   END_STRUCT;

END_TYPE

TYPE "MODE_SG_DETAIL_IN_UDT"
VERSION : 0.1
   STRUCT
      ERROR_POWER_LOAD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_POWER_LOGIC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_AIR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_WATER { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_GAS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_OIL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_BUS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_SAFETY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_DROP_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      ERROR_SEOC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      MESSAGE_PERI_NOT_READY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      WARNING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Description using application blocks: "S" set
      OVERFLOW_PIC_RED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Overflow pictures > red color shift // bit 0: Figure 1
      OVERFLOW_PIC_YELLOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Overflow pictures > yellow color shift // bit 0: Figure 1
      ERROR_SEQUENCE_FLOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault material flow disposal or supply at limits of SG
      REQ_CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // User: "S" Controlled Stop request
      AUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: BA automatic (without operator release)
      START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: BA automatic or resequencing start (without operator release)
      DROP_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: Delete start (without operator release)
      MAN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: BA manual (without operator release)
      QUIT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Button: Acknowledgment (without operator release)
      PANEL_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // >>Visu: at least one panel displays this SG
      PANEL_NR_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // >>Visu: Panel number currently viewing the SG
      PROD_END { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of production reached for SG elements
      PROD_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Production interruption reached for SG elements
      OFF_WITHOUT_ENDTIME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch off SG without final time
      OFF_DIAG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_OFF_DIAG_UDT";   // Diagnostics stack device-related production line shutdown
      DEVICES { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_DEVICES_SINGLE_UDT";   // Information about devices of SG level
      IPST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_IPST_PRIORITY_UDT";   // IPS-T priorities of faults active in the level
   END_STRUCT;

END_TYPE

TYPE "MODE_SG_DETAIL_IN_COMMISSIONING_UDT"
VERSION : 0.1
   STRUCT
      NO_MODE_MANIPULATION { ExternalVisible := 'False'} : Bool;   // Do not output messages, error bits are not evaluated
      NO_MESSAGE { ExternalVisible := 'False'} : Bool;   // Do not output message
      NO_OUTPUT { ExternalVisible := 'False'} : Bool;   // Outputs are not switched
   END_STRUCT;

END_TYPE

TYPE "MODE_SG_DETAIL_OUT_UDT"
VERSION : 0.1
   STRUCT
      EXIST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SG available
      SG_EMPTY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      HOME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FG in home position
      QUIT_EDGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Edge
      QUIT_PULSE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // PULSE [300 ms]
      RUN_EMPTY_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Physically separate mode at SG level
      LIGHT_TEST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Lamp test
      DRY_RUN_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Physically separate mode at SG level
      CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Complete SG is in state: Controlled stop
      REQ_CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // SG has a controlled stop request // Collective signal: higher + own level (PLC+SG)
      SEOC_REL_GATE_ACCESS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Complete SG has release to open safety gate for HNTE
      ERROR_POWER_LOAD { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      ERROR_POWER_LOGIC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      ERROR_AIR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      ERROR_WATER { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      ERROR_GAS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      ERROR_OIL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      ERROR_BUS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      ERROR_SAFETY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      ERROR_DROP_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      ERROR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      ERROR_SEOC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      MESSAGE_PERI_NOT_READY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      WARNING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Collective signal: higher + and own level (PLC+SG)
      ERROR_SEQUENCE_FLOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Fault material flow disposal or supply fault at limits of SG
      CO_NO_MODE_MANIPULATION { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Do not output messages, error bits are not evaluated
      CO_NO_MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Do not output message
      CO_NO_OUTPUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Outputs are not switched
      PANEL_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // >>Visu: at least one panel displays this SG
      PANEL_NR_VIEW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // >>Visu: Panel number currently viewing the SG
      REQ_PROD_END { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request end of production
      PROD_END { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // End of production reached for SG
      REQ_PROD_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request production end
      PROD_BREAK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Production interruption reached for SG
      ON_REQUEST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request switch on SG
      OFF_RELEASE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release switch off SG
      OFF_REQUEST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Request switch off SG
      OFF_WITHOUT_ENDTIME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch off SG without final time
      OFF_WITH_ENDTIME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Switch off SG with final time
      OFF_ENDTIME {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;   // Mode end time
      IPST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_IPST_PRIORITY_UDT";   // IPS-T priorities of faults active in the level
   END_STRUCT;

END_TYPE

TYPE "MODE_SG_DETAIL_IN_HMI_UDT"
VERSION : 0.1
   STRUCT
      AUT : DWord;   // BUTTON_AUTOMATIK
      START : DWord;   // BUTTON AUTOMATIC or resequencing START
      REQ_CONTR_STOP : DWord;   // BUTTON_ANFORDERUNG CONTROLLED_STOP
      DROP_START : DWord;   // BUTTON_START_LOESCHEN
      MAN : DWord;   // BUTTON_HAND
      REQ_RESEQ : DWord;   // BUTTON request resequencing
      SEOC_ON : DWord;   // BUTTON_HNTE_EIN
      SEOC_OFF : DWord;   // BUTTON_HNTE_AUS
      REQ_PROD_END_ON : DWord;   // BUTTON end of production on
      REQ_PROD_END_OFF : DWord;   // BUTTON end of production off
      REQ_PROD_BREAK_ON : DWord;   // BUTTON production interruption on
      REQ_PROD_BREAK_OFF : DWord;   // BUTTON production interruption off
      RUN_EMPTY : DWord;   // BUTTON_LEERFAHREN
      DRY_RUN_ON : DWord;   // BUTTON_BAUTEILLOS_EIN
      DRY_RUN_OFF : DWord;   // BUTTON_BAUTEILLOS_AUS
      UNPLANNED_BREAK_ON : DWord;   // BUTTON unscheduled pause on
      UNPLANNED_BREAK_OFF : DWord;   // BUTTON unscheduled pause off
      TPM_ON : DWord;   // BUTTON planned maintenance on
      TPM_OFF : DWord;   // BUTTON planned maintenance off
      OFF_WITHOUT_ENDTIME_ON : DWord;   // BUTTON deactivate SG without end time on
      OFF_WITHOUT_ENDTIME_OFF : DWord;   // BUTTON deactivate SG without end time off
      OFF_DIAG_HMI_OFFSET : Int;   // Offset in list. 0 means display as of first entry
   END_STRUCT;

END_TYPE

TYPE "MODE_LINE_DETAIL_IN_HMI_UDT"
VERSION : 0.1
   STRUCT
      AUT : DWord;   // BUTTON_AUTOMATIK
      START_AUT : DWord;   // BUTTON_AUTOMATIK_START
      REQ_CONTR_STOP : DWord;   // BUTTON_ANFORDERUNG CONTROLLED_STOP
      DROP_START : DWord;   // BUTTON_START_LOESCHEN
      MAN : DWord;   // BUTTON_HAND
      SEOC_ON : DWord;   // BUTTON_HNTE_EIN
      SEOC_OFF : DWord;   // BUTTON_HNTE_AUS
      RUN_EMPTY : DWord;   // BUTTON_LEERFAHREN
   END_STRUCT;

END_TYPE

TYPE "MODE_PLC_DETAIL_OUT_HMI_UDT"
VERSION : 0.1
   STRUCT
      EMPTY : Bool;
      AUT : Bool;
      AUT_AT_LEAST_ONE_FG : Bool;
      AUT_START : Bool;
      AUT_START_AT_LEAST_ONE_FG : Bool;
      MAN : Bool;   // MANUAL
      MAN_AT_LEAST_ONE_FG : Bool;
      MAN_RELEASE : Bool;   // MANUAL
      MAN_RELEASE_AT_LEAST_ONE_FG : Bool;
      HOME : Bool;   // SG in home position
      RESEQ : Bool;   // Operating mode resequencing
      RESEQ_AT_LEAST_ONE_FG : Bool;   // Operating mode resequencing in at least one FG
      RESEQ_START : Bool;   // Operating mode resequencing start
      RESEQ_START_AT_LEAST_ONE_FG : Bool;   // Operating mode resequencing start in at least one FG
      RESEQ_INTERLOCK : Bool;   // Release resequencing mode
      RESEQ_INTERLOCK_AT_LEAST_ONE_FG : Bool;   // Release resequencing mode in least on FG
      RESEQ_ENABLE : Bool;   // Operating mode resequencing is possible
      RESEQ_ENABLE_AT_LEAST_ONE_FG : Bool;   // Operating mode resequencing is possible in at least one FG
      RESEQ_POSSIBLE : Bool;   // Resequencing of a phase is possible
      RESEQ_POSSIBLE_AT_LEAST_ONE_FG : Bool;   // Resequencing of a phase is possible in at least one FG
      SHOW_DIALOG_ERROR_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs!!! Collective signal!!!
      SHOW_DIALOG_MESSAGE_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs!!! Collective signal!!!
      SEOC : Bool;
      SEOC_AT_LEAST_ONE_FG : Bool;
      RUN_EMPTY_MODE_ACTIVE : Bool;   // Separate mode at SG level
      RUN_EMPTY_MODE_AT_LEAST_ONE_FG : Bool;
      DRY_RUN_MODE_ACTIVE : Bool;   // A separate mode only from SG on
      DRY_RUN_MODE_ACTIVE_AT_LEAST_ONE_FG : Bool;
      REQ_CONTR_STOP_AT_LEAST_ONE_FG : Bool;   // Subordinate level: Associated FGs
      ERROR_POWER_LOAD : Bool;   // Only own level: PLC!!!
      ERROR_POWER_LOGIC : Bool;   // Only own level: PLC!!!
      ERROR_AIR : Bool;   // Only own level: PLC!!!
      ERROR_WATER : Bool;   // Only own level: PLC!!!
      ERROR_GAS : Bool;   // Only own level: PLC!!!
      ERROR_OIL : Bool;   // Only own level: PLC!!!
      ERROR_BUS : Bool;   // Only own level: PLC!!!
      ERROR_SAFETY : Bool;   // Only own level: PLC!!!
      ERROR_SAFETY_AT_LEAST_ONE_FG : Bool;   // Subordinate level: SG and FGs
      ERROR_DROP_START : Bool;   // Only own level: PLC!!!
      ERROR_DROP_START_AT_LEAST_ONE_FG : Bool;   // Subordinate level: SG and FGs
      ERROR : Bool;   // Only own level: PLC!!!
      ERROR_AT_LEAST_ONE_FG : Bool;   // Subordinate level: SG and FGs
      ERROR_SEOC : Bool;   // Only own level: PLC!!!
      ERROR_SEOC_AT_LEAST_ONE_FG : Bool;   // Subordinate level: SG and FGs
      ANY_ERROR : Bool;   // Only own level: PLC!!! Collective signal!!!
      ANY_ERROR_AT_LEAST_ONE_FG : Bool;   // Subordinate level: SG and FGs!!! Collective signal!!!
      MESSAGE_PERI_NOT_READY : Bool;
      MESSAGE_PERI_AT_LEAST_ONE_FG : Bool;
      MESSAGE : Bool;   // Only own level: PLC!!!
      MESSAGE_AT_LEAST_ONE_FG : Bool;   // Subordinate level: SG and FGs
      WARNING : Bool;   // Only own level: PLC!!!
      WARNING_AT_LEAST_ONE_FG : Bool;   // Subordinate level: SG and FGs
      OVERFLOW_PIC_RED : Byte;   // Overflow pictures > red color shift // bit 0: Figure 1
      OVERFLOW_PIC_YELLOW : Byte;   // Overflow pictures > yellow color shift // bit 0: Figure 1
      HEADER_MENU_RED : Bool;   // General header: header change-over button > red color change
      HEADER_MENU_YELLOW : Bool;   // General header: header change-over button > yellow color change
      HEADER_MENU_PULLDOWN_RED : Array[0..5] of Word;   // General header: Button PullDown menu > red color change // Index 0: left Pulldown menu bit 0: top button
      HEADER_MENU_PULLDOWN_YELLOW : Array[0..5] of Word;   // General header: Button PullDown menu > red color change // Index 0: left Pulldown menu bit 0: top button
      REQ_CONTROLLED_STOP : Bool;   // Request for controlled stop active (IN interface) // only own level: PLC!!!
      OP_RELEASE_PANEL_NR : USInt;   // Panel number of panel which has operator release for FG
      OP_RELEASE_AT_LEAST_ONE_FG : Bool;   // At least one has FG operator release
      OP_RELEASE_CHANGE_NR : UInt;   // Panel operator release has changed
      ERROR_SEQUENCE_FLOW : Bool;   // Fault material flow disposal or supply fault at limits of PLC
      UNPLANNED_BREAK : Bool;   // Total PLC in unplanned pause
      UNPLANNED_BREAK_AT_LEAST_ONE_SG : Bool;   // At least one SG is in an unscheduled pause
      TPM : Bool;   // Total PLC in planned maintenance
      TPM_AT_LEAST_ONE_SG : Bool;   // At least one SG is in planned maintenance
      REQ_PROD_END : Bool;   // Request end of production
      REQ_PROD_END_AT_LEAST_ONE_SG : Bool;   // Request end of production in at least one SG
      PROD_END : Bool;   // End of production reached for PLC
      PROD_END_AT_LEAST_ONE_SG : Bool;   // End of production reached for at least one subordinate SG
      REQ_PROD_BREAK : Bool;   // Request production end
      REQ_PROD_BREAK_AT_LEAST_ONE_SG : Bool;   // Request production interruption in at least one SG
      PROD_BREAK : Bool;   // Production interruption reached for PLC
      PROD_BREAK_AT_LEAST_ONE_SG : Bool;   // Production interruption reached for at least one subordinate SG
      OFF_REQUEST : Bool;   // Request switch off PLC
      OFF_REQUEST_AT_LEAST_ONE_SG : Bool;   // Request switch off at least one SG
      OFF_RELEASE : Bool;   // Release switch off SG from all SGs
      OFF_RELEASE_AT_LEAST_ONE_SG : Bool;   // Release switch off SG from at least one SG
      OFF_IN_FUTURE_REQUEST : Bool;   // Request PLC is due for the future
      OFF_WITH_ENDTIME : Bool;   // Switch off all SGs with a final time
      OFF_WITH_ENDTIME_AT_LEAST_ONE_SG : Bool;   // Switch off at least one SG with a final time
      OFF_WITHOUT_ENDTIME : Bool;   // Switch off all SGs without a final time
      OFF_WITHOUT_ENDTIME_AT_LEAST_ONE_SG : Bool;   // Switch off at least one SG without a final time
      REQ_PROD_END_TIME {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Time at which the end of production is requested
      OFF_TIME {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Time at which the production line is to be switched off
      ON_TIME {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Time at which the production line must be ready for operation
      BREAKTIME_BLOCKED : Time;   // ProdBreak: Duration of production break due to the disposal fault
      BREAKTIME_STARVED : Time;   // ProdBreak: Duration of production break due to the supply fault
      FORCE_SWITCH_ON : Bool;   // ProdBreak: immediate activation ProdBreak active
      IPST_REQ_NOT_OFF_NEXT_BREAK {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Do not switch off next pause (EVENT_IM 33)
      IPST_SWITCH_ON {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Switch on (EVENT_IM 34)
      IPST_SWITCH_OFF {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Switch off (EVENT_IM 35)
      REQ_NOT_OFF_NEXT_BREAK_IPST : Bool;   // Status saved
      OFF_DIAG : "MODE_OFF_DIAG_UDT";   // Diagnostics stack device-related production line shutdown
      REQ_NOT_OFF_NEXT_BREAK : Bool;   // Request do not switch off next break
      TIME_TO_OFF : Time;   // Time until production line switch-off
      DEVICES : "MODE_DEVICES_MULTI_UDT";   // Information about devices of own and subordinate levels
   END_STRUCT;

END_TYPE

TYPE "MODE_LINE_PLC_DATA_UDT"
VERSION : 0.1
   STRUCT
      SIZE : USInt;   // Number of existing PLCs in the line link [1..5]
      PLC : Array[0..5] of "MODE_LINE_PLC_DETAIL_UDT";   // Detail about the individual PLCs in the line link
   END_STRUCT;

END_TYPE

TYPE "MEDIA_PN_STATE_UDT"
VERSION : 0.1
   STRUCT
      PN_IO_SYSTEMS : USInt := 1;   // Number of Profinet OK systems
      DATA_VALID_PN_IO_SYSTEM : Array[1..2] of Bool;   // PN data for master systems valid
      DEV_STATE_PLC : "MEDIA_PN_DEV_STATE_PLC_UDT";   // Summary of devices PLC and subordinate level
      DEV_STATE_SG : Array[0.."CO_MODE_SG_MAX"] of "MEDIA_PN_DEV_STATE_SG_UDT";   // Summary of devices SG and subordinate level
      DEV_STATE_FG : Array[0.."CO_MODE_FG_MAX"] of "MEDIA_PN_DEV_STATE_FG_UDT";
   END_STRUCT;

END_TYPE

TYPE "MEDIA_WOL_UDT"
VERSION : 0.1
   STRUCT
      INIT : Bool;   // Initializing of list required (1 PLC cycle)
      INIT_PULSE : Bool;   // Initializing of list required (pulse 200 ms)
      INIT_REQ : Bool;   // Request initialization of list
      SIZE : Int;   // Number of Wake On LAN devices in the PLC
      SIZE_MAX : Int := "CO_MEDIA_WOL_LIST_MAX";   // Number of maximum entries in the list
      CURRENT_OFFSET : Int;   // Current offset in the list
      ITEM : Array[0.."CO_MEDIA_WOL_LIST_MAX"] of "MEDIA_WOL_DETAIL_UDT";   // List of devices woken up by Wake On LAN
   END_STRUCT;

END_TYPE

TYPE "MESS_ARCHIVE_REG_UDT"
VERSION : 0.1
   STRUCT
      INIT : Bool;
      OVERROUND : Bool;   // After init =0. After completing one cycle =1.
      PTR_IN : Int;
      LINE : Array[1.."CO_MESS_SIZE_ARCHIVE_REGISTER_MAX"] of "MESS_REGLINE_UDT";   // Data for the individual messages in archive
   END_STRUCT;

END_TYPE

TYPE "MESS_CHANGE_UDT"
VERSION : 0.1
   STRUCT
      COUNT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Number of entries that have changed
      ITEMS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1.."SYS_MESS_ACTIVE_MESSAGE_EVENTS_MAX"] of "MESS_REGLINE_UDT";   // Data with the changes
   END_STRUCT;

END_TYPE

TYPE "MESS_SPOOL_DBL_UDT"
VERSION : 0.1
   STRUCT
      SIZE_MAX { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := "SYS_MESS_SPOOL_DBL_MAX";   // Maximum size of spool
      SIZE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number of entries in spool
      PTR_IN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Pointer for adding to buffer
      PTR_OUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Pointer for removing from buffer
      LIST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1.."SYS_MESS_SPOOL_DBL_MAX"] of "MESS_LIST_PTR_DETAIL_UDT";   // List of messages to be retrieved from MMC
      "COUNTER" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Event counter
         ACTIVITY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Activities
            INSERT_MESSAGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Message entered in spool to retrieve from load memory
         END_STRUCT;
         ERRORS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Error
            READ_REF_DB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Error reading REF_DBs
            PTR_NULL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Reference DB of message is 0
            REF_DB_NOT_INIT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Reference DB is not initialized
         END_STRUCT;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "MESS_PANEL_CHANGE_UDT"
VERSION : 0.1
   STRUCT
      GLOB_CHANGE : USInt;   // Global trigger variable for updating fault stack via all panels
      PANEL_CHANGE : Array[0..32] of USInt;   // Panel-related variable for updating the fault stack
   END_STRUCT;

END_TYPE

TYPE "MESS_REF_PTR_UDT"
VERSION : 0.1
   STRUCT
      INIT : Bool;   // Initializing of list required
      INIT_REQ : Bool;   // Request initialization of list
      SIZE_MAX : Int := "SYS_MESS_SIZE_REF_LIST_MAX";   // Number of maximum entries in the list
      SIZE : Int;   // Number of message lists in the PLC
      CURRENT_OFFSET : Int;   // Current offset in the list
      PTR : Array[0.."SYS_MESS_SIZE_REF_LIST_MAX"] of "MESS_REF_PTR_DETAIL_UDT";   // List of reference DBs used
   END_STRUCT;

END_TYPE

TYPE "TOOL_TOKEN_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      TOKEN_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      TOKEN_UNUSED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // 0: current token ID not yet considered by all blocks
      TOKEN_MAX_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Maximum number of actions per cycle (value comes from GLOB.SYS.area)
      TOKEN_CURRENT_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Current number of activities per cycle
      TOKEN_CURRENT_FREE_RESOURCES { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Current number of free resources
      TOKEN_TOTAL_FREE_RESOURCES { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Absolute number of free resources
   END_STRUCT;

END_TYPE

TYPE "MESS_DIAG_UDT"
VERSION : 0.1
   STRUCT
      NO_MESSAGE_TEXT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_GET_TEXT_SEQ_UDT";   // Text to use if no text exists
      NO_TEXT_CONFIG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_GET_TEXT_SEQ_UDT";   // Text not projected in text list
      ERROR_REF_DB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_GET_TEXT_SEQ_UDT";   // Error invalid reference DB
   END_STRUCT;

END_TYPE

TYPE "MESS_ACTIVE_REG_UDT"
VERSION : 0.1
   STRUCT
      INIT : Bool;   // Initialize messaging system
      INIT_REQ : Bool;   // Initialization of message system required
      MAX_SIZE : Int;   // Active register size
      MAX_ACTIVE : Int;   // Maximum number of actions
      CUR_ACTIVE : Int;   // Actual number of activities
      COUNT_MESS_HANDLER : Int;   // Number of measurement handlers called
      COUNT_CHANGE : Bool;   // A difference in the local count was detected in at least one FB
      CYCLE_ID : Int;   // Consecutive cycle ID: INC1 per cycle
      COUNT_ACTIVE_MESSAGES : Int;   // Count variable number of active/open messages
      ACTIVE_MESSAGES : Int;   // Number of active/open messages
      PTR_IN : Int;   // Pointer entry
      LINE_INDEX : Array[1.."CO_MESS_SIZE_ACTIVE_REGISTER_MAX"] of Int;   // Pointer field
      LINE : Array[1.."CO_MESS_SIZE_ACTIVE_REGISTER_MAX"] of "MESS_REGLINE_UDT";   // Data for the individual messages
   END_STRUCT;

END_TYPE

TYPE "PANEL_DEVICE_UDT"
VERSION : 0.1
   STRUCT
      DEV_CHANGE_ACTIVE : Bool;   // Actuator change is activated
   END_STRUCT;

END_TYPE

TYPE "PANEL_CONFIG_PANEL_UDT"
VERSION : 0.1
   STRUCT
      exist : Bool;   // OEM: Set bit if panel available
      PanelName : String[32];   // Name of panel as per AKZ
      assign_LINE : Bool;   // OEM: Set bit if panel is permitted to operate LINE
      assign_PLC : Bool;   // OEM: Set bit if panel is permitted to operate PLC
      assign_SG : Array[0.."CO_MODE_SG_MAX"] of Bool;   // OEM: Set bit if panel is permitted to operate SGxx
      assign_FG : Array[0.."CO_MODE_FG_MAX"] of Bool;   // OEM: Set bit if panel is permitted to operate FGxx
   END_STRUCT;

END_TYPE

TYPE "PANEL_HMI_REQ_TO_PANEL_UDT"
VERSION : 0.1
   STRUCT
      REQUEST_ACTIVE : Bool;   // Request pending
      REQUEST_FROM : Int;   // Request comes from panel xx
      REQUEST_PLC : Bool;   // Request for whole PLC from another panel
      REQUEST_SG : Int;   // Request for SGxx from another panel
      REQUEST_FG : Int;   // Request for FGxx from another panel
      REQUEST_CONFIG : Bool;   // Request for configured area from the other panel
      BUTTON_ACCEPT : Bool;   // Accept request
      BUTTON_DEFEAT : Bool;   // Reject request
      DELETE_RELEASE : Bool;   // Delete operator release of own panel
      REMAINING_TIME : Int;   // Time remaining in which the window is still shown
   END_STRUCT;

END_TYPE

TYPE "MODE_SG_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      IN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_SG_DETAIL_IN_UDT";
      IN_COMMISSIONING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_SG_DETAIL_IN_COMMISSIONING_UDT";
      OUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_SG_DETAIL_OUT_UDT";
      IN_HMI : "MODE_SG_DETAIL_IN_HMI_UDT";   // ONLY the VISU writes here: 1*setting DWORD: Panel[1..32]
      "IN_FEEDBACK_<<_FG" : "MODE_SG_DETAIL_IN_FEEDBACK_FG";
      OUT_HMI : "MODE_SG_DETAIL_OUT_HMI_UDT";
      INTERNAL : "MODE_SG_DETAIL_INTERNAL_UDT";
   END_STRUCT;

END_TYPE

TYPE "MODE_PLC_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      IN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_PLC_DETAIL_IN_UDT";
      IN_COMMISSIONING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_PLC_DETAIL_IN_COMMISSIONING_UDT";
      OUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_PLC_DETAIL_OUT_UDT";
      IN_HMI : "MODE_PLC_DETAIL_IN_HMI_UDT";
      "IN_FEEDBACK_<<_SG" : "MODE_PLC_DETAIL_IN_FEEDBACK_SG";
      OUT_HMI : "MODE_PLC_DETAIL_OUT_HMI_UDT";
      INTERNAL : "MODE_PLC_DETAIL_INTERNAL_UDT";
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      IN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_FG_DETAIL_IN_UDT";
      IN_COMMISSIONING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_FG_DETAIL_IN_COMMISSIONING_UDT";   // Commissioning bits: to be set by user
      OUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_FG_DETAIL_OUT_UDT";
      IN_HMI : "MODE_FG_DETAIL_IN_HMI_UDT";   // ONLY the VISU writes here: 1*setting DWORD: Panel[1..32]
      IN_HMI_FROM_UP_LEV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_FG_DETAIL_IN_HMI_FROM_UP_LEV_UDT";   // Is described by standard FBs; not directly by visu!
      OUT_HMI : "MODE_FG_DETAIL_OUT_HMI_UDT";
      INTERNAL : "MODE_FG_DETAIL_INTERNAL_UDT";
      DIALOG : "MODE_FG_DETAIL_DIALOG_UDT";
   END_STRUCT;

END_TYPE

TYPE "SYS_CONST_UDT"
VERSION : 0.1
   STRUCT
      FG_MAX : Int := "CO_MODE_FG_MAX";   // Maximum number of FGs
      SG_MAX : Int := "CO_MODE_SG_MAX";   // Maximum number of SGs
      PANEL_MAX : Int := 20;   // Maximum number of panels
      MAX_SIZE_ACTIVE_REGISTER : Int := "CO_MESS_SIZE_ACTIVE_REGISTER_MAX";   // Maximum number of messages in active register
      MAX_SIZE_ARCHIVE_REGISTER : Int := "CO_MESS_SIZE_ARCHIVE_REGISTER_MAX";   // Maximum number of messages in archive register
      MAX_ACTIVE_MESSAGE_EVENTS : Int := "SYS_MESS_ACTIVE_MESSAGE_EVENTS_MAX";   // Maximum number of messages per PLC cycle
      MAX_SIZE_REF_LIST : Int := "SYS_MESS_SIZE_REF_LIST_MAX";   // Maximum number of message lists
      MESS : Struct   // Classes for outputting fault messages
         ERROR_SAFETY : Int := 8;   // Fault with loss manual release
         ERROR_DROP_START : Int := 9;   // Fault with loss automatic start
         ERROR_NOT_DROP_START : Int := 10;   // Fault without loss automatic start
         ERROR_SEOC : Int := 11;   // Fault stop after end of cycle
         CONTROLLED_STOP : Int := 14;   // Controlled stop
         WARNING : Int := 13;   // Warning (leads to production line standstill over a longer period of time)
         MESSAGE : Int := 12;   // Message (information without any effect on the production line)
         MESSAGE_PERI_NOT_READY : Int := 16;
         ERROR_SEQUENCE_FLOW : Int := 15;   // Fault material flow disposal or supply fault at limits of SG
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "SYS_TIME_UDT"
VERSION : 0.1
   STRUCT
      SYSTEM {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // CPU15xx: DTL: access to individual elements possible from then
      LOCAL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      LAST_SYNC {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Last time for time change
      TRIG_TIME_SYNC : Bool;   // Pulse 1 cycle: Time was synchronized
      SUMMER_WINTER : Bool;   // TRUE: BUZZER
      CYCLE_TIME_SUM : LTime;   // Runtime CPU, corresponds to TIME_TCK for data type LTIME
   END_STRUCT;

END_TYPE

TYPE "PANEL_PLC_REQ_FROM_PANEL_UDT"
VERSION : 0.1
   STRUCT
      REQUEST_NEW : Bool;   // Request is being placed (via key switch)
      REQUEST_PLC : Bool;   // Request for whole PLC
      REQUEST_SG : Int;   // Request for SGxx
      REQUEST_FG : Int;   // Request for FGxx
      REQUEST_CONFIG : Bool;   // Request for configured area
      REQUEST_RECENT : Bool;   // Request currently being tested (1/cycle)
      REQUEST_IN_PROGRESS : Bool;   // Request is currently being processed (10 s)
      REMAINING_TIME : Int;   // Remaining display time [s]
      REQUEST_TO_PANEL : Array[0..32] of Bool;   // Request goes to panels...(for visualization display)
      BUTTON_FORCE_RELEASE : Bool;   // Immediate retrieval of operator release
      BUTTON_F_REL_VISIBLE : Bool;   // Button FORCE_RELEASE visible
   END_STRUCT;

END_TYPE

TYPE "SYS_PLC_UDT"
VERSION : 0.1
   STRUCT
      CYCLE_TIME : Real;   // Cycle time of PLC
      "CYCLE_TIME_100µs" : UInt;   // Cycle time of PLC in 100 µs
      IP_ADDRESS : Array[0..4] of USInt;   // IP address of CPU
      CYCLE_TIME_LEVEL : "SYS_PLC_LEVEL_CYCLE_TIME";   // Cycle times of SGs, FGs, ...
   END_STRUCT;

END_TYPE

TYPE "PANEL_HMI_COMMON_UDT"
VERSION : 0.1
   STRUCT
      GLOBAL_TASK : Array[0..16] of Bool;   // Trigger bits for HMI task scheduler (topic-related) // bit 1: SAP // bit 2: RobBackup
      QUALITY_RELEVANT_INTERVENTION_AUTHORIZATION : USInt;   // HMI authorization level for quality-related process interventions 0 => none, 5 => expert
   END_STRUCT;

END_TYPE

TYPE "PANEL_HMI_INTFACE_PANEL_UDT"
VERSION : 0.1
   STRUCT
      FROM_PANEL : "PANEL_HMI_INTFACE_FROM_PANEL_UDT";
      TO_PANEL : "PANEL_HMI_INTFACE_TO_PANEL_UDT";
   END_STRUCT;

END_TYPE

TYPE "PANEL_MASTER_DATA_HEADER_UDT"
VERSION : 0.1
   STRUCT
      PANEL_NR : Int;   // x: Number of panel with operator release / 0: No panel has release
      EXCLUSIVE : Bool;   // TRUE: PANEL was exclusively selected / no request from other panel possible
   END_STRUCT;

END_TYPE

TYPE "PANEL_BUTTON_PANEL_UDT"
VERSION : 0.1
   STRUCT
      AUT : Bool;   // BUTTON_AUTOMATIK (linked to operator release)
      START : Bool;   // BUTTON START automatic or resequencing (linked to operator release)
      DROP_START : Bool;   // BUTTON_START_LOESCHEN (linked to operator release)
      MAN : Bool;   // BUTTON_HAND (linked to operator release)
      RESEQ : Bool;   // BUTTON Resequencing (linked to operator release)
      QUIT : Bool;   // BUTTON ACKNOWLEDGE (linked to operator release)
      MAN_ADVANCE : Bool;   // BUTTON MANUAL ADVANCE (linked to operator release)
      MAN_RETRACT : Bool;   // BUTTON MANUAL RETRACT (linked to operator release)
      FAST : Bool;   // BUTTON FAST (linked to operator release)
      SERVICE_MODE : Bool;   // SS service mode (linked to operator release)
      ENDPOS_IGNORED : Bool;   // SS without final positions (linked to operator release)
      REQ_OP_RELEASE : Bool;   // SS request operator release
      REQ_OP_RELEASE_DEL : Bool;   // SS request operator release delayed
      REQ_CONFIG_DEL : Bool;   // SS request operator release for configured area delayed
      EXCLUSIVE_MODE : Bool;   // Configuration parameter: TRUE = exclusive operation
   END_STRUCT;

END_TYPE

TYPE "PANEL_MASTER_DATA_FG_UDT"
VERSION : 0.1
   STRUCT
      PANEL_NR : Int;   // x: Number of panel with operator release / 0: No panel has release
      SG_NR : Int;   // x: Number of superordinate SG / 0: FG does not exist
      EXCLUSIVE : Bool;   // TRUE: FG was exclusively selected / no request from other panel possible
   END_STRUCT;

END_TYPE

TYPE "PANEL_OP_REL_PANEL_UDT"
VERSION : 0.1
   STRUCT
      LINE : Struct   // Operator release for LINE: complete/partial
         COMPLETE : Bool;
         AT_LEAST_ONE_FG : Bool;
      END_STRUCT;
      PLC : Struct   // Operator release for PLC: complete/partial
         COMPLETE : Bool;
         AT_LEAST_ONE_FG : Bool;
      END_STRUCT;
      SG : Array[0.."CO_MODE_SG_MAX"] of Struct   // Operator release for SGxx: complete/partial
         COMPLETE : Bool;
         AT_LEAST_ONE_FG : Bool;
      END_STRUCT;
      FG : Array[0.."CO_MODE_FG_MAX"] of Struct   // Operator release for FG
         COMPLETE : Bool;
      END_STRUCT;
   END_STRUCT;

END_TYPE

TYPE "MODE_LINE_DETAIL_UDT"
VERSION : 0.1
   STRUCT
      OUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MODE_LINE_DETAIL_OUT_UDT";
      IN_HMI : "MODE_LINE_DETAIL_IN_HMI_UDT";
      OUT_HMI : "MODE_LINE_DETAIL_OUT_HMI_UDT";
      LINE_PLC_DATA : "MODE_LINE_PLC_DATA_UDT";
   END_STRUCT;

END_TYPE

TYPE "MEDIA_UDT"
VERSION : 0.1
   STRUCT
      PN_STATE : "MEDIA_PN_STATE_UDT";   // Signals on all bus systems of PLC
      WOL : "MEDIA_WOL_UDT";   // Interface Wake on LAN
   END_STRUCT;

END_TYPE

TYPE "TOOL_TOKEN_UDT"
VERSION : 0.1
   STRUCT
      GET_SYMBOL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "TOOL_TOKEN_DETAIL_UDT";   // Cycle distributor trigger GetSymbol
      MESS_PANEL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "TOOL_TOKEN_DETAIL_UDT";   // Cycle distributor message output panel filter
      RD_WR_REC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "TOOL_TOKEN_DETAIL_UDT";   // Resource distributor data access via RDREC, WRREC
   END_STRUCT;

END_TYPE

TYPE "PANEL_ORG_UDT"
VERSION : 0.1
   STRUCT
      HMI_INTFACE_PANEL : Array[0..32] of "PANEL_HMI_INTFACE_PANEL_UDT";
      CONFIG_PANEL : Array[0..32] of "PANEL_CONFIG_PANEL_UDT";   // OEM: Configuration maximum operating area
      BUTTON_PANEL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..32] of "PANEL_BUTTON_PANEL_UDT";
      MASTER_HEADER : "PANEL_MASTER_DATA_HEADER_UDT";   // Header operator release management
      MASTER_DATA_FG : Array[0.."CO_MODE_FG_MAX"] of "PANEL_MASTER_DATA_FG_UDT";   // FG operator release management
      OP_REL_PANEL : Array[0..32] of "PANEL_OP_REL_PANEL_UDT";   // Panel releases for FGs and as feedback for SGs, PLC
      OP_REL_PANEL_PRESET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "PANEL_OP_REL_PANEL_UDT";   // Data structure for preallocation in the FB
      HMI_REQ_TO_PANEL : Array[0..32] of "PANEL_HMI_REQ_TO_PANEL_UDT";   // Active requests for operator release from another panel >> VISU
      PLC_REQ_FROM_PANEL : Array[0..32] of "PANEL_PLC_REQ_FROM_PANEL_UDT";   // Request for operator release << PLC
      DEV_PANEL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..32] of "PANEL_DEVICE_UDT";   // Panel-related data exchange for managing actuators
      MESS : "MESS_PANEL_CHANGE_UDT";   // Update fault stack organization in panels
      HMI_COMMON : "PANEL_HMI_COMMON_UDT";   // Trigger bits for HMI task scheduler (topic-related)
   END_STRUCT;

END_TYPE

TYPE "SYS_UDT"
VERSION : 0.1
   STRUCT
      Clock_10Hz : Bool;   // Cycle marker from CPU
      Clock_5Hz : Bool;   // Cycle marker from CPU
      Clock_2_5Hz : Bool;   // Cycle marker from CPU
      Clock_2Hz : Bool;   // Cycle marker from CPU
      Clock_1_25Hz : Bool;   // Cycle marker from CPU
      Clock_1Hz : Bool;   // Cycle marker from CPU
      Clock_0_625Hz : Bool;   // Cycle marker from CPU
      Clock_0_5Hz : Bool;   // Cycle marker from CPU
      FirstScan : Bool;   // Start-up pulse
      DiagStatusUpdate : Bool;
      F_MODE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;   // 1 = disabled safety operation
      AlwaysTRUE : Bool;   // ROL 1: always "1" signal
      AlwaysFALSE : Bool;   // ROL 0: always "0" signal
      AlwaysTRUE_CO : Bool;   // ROL 1: always "1" signal commissioning
      AlwaysFALSE_CO : Bool;   // ROL 0: always "0" signal commissioning
      AlwaysTRUE_SAS : Bool;   // ROL 1: "1" always generated by SAS, must be adapted
      AlwaysFALSE_SAS : Bool;   // ROL 0: always "0" generated by SAS, must be adapted
      "CONST" : "SYS_CONST_UDT";   // System constants
      "TIME" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "SYS_TIME_UDT";   // System times
      AKZ : String[10];   // Production line identification code: CPU name
      TIME_STAMP_MCX_HMI_PROJECT : String[20];   // Time stamp of HMI runtime project file
      THIRD_HMI_LANGUAGE : Int;   // Third language for panels [3 to 6] or 0
      DEFAULT_HMI_LANGUAGE : Int;   // Standard language for panels (default) [1..6]
      PLC : "SYS_PLC_UDT";   // PLC status information
      "TYPE" : Array[0..255] of USInt;   // Type ID of used types
   END_STRUCT;

END_TYPE

TYPE "MESS_REF_UDT"
VERSION : 0.1
   STRUCT
      INIT : Bool;   // Reference DB is initialized
      "FAMILY" : String[8];   // Family name of list
      PTR_DB : DB_ANY;   // DB number pointer RAM DB
      TEXT_DB : DB_ANY;   // DB number texts RAM DB
      PTR_L_DB : DB_ANY;   // DB number pointer load memory DB
      TEXT_L_DB : DB_ANY;   // DB number texts load memory DB
      ACT_DB : DB_ANY;   // DB number currentness DB
      REF_DB : DB_ANY;   // DB number reference DB
      GENERATE_DATE {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Time at which the list was generated
      SIZE_PTR_DB : DInt;   // Number of pointer field entries
      SIZE_TEXT_DB : Int;   // Number of texts entries RAM DB
      SIZE_TEXT_L_DB : Int;   // Number of text entries load memory DB
      SIZE_ACT_DB : Int;   // Number of entries in currentness DB
   END_STRUCT;

END_TYPE

TYPE "MODE_UDT"
VERSION : 0.1
   STRUCT
      RECENT_FG : Int;   // Current FG
      RECENT_SG : Int;   // Current SG
      LINE : "MODE_LINE_DETAIL_UDT";   // LINE level (several PLCs)
      PLC : "MODE_PLC_DETAIL_UDT";   // PLC level, the entire PLC
      SG : Array[0.."CO_MODE_SG_MAX"] of "MODE_SG_DETAIL_UDT";   // SG level, safety groups
      FG : Array[0.."CO_MODE_FG_MAX"] of "MODE_FG_DETAIL_UDT";   // FG level, function groups
   END_STRUCT;

END_TYPE

TYPE "MESS_ACT_UDT"
VERSION : 0.1
   STRUCT
      TEXT_NR : UInt;   // Text number
      "COUNTER" : UInt;   // Access counter
   END_STRUCT;

END_TYPE

TYPE "MESS_UDT"
VERSION : 0.1
   STRUCT
      ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_ACTIVE_REG_UDT";   // Active register
      ARCHIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_ARCHIVE_REG_UDT";   // Archive register
      CHANGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_CHANGE_UDT";   // List of changes in fault message register
      SPOOL_DBL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_SPOOL_DBL_UDT";   // List of messages to be retrieved from load memory
      REF_PTR : "MESS_REF_PTR_UDT";   // Message lists management
      DIAG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_DIAG_UDT";   // Diagnostics information for messaging system
   END_STRUCT;

END_TYPE

FUNCTION "MESS_UPDATE_ACT_DB_FC" : Word
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      INDEX : Int;   // Index in the
      TEXT_NR : Int;   // Message number to update
   END_VAR

   VAR_IN_OUT 
      "REF" : "MESS_REF_UDT";   // References
   END_VAR

   VAR_TEMP 
      ret : Int;
      intError : Word;
      WorkField : "MESS_ACT_UDT";
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             MESS_UPDATE_ACT_DB_FC     
	              Kommentar :         Updaten der Act DB für eine Meldung
	    
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR
	              Datum :             12.04.2013        
	              Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                                  [ ] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [x] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	Wird eine Meldung von der Steuerung verwendet wird im Aktualitäts DB der Zähler für diese Meldung auf den größten Wert 
	gesetzt. Mit dieser Methode ist es möglich die älteste Meldung zu ermitteln
	
	
	****************************************************************************************************************************
	Rückgabewerte
	
	@DESCRIPTION_DIAG@
	Binärwert Hexwert Beschreibung
	yyyyyyyy_xxxxxxxx yyxx  yy = Störklasse, xx = Meldenummer
	    
	10100000_00100000 A020  Fehler beim Auslesen des letzten Feld im Act DB
	10100000_00100001 A021  Fehler beim Schreiben des letzten Feld im Act DB
	10100000_00100010 A022  Fehler beim Schreiben des Index Feld im Act DB
	00000000_00000000 0000  Kein Fehler
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Autor             Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	12.04.2013  Breu              Grundversion
	24.04.2013  Breu              Siemens Bausteine hab als Rückgabewerte nun einen INT. 
	@CHANGELOG@
	*)
	
	
	//Auslesen des letzten Feld aus dem Act DB
	#ret := ReadFromArrayDB(db:=#REF.ACT_DB, index:=#REF.SIZE_ACT_DB , value=>#WorkField);
	
	//Fehler auswerten
	IF #ret <> 0 THEN
	  #intError := w#16#a020;
	ELSE
	    
	  //Zugriffszähler erhöhen 
	  IF #WorkField.COUNTER < 65535 THEN
	    #WorkField.COUNTER := #WorkField.COUNTER + 1;
	  
	    //Schreibe den maximalen zugriffszähler zurück
	    #ret := WriteToArrayDB(db:=#REF.ACT_DB, index:=#REF.SIZE_ACT_DB, value:=#WorkField);
	    //Fehler auswerten
	    IF #ret <> 0 THEN
	      #intError := w#16#a021;
	    ELSE
	      //Schreibe den Zugriffszähler auch in das Feld für den Text
	      #WorkField.TEXT_NR := #TEXT_NR;
	      #ret := WriteToArrayDB(db:=#REF.ACT_DB, index:=#INDEX , value:=#WorkField);
	      IF #ret <> 0 THEN
	        #intError := w#16#a022;
	      END_IF;//Fehlerauswertung Schreiben Zugriffszähler Text
	    END_IF;//Fehlerauswertung Schreiben letztes Feld
	  END_IF;//Abfrage zugriffszähler im gültigen bereich
	END_IF;//Fehlerauswertung Lesen letztes Feld
	  
	//Reückgabewert aufbereiten  
	#MESS_UPDATE_ACT_DB_FC := #intError;  
END_FUNCTION

FUNCTION "MESS_SPOOL_UPDATE_SIZE_FC" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_IN_OUT 
      MESS_DBL : "MESS_SPOOL_DBL_UDT";   // List of all messages that are retrieved
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             MESS_SPOOL_UPDATE_SIZE_FC   
	              Kommentar :         Berechnet die Anzahl der Einträge im Spool der Meldungen die vom Ladespeicher 
	                                  geholt werden soll
	    
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR                   
	              Datum :             26.04.2013  
	              Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                                  [x] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [ ] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	            Hardware- Bindung     [] 319F   [ ] 15xx           [x] auf 319F und 15xx lauffähig
	            Aufrufumgebung        [] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	            aufgerufene Bausteine    :   keine weiteren                                     
	
	   
	
	@DESCRIPTION_DIAG@
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Autor       Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	26.04.2012  Breu        Grundversion
	@CHANGELOG@
	*)
	
	
	//Berechnen wieviele Datensätze belegt sind
	IF #MESS_DBL.PTR_IN >= #MESS_DBL.PTR_OUT THEN 
	  #MESS_DBL.SIZE := #MESS_DBL.PTR_IN - #MESS_DBL.PTR_OUT;
	ELSE
	  #MESS_DBL.SIZE := #MESS_DBL.SIZE_MAX - #MESS_DBL.PTR_OUT +  #MESS_DBL.PTR_IN - 1;
	END_IF;
	
END_FUNCTION

TYPE "MESS_HANDLE_SINGLE_UDT"
VERSION : 0.1
   STRUCT
      ERROR_CLASS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Class error
      IPST_PRIO { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Char;   // IPS-T priority
      OPERAND { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[30];   // Operand designator (if available)
      PAGING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // Paging
      CODE_VIEWER { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Allow Code Viewer call in its different forms
      EPLAN_VIEWER { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Allow EPLAN viewer call
      PN_DEVICE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Message relates to PN device with further functionality: Web server, PN diagnostics, etc.
      OVERFLOW_PIC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Location of reporting element, if overflow pictures present
      FIRST_UP_FAULT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // First-up value fault
      IPST_SEND { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Message must be sent to IPS-T
      COMMISSIONING_MODE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning mode from the block CONF interface
      HEADER_VALID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Header valid, to be used for message transmission
      LIST_PTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..2] of "MESS_LIST_PTR_DETAIL_UDT";
      HEADER { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_HANDLE_SINGLE_HEADER_UDT";   // Message header: Information on reporting block
   END_STRUCT;

END_TYPE

TYPE "IPSL_TYPE_GET_DATA_ORG_CONF_UDT"
VERSION : 0.1
   STRUCT
      KEYTYPE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // Key type for request (IG, PN or ID)
      KEY_PREFIX { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Prefix key (e.g., component, ID type)
      CHECK_CHECKSUM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate checksum check
      AUTOCOPY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // If data is valid, move automatically to data place
      BYPASS_OP_RELEASE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // No operator release necessary for request and move
      IPSL_SUB_ON_OFF { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // IPS-L data request sub-blocks allowed = 1, not allowed = 0
   END_STRUCT;

END_TYPE

TYPE "GLOB_UDT"
VERSION : 0.1
   STRUCT
      MODE : "MODE_UDT";   // Operating modes
      SYS : "SYS_UDT";   // System configuration
      PANEL_ORG : "PANEL_ORG_UDT";   // Panel organization
      MESS : "MESS_UDT";   // Fault messages
      MEDIA : "MEDIA_UDT";   // Media status overview (Profinet)
      TOKEN : "TOOL_TOKEN_UDT";   // Control of non-cyclical processes
   END_STRUCT;

END_TYPE

TYPE "TYPE_IPSL_GET_DATA_SEQ_UDT"
VERSION : 0.1
   STRUCT
      REQUEST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // IN: Request status change
      BUSY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // OUT: Requirement active
      DONE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // INOUT: Finished
      REFERENCE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // OUT: Reference from data place
      ERROR_CS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // INOUT: Error checksum
      ERROR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // INOUT: Error
      RESET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // OUT: Reset was carried out
      GLOB_CONF { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "IPSL_TYPE_GET_DATA_ORG_CONF_UDT";   // OUT: Configuration global
      CHECK_CHECKSUM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // OUT: Check checksum enabled
      KEY_PREFIX { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // IN: Prefix key (e.g., component or ID type)
      KEYTYPE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // IN: Key type for request (IG, PN or ID)
      KEY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // IN: Part key for request
      CHECKSUM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[2];   // IN: Checksum from manual input
   END_STRUCT;

END_TYPE

FUNCTION "MODE_ANIMATE_OV_PIC_REV2_FC" : Void
TITLE = MODE_ANIMATE_OV_PIC_REV2_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW_TUE
FAMILY : MODE
VERSION : 0.1
//Animate overflow pictures in yellow or red
//Block evaluates OVERFLOW_PIC from the MESS_HANDLE_SINGLE_UDT structure!
//The OVERFLOW_PIC bit array is used to generate a general flag for animating the buttons (red or yellow) for each overflow picture that contains the respective component
//OVERFLOW_PIC.x0      :       Basic picture
//OVERFLOW_PIC.x1..7   :       Overflow picture 1..7
//default: OVERFLOW_PIC = 0    means basic picture
   VAR_INPUT 
      MESS_HANDLER : "MESS_HANDLE_SINGLE_UDT";   // Active message :   Data structure
   END_VAR

   VAR_IN_OUT 
      GLOB : "GLOB_UDT";   // Global data
      OVERFLOW_PIC_RED : Byte;   // Overrun images > red color shift //  Bit 0 : Figure 1:
      OVERFLOW_PIC_YELLOW : Byte;   // Overrun images > yellow color shift //  Bit 0 : Figure 1:
   END_VAR

   VAR_TEMP 
      OverflowPicRed : Byte;
      OverflowPicYellow : Byte;
      AF_OverflowPic : Byte;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             MODE_ANIMATE_OV_PIC_REV2      
	              Kommentar :         Überlaufbilder gelb oder rot animieren
	                                  Baustein wertet OVERFLOW_PIC aus der MESS_HANDLE_SINGLE_UDT Struktur aus !
	                                  Mit der Bitleiste OVERFLOW_PIC wird für jedes Überlaufbild, auf dem sich die jeweilige Komponente befindet,
	                                  ein Sammelmerker zur Animation der Buttons generiert (rot oder gelb)
	                                  OVERFLOW_PIC.x0      :       Grundbild
	                                  OVERFLOW_PIC.x1..7   :       Überlaufbild 1..7
	                                  default : OVERFLOW_PIC = 0    bedeutet Grundbild
	              Copyright 20xx      BMW AG .....
	              Ersteller :         TP-114 Schnellbögl                  
	
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	            Hardware- Bindung     [x]  15xx    
	            Aufrufumgebung        [x] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	            
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	es gibt kein Diagnosewort !
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version    Autor        Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	21.07.2014  V1.33.x    Schnellbögl  Umstellung auf MESS_HANDLE_SINGLE_UDT
	13.04.2015  V1.34.x    Schnellbögl  Bugfix bei Rangierung Overflow_Pic
	19.05.2015  V1.35.x    Schnellbögl  Versionsanpassung gegenüber HF3 Stand
	30.09.2016  V1.36.x    Schnellbögl  Integration MESS_PERI_NOT_READY
	@CHANGELOG@
	*)
	
	// Defaultwert als Grundbild betrachten
	IF #MESS_HANDLER.OVERFLOW_PIC = 0 THEN
	  #AF_OverflowPic := 1;
	ELSE
	  #AF_OverflowPic := #MESS_HANDLER.OVERFLOW_PIC;
	END_IF;
	// ist überhaupt eine Meldung vorhanden
	IF (#MESS_HANDLER.ERROR_CLASS <> 0) THEN
	  
	  // rote Farbe
	  IF (#MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_SAFETY) OR
	    (#MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_DROP_START) OR
	    (#MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START) OR
	    (#MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_SEOC) THEN
	    #OverflowPicRed := #AF_OverflowPic;
	  END_IF;
	  // gelbe Farbe
	  IF (#MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.MESSAGE) OR
	    (#MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.MESSAGE_PERI_NOT_READY) OR
	    (#MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.WARNING) THEN
	    #OverflowPicYellow := #AF_OverflowPic;
	  END_IF;
	END_IF;
	
	#OVERFLOW_PIC_RED := #OVERFLOW_PIC_RED OR #OverflowPicRed;
	#OVERFLOW_PIC_YELLOW := #OVERFLOW_PIC_YELLOW OR #OverflowPicYellow;
	
END_FUNCTION

TYPE "TYPE_REF_UDT"
VERSION : 0.1
   STRUCT
      REFERENZ : Int;   // Reference to dataset
      RESTORE : Bool;   // Restore dataset
      ERROR_TYPE : Bool;   // Parts present and type do not match
   END_STRUCT;

END_TYPE

FUNCTION "MODE_GET_LEVEL_INFO_FC" : Int
TITLE = MODE_GET_LEVEL_INFO_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW
FAMILY : MODE
//Block identifies the level in which this block was called using the two variables #GLOB.MODE.RECENT_FG and #GLOB.MODE.RECENT_SG. The following values are return values:
//0: no valid level information available
//1: block called in PLC level
//2: block called in SG level
//3: block called in FG level
   VAR_IN_OUT 
      GLOB { S7_HiddenAssignment := 'Hide'} : "GLOB_UDT";   // Global data
   END_VAR

   VAR_TEMP 
      FgNr : Int;
      SgNr : Int;
      RetVal : Int;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             MODE_GET_LEVEL_INFO_FC     
	              Kommentar :         Baustein ermittelt anhand der beiden Variablen #GLOB.MODE.RECENT_FG und 
	                                  #GLOB.MODE.RECENT_SG die Ebene in der dieser 
	                                  Baustein aufgerufen wurde. Als Rückgabewert ist gibt es folgende Werte:
	                                  0: keine gültige Ebeninformation vorhanden
	                                  1: Baustein in der PLC Ebene aufgerufen
	                                  2: Baustein in der SG Ebene aufgerufen
	                                  3: Baustein in der FG Ebene aufgerufen
	
	    
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR                   
	              Version :           V 0.1      
	              Datum :             24.07.2013        
	              Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                                  [ ] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [x] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	
	
	@DESCRIPTION_DIAG@
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version   Autor         Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	09.03.2013  V0.1      Breu          Ersterstellung
	24.07.2013  V0.1      Breu          Dokumentation
	11.03.2015  V1.34.x   Schnellbögl   Umstellung auf globale Konstanten  CO_MODE_FG_MAX, CO_MODE_SG_MAX 
	@CHANGELOG@
	*)
	
	
	//Ebeneninformation auslesen
	#FgNr := #GLOB.MODE.RECENT_FG;
	#SgNr := #GLOB.MODE.RECENT_SG;
	
	//Auswerten auf welcher Ebene der Baustein aufgerufen wurde
	IF #FgNr = 0 AND #SgNr = 0 THEN
	  #RetVal := 1;
	ELSIF #FgNr = 0 AND #SgNr > 0 AND #SgNr <= "CO_MODE_SG_MAX" THEN
	  #RetVal := 2;
	ELSIF #SgNr > 0 AND #SgNr <= "CO_MODE_SG_MAX"  AND #FgNr > 0 AND #FgNr <= "CO_MODE_FG_MAX"  THEN
	  #RetVal := 3;
	END_IF;
	
	//Funktion verlassen
	#MODE_GET_LEVEL_INFO_FC := #RetVal;
	
END_FUNCTION

FUNCTION "MESS_SPOOL_ADD_GET_DBL_FC" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      NEW_MESS : "MESS_LIST_PTR_DETAIL_UDT";   // New message to be displayed
   END_VAR

   VAR_IN_OUT 
      MESS_DBL : "MESS_SPOOL_DBL_UDT";   // List of all messages that are retrieved
   END_VAR

   VAR_TEMP 
      "ref" : "MESS_REF_UDT";
      ptrDBNr : Int;
      ptrNr : Int;
      RetI : Int;
      RetW : Word;
      insert : Bool;
      index : Int;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             MESS_SPOOL_ADD_GET_DBL_FC     
	              Kommentar :         Prüfen ob eine Meldung schon im Arbeitspeicher vorhanden ist. 
	                                  Wenn ja, wird der aktuallitätszähler erhöht
	                                  Wenn nein, wird die Meldung in einen Spool zum abholen aus den Ladespeicher geholt
	    
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR                   
	              Datum :             14.03.2012        
	              Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                                  [x] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [ ] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	            Hardware- Bindung     [] 319F   [ ] 15xx           [x] auf 319F und 15xx lauffähig
	            Aufrufumgebung        [] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	            aufgerufene Bausteine    :   keine weiteren                                     
	
	   
	
	@DESCRIPTION_DIAG@
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Autor       Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	26.04.2012  Breu        Grundversion
	@CHANGELOG@
	*)
	
	//****************************************************************************************************************************
	//Prüfen der Zeiger und korrigieren
	//****************************************************************************************************************************
	IF #MESS_DBL.PTR_OUT < 1  OR #MESS_DBL.PTR_IN < 1 THEN
	  #MESS_DBL.PTR_OUT := 1;
	  #MESS_DBL.PTR_IN := 1;
	END_IF;
	
	
	IF DB_ANY_TO_UINT(#NEW_MESS.DB) <> 0 THEN
	  //Auslesen der Daten vom Ref DB der Meldung
	  #RetI := ReadFromArrayDB(db:=#NEW_MESS.DB, index:=0, value=>#ref);
	
	  //Prüfen Fehler aufgetreten, Wenn ja mit der nächsten Meldung weiter machen
	  IF #RetI = 0 AND #ref.INIT THEN
	    
	    //Prüfen Meldung bereits im PTR_DB vorhanden
	    #RetI := ReadFromArrayDB(db:=#ref.PTR_DB, index:=#NEW_MESS.NR, value=>#ptrDBNr);
	    
	    //Nummer konnte geholt werden und der RefDb ist Initailisiert
	    IF #RetI = 0 THEN
	      //Bei 0 läuft noch kein Auftrag dies Nummer zu holen. -> umkopieren in den
	      //internen Stack um damit den Leseauftrag zu Starten
	      #insert := #ptrDBNr = 0;
	      
	      //Ist eine negative Nummer eingetragen wird geprüft ob ein Eintrag in der Worklist vorhanden ist 
	      IF #ptrDBNr < 0 THEN
	        #ptrNr := #ptrDBNr * -1;
	        IF #ptrNr >= 1 AND #ptrNr <= #MESS_DBL.SIZE_MAX THEN 
	          #insert := #NEW_MESS.NR <> #MESS_DBL.LIST[#ptrNr].NR
	                  AND DB_ANY_TO_UINT(#NEW_MESS.DB) <> DB_ANY_TO_UINT(#MESS_DBL.LIST[#ptrNr].DB) ;
	        END_IF;       
	      END_IF;
	
	      //Wenn eine Positive Zahl in der Liste steht muss der Aktualiätsindex erhöht werden
	      IF #ptrDBNr >0 THEN
	          #RetW := "MESS_UPDATE_ACT_DB_FC"(INDEX:=#ptrDBNr - 1, TEXT_NR:=#NEW_MESS.NR, "REF":=#ref);
	       END_IF;
	      
	
	      //Meldung zu holen eintragen in die Interne Worklist
	      IF #insert THEN
	
	        //Zeiger für nächsten Eintrag ermitteln
	        #index := #MESS_DBL.PTR_IN + 1;
	        IF #index > #MESS_DBL.SIZE_MAX THEN
	          #index := 1;
	        END_IF;
	        
	       //prüfen noch Platz im Ringpuffer frei
	        IF #MESS_DBL.PTR_OUT <> #index THEN
	          #ptrDBNr := #MESS_DBL.PTR_IN * -1;
	          
	          //Meldung in Arbeitsvorat eintragen
	           #MESS_DBL.LIST[#MESS_DBL.PTR_IN] := #NEW_MESS;
	          
	          //Speichere den internen Zeiger zeiger DB ab
	          #RetI:= WriteToArrayDB(db:=#ref.PTR_DB, index:=#NEW_MESS.NR, value:= #ptrDBNr);
	        END_IF;
	
	        //Zeiger für nächsten Eintrag zuweisen
	        #MESS_DBL.PTR_IN:= #index;
	        
	        //Updaten der Größe vom Spool        
	        "MESS_SPOOL_UPDATE_SIZE_FC"(#MESS_DBL);
	        
	        //Statistik Zähler erhöhen
	        #MESS_DBL.COUNTER.ACTIVITY.INSERT_MESSAGE := #MESS_DBL.COUNTER.ACTIVITY.INSERT_MESSAGE + 1;
	        
	      END_IF;
	      
	   END_IF;
	
	  ELSE //Auswertung Ref DB auslesen
	    
	    //Fehler baim Auslesen aufgetreten
	    IF #RetI <> 0 THEN
	      #MESS_DBL.COUNTER.ERRORS.READ_REF_DB := #MESS_DBL.COUNTER.ERRORS.READ_REF_DB + 1;
	    END_IF;
	    
	    //refDB ist nicht Initalisiert
	    IF NOT #ref.INIT THEN
	      #MESS_DBL.COUNTER.ERRORS.REF_DB_NOT_INIT := #MESS_DBL.COUNTER.ERRORS.REF_DB_NOT_INIT + 1;
	    END_IF;
	
	  END_IF;
	ELSE
	  //Es wurde eine Meldung mir einem NULL Zeiger übergeben
	  #MESS_DBL.COUNTER.ERRORS.PTR_NULL := #MESS_DBL.COUNTER.ERRORS.PTR_NULL + 1;
	END_IF;
END_FUNCTION

TYPE "TYPE_FM_UDT"
VERSION : 0.1
   STRUCT
      FM : Array[0.."CO_TYPE_FM_MAX"] of Bool;   // Finish message
   END_STRUCT;

END_TYPE

TYPE "TYPE_CTRL_UDT"
VERSION : 0.1
   STRUCT
      DATA_EXIST : Bool;   // Dataset available
      DATA_EXIST_ONLINE : Bool;   // Dataset used online
      EDIT_ACTIVE : Bool;   // Dataset selected for editing
      EDIT_ENABLE : Bool;   // Dataset can be edited
      ERROR_DATA_NOT_EMPTY : Bool;   // Error dataset pointer not empty
      ERROR_BUFFER_NOT_EMPTY : Bool;   // Error clipboard (buffer) not empty
      ERROR_NOT_POSIBLE : Bool;   // Error dataset not plausible
      ERROR_MULTI_USED : Bool;   // Error dataset used several times
      DELETE : Bool;   // Move dataset into the recycle bin
      COPIED : Bool;   // Dataset copied
      CREATED : Bool;   // Dataset was generated in this cycle. Deleted again by TYPE_CHECK_CONSISTENCE_FB.
      SYSTEM_FILLING : Bool;   // Dataset considered at production line fill level
      FG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // FG number in which the dataset is edited
      SG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // SG number in which data set is edited
      TYPE_NR : USInt;   // Decoded type number
   END_STRUCT;

END_TYPE

FUNCTION "MODE_SET_IPST_PRIO_FC" : Void
TITLE = MODE_SET_IPST_CLASS_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW
FAMILY : MODE
//Convert IPS-T message class from char to a bit structure
   VAR_INPUT 
      IPST_CLASS : Char;   // IPST message classes
   END_VAR

   VAR_IN_OUT 
      IPST : "MESS_IPST_PRIORITY_UDT";   // Bit structure with the IPST message classes
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             MODE_SET_IPST_CLASS_FC     
	              Kommentar :         IPST Meldeklasse vom Char in ein Bit Struktur umwandeln
	                                  
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR
	              Datum :             15.05.2013        
	              Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                                  [x] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [ ] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	            Hardware- Bindung     [ ] 319F   [ ] 15xx           [x] auf 319F und 15xx lauffähig
	            Aufrufumgebung        [] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	            aufgerufene Bausteine    :   keine weiteren                                     
	
	****************************************************************************************************************************
	TODO:
	----------------------------------------------------------------------------------------------------------------------------
	
	@DESCRIPTION_DIAG@
	@DESCRIPTION_DIAG@
	
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version Autor         Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	07.01.2013  V0.0    Breu          Grundversion
	24.07.2013  V0.1    Breu          Dokumentation
	@CHANGELOG@
	*)
	
	
	IF #IPST_CLASS = 'A' THEN
	  #IPST.A := true;
	ELSIF #IPST_CLASS = 'B' THEN
	  #IPST.B := true;
	ELSIF #IPST_CLASS = 'E' THEN
	  #IPST.E := true;
	ELSIF #IPST_CLASS = 'I' THEN
	  #IPST.I := true;
	ELSIF #IPST_CLASS = 'M' THEN
	  #IPST.M := true;
	ELSIF #IPST_CLASS = 'O' THEN
	  #IPST.O := true;
	ELSIF #IPST_CLASS = 'P' THEN
	  #IPST.P := true;
	ELSIF #IPST_CLASS = 'Q' THEN
	  #IPST.Q := true;
	ELSIF #IPST_CLASS = 'S' THEN
	  #IPST.S := true;
	ELSIF #IPST_CLASS = 'T' THEN
	  #IPST.T := true;
	ELSIF #IPST_CLASS = 'W' THEN
	  #IPST.W := true;
	ELSIF #IPST_CLASS = 'Y' THEN
	  #IPST.Y := true;
	END_IF;
	
	
	
	
	
END_FUNCTION

TYPE "TYPE_DATA_CTRL_UDT"
VERSION : 0.1
   STRUCT
      DATA : Array[0.."CO_TYPE_DATA_MAX"] of "TYPE_CTRL_UDT";
   END_STRUCT;

END_TYPE

FUNCTION "MESS_GET_TEXT_FC" : Void
TITLE = MESS_GET_TEXT_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : SCHNELL
FAMILY : MESS
VERSION : 0.15
//Retrieving texts from text lists
   VAR_INPUT 
      REF_DB : DB_ANY;   // Name of message text - reference DBs
      TEXT_NR : UInt;   // Message text number
   END_VAR

   VAR_IN_OUT 
      GLOB : "GLOB_UDT";   // Global data
      SEQ : "MESS_GET_TEXT_SEQ_UDT";   // Interface sequence control
   END_VAR

   VAR_TEMP 
      "Ref" : "MESS_REF_UDT";
      Mess : "MESS_LIST_PTR_DETAIL_UDT";
      Text : "MESS_3_LANGUAGE_UDT";
      CO : Struct
         StartReadFromDBL : Int;
         NullPtr : Int;
      END_STRUCT;
      PtrText : Int;
      ret : Int;
      intError : Word;
      TextValid : Bool;
      PtrValid : Bool;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	Titel :             MESS_GET_TEXT_FC     
	Kommentar :         Holen von Texten aus Textlisten
	
	Copyright 20xx      BMW AG .....
	Ersteller :         G. Schnellbögl                   
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	Baustein holt aus den Textlisten im Arbeitsspeicher den zugehörigen Text zur TextNr 
	Verwendung für Visualisierung : Anzeige von Fehlermeldungen in der Detailmaske
	Sprache : falls mehrere Panels den Text angefordern, gewinnt das Panel mit der niedrigsten Nummer !!!  
	Falls kein Text zu der jeweiligen Fehelrnummer vorhanden ist, wird ein Leerstring zurückgeliefert
	
	****************************************************************************************************************************
	Rückgabewerte im SEQ.DIAG
	
	@DESCRIPTION_DIAG@
	yyxx  yy = Störklasse, xx = Meldenummer
	    
	0000  Kein Fehler
	A001  Fehler beim auslesen vom Referenz DB
	A004  Zeiger im Zeiger DB ist null. Der Text ist nicht vorhanden
	A011  Fehler beim Auslesen des Zeigers aus dem Zeiger db im Arbeitspeicher
	A012  Fehler beim Auslesen des Textes in den Arbeitspeicher DB 
	    
	Durch den MESS_UPDATE_ACT_DB_FC   
	A020  Fehler beim Auslesen des letzten Feld im Act DB
	A021  Fehler beim Schreiben des letzten Feld im Act DB
	A022  Fehler beim Schreiben des Index Feld im Act DB
	
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version Autor             Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	21.09.2012          Schnellbögl       Ersterstellung
	26.09.2012          Schnellbögl       Erweiterung um Sprachumschaltung (panelbezogen)
	10.10.2012          Breu              Bugfix, ENCO liefert beim Bit 0 "0" zurück, dies entspricht aber Panel 1
	30.10.2012          Breu              Umstellung auf 15xx
	20.11.2012          Schnellbögl       Anforderung von Texten, falls sie in Liste nicht vorhanden sind !
	12.04.2013          Breu              Redesign des Bausteins. Umstellung auf optimierte DBs. Schnittstelle angepasst für 
	                                      bessere Mehrfachverwendung
	26.04.2013          Breu              Siemens Befehle Rückgabewerte von Word nach INT geändert.
	18.11.2013  V1.4.x  Breu              Fehlerauswertung optimiert. Im Glob_DB sind nun Standardtexte hinterlegt für bestimmte
	                                      Fälle hinterlegt.
	05.12.2013  V1.5.x  Breu              Bugfix: Wenn beim auslesen des Zeiger DB ein Fehler auftritt wird auch der
	                                      Standardtext Text nicht Projektiert angezeigt. 
	16.03.2015  V1.34.x Breu              BUGFIX: Schnittstelle SEQ und GLOB waren unter OUTPUT nun verschoben nach INOUT 
	16.03.2020  V1.35.x Schnellbögl       Anpassungen an Fehlernummern bis 65000
	24.06.2022  V1.36.x Rahm              BMWCSN-1167: Optimierung Text wird nicht geholt (#PtrText <= 0)
	           
	@CHANGELOG@                   
	*)
	//**************************************************************************************************************************
	//Konstanten Iniitalisieren
	//**************************************************************************************************************************
	
	#CO.StartReadFromDBL  := -7000;
	#CO.NullPtr           := -7001;
	 
	//****************************************************************************************************************************
	//Auslesen des Referenz DBs
	//****************************************************************************************************************************
	#ret := ReadFromArrayDB(db:=#REF_DB, index:=0, value=>#Ref);
	
	//Fehlerauswertung nach auslesen des Ref DB
	IF #ret <> 0 THEN
	  #intError := w#16#a001;
	ELSIF NOT #Ref.INIT THEN
	  #intError := w#16#a002;
	END_IF;
	
	//****************************************************************************************************************************
	//Auslesen des Zeigers aus dem Zeiger DBs
	//****************************************************************************************************************************
	IF #intError = 0 THEN
	  #ret := ReadFromArrayDB(db:=#Ref.PTR_DB, index:=#TEXT_NR, value=>#PtrText);
	
	  //Fehlerauswertung Lesebefehl
	  IF #ret <> 0 THEN
	    #intError := w#16#a011;
	
	    //Text es ist noch kein Text im Arbeitspeicher
	    #Text := #GLOB.MESS.DIAG.NO_TEXT_CONFIG.TEXT;
	
	  ELSE
	    //Lesebefehl war erfolgreich --> Zeiger auswerten
	    IF #PtrText <= 0 THEN
	      //Ist der Zeiger 0 so ist der Text im Arbeitspeicher noch nicht vorhanden. Er wird in die Liste zum abholen der Texte 
	      //eingetragen
	      #Mess.DB := #REF_DB;
	      #Mess.NR := #TEXT_NR;
	
	      //Datensatz in die Liste zum holen vom Ladespeicher eintragen
	      "MESS_SPOOL_ADD_GET_DBL_FC"(NEW_MESS:=#Mess,
	                                  MESS_DBL:=#GLOB.MESS.SPOOL_DBL);
	
	      //Text ist noch nicht Arbeitspeicher- Text wird geladen
	      #Text := #GLOB.MESS.DIAG.NO_MESSAGE_TEXT.TEXT;
	
	    ELSIF #PtrText = #CO.NullPtr THEN
	      //Gibt es für diese Meldung keinen Text im Arbeitspeicher so wird eine Nullpointer Meldung eingetragen    
	      #intError := w#16#a004;
	      
	      //Text es ist noch kein Text im Arbeitspeicher
	      #Text := #GLOB.MESS.DIAG.NO_TEXT_CONFIG.TEXT;
	      
	    ELSIF #PtrText > 0 THEN
	      //ist der Zeiger im Arbeitspeicher größer als null ist der Text
	      //im Arbeitspeicher vorhanden
	      #PtrValid := true;
	      
	    END_IF;
	  END_IF;
	ELSE
	  //Der Referenz DB konnte nicht gelesen werden
	  #Text := #GLOB.MESS.DIAG.ERROR_REF_DB.TEXT;
	END_IF;
	
	//****************************************************************************************************************************
	//Auslesen des Textes aus dem Text DBs
	//****************************************************************************************************************************
	IF #PtrValid THEN
	  #ret := ReadFromArrayDB(db:=#Ref.TEXT_DB, index:=#PtrText - 1, value=>#Text);
	  IF #ret <> 0 THEN
	    #intError := w#16#a012;
	  ELSE
	    #TextValid := true;
	  END_IF;
	END_IF;
	
	//****************************************************************************************************************************
	//Zugriffzähler erhöhen
	//****************************************************************************************************************************
	IF #TextValid THEN
	
	  //Da der Baustein die Texte zur Zeit Zyklisch abholt würde der Text immer wieder geholt werden
	  #intError := "MESS_UPDATE_ACT_DB_FC"(INDEX:=#PtrText - 1, TEXT_NR:=#TEXT_NR, "REF":=#Ref);
	  
	END_IF; //Abfrage gültiger Text vorhanden
	
	//****************************************************************************************************************************
	//Statusausgabe
	//****************************************************************************************************************************
	#SEQ.ERROR  := #intError <> 0;
	#SEQ.BUSY   := #intError = 0 AND #PtrText <= 0;
	#SEQ.UNKNOW := #intError = w#16#a004;
	#SEQ.VALID  := #intError = 0 AND #TextValid;
	#SEQ.DIAG   := #intError;
	#SEQ.TEXT   := #Text;
	
END_FUNCTION

TYPE "TYPE_DELETE_SEQ_UDT"
VERSION : 0.1
   STRUCT
      DELETE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Delete type
   END_STRUCT;

END_TYPE

TYPE "TYPE_GLOB_UDT"
VERSION : 0.1
   STRUCT
      BACKUP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         SAVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Back up type management
         SAVE_REF { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Read and save reference structure
         RESTORE_REF { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Restore reference structure
         SET_ENABLE_SAVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release set backup
         ENABLE_SAVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Release backup
         SAVE_REF_INDEX { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Runtime variable for ref structure
         REF_STRUCT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1.."CO_TYPE_REFERENZ_MAX"] of Struct   // Derived ref structure
            REFERENZ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         END_STRUCT;
      END_STRUCT;
      "REF" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         INIT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // DB numbers initialized
         LINE_DB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DB_ANY;   // DB number TYPE_DATA_LINE_DB
      END_STRUCT;
      FM : Struct
         USED : "TYPE_FM_UDT";   // Finish message used
         "NAME" : Array[0.."CO_TYPE_FM_MAX"] of String[35];   // Production message names
      END_STRUCT;
      FILLING_SYSTEM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         PLACES { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0.."CO_MODE_SG_MAX"] of Struct
            EXIST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // System fill level required
            COUNT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Number data places
         END_STRUCT;
      END_STRUCT;
      SYS : Struct
         "CONST" : Struct
            MAX_INDEX : Int;   // Index of the last valid type in type declaration
            DELETE_PLACE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Data place index with delete sample
         END_STRUCT;
      END_STRUCT;
      UNIT_NO_USED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "TYPE_REF_UDT";   // Unused dataset reference
      IPSL_GET_DATA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "TYPE_IPSL_GET_DATA_SEQ_UDT";
   END_STRUCT;

END_TYPE

TYPE "DEV_GROUP_UDT"
VERSION : 0.1
   STRUCT
      GROUP_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Selection activate group
      DEV_SELECTED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Actuator selected
      BUTTON_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Advance button
      BUTTON_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Retract button
      REVERSE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Preselection actuator reverse
   END_STRUCT;

END_TYPE

TYPE "MESS_DETAIL_WINDOW_UDT"
VERSION : 0.1
   STRUCT
      CLASS : Int;   // Error class
      NR : UInt;   // Error number
      IPST_PRIO : Char;   // IPS-T priority
      TEXT : WString[80];   // Error text
   END_STRUCT;

END_TYPE

FUNCTION "MODE_SET_ERROR_LEVEL_REV2_FC" : Void
TITLE = MODE_SET_ERROR_LEVEL_REV2_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW_TUE
FAMILY : MODE
VERSION : 0.1
//Based on the level in which this block is called, it outputs an error message based on the content of the MESS_HANDLE_SINGLE_UDT structure.
//This is then only set in the corresponding level.
   VAR_INPUT 
      MESS_HANDLER : "MESS_HANDLE_SINGLE_UDT";   // Active message :   Data structure
   END_VAR

   VAR_IN_OUT 
      GLOB : "GLOB_UDT";   // Global data
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             MODE_SET_ERROR_LEVEL_FC_REV2     
	              Kommentar :         Anhand der Ebene, in der dieser Baustein aufgerufen wird setzt dieser ein Fehlermeldung 
	                                  basierend auf den Inhalten der MESS_HANDLE_SINGLE_UDT Struktur ab. 
	                                  Diese wird dann nur in der entsprechenden Ebene gesetzt.
	              
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR
	              Datum :             23.06.2014       
	              Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                                  [x] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [ ] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	            Hardware- Bindung     [ ] 319F   [ ] 15xx           [x] auf 319F und 15xx lauffähig
	            Aufrufumgebung        [] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	            aufgerufene Bausteine    :   keine weiteren                                     
	
	****************************************************************************************************************************
	TODO:
	----------------------------------------------------------------------------------------------------------------------------
	
	@DESCRIPTION_DIAG@
	@DESCRIPTION_DIAG@
	
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version Autor         Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	
	23.06.2014  V1.33.x   Schnellbögl   Umstellung auf MESS_HANDLE_SINGLE_UDT
	07.08.2014  V1.34.x   Schnellbögl   Bugfix
	10.09.2014  V1.35.x   Schnellbögl   keine Errorgenerierung, wenn #"MESS_HANDLER".DATA.COMMISSIONING_MODE aktiv ist
	30.09.2016  V1.36.x   Schnellbögl   Integration MESSAGE_PERI_NOT_READY : vorerst wird zusätzlich MESSAGE gesetzt !
	29.08.2017  V1.37.x   Schnellbögl   Erweiterung um ERROR_SEQUENCE_FLOW
	@CHANGELOG@
	*)
	
	//Abfrage Störung aktiv
	IF (#MESS_HANDLER.LIST_PTR[0].NR <> 0) AND NOT #MESS_HANDLER.COMMISSIONING_MODE THEN
	  
	  //Auswahl der Ebene auf der der Baustein aufgerufen ist
	  CASE "MODE_GET_LEVEL_INFO_FC"(GLOB := #GLOB) OF
	      //----------------------------------------------------------------------------------------------------------------------------
	      //PLC Ebene
	      //----------------------------------------------------------------------------------------------------------------------------
	    1:
	      IF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_SAFETY THEN
	        #GLOB.MODE.PLC.IN.ERROR_SAFETY := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_DROP_START THEN
	        #GLOB.MODE.PLC.IN.ERROR_DROP_START := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START THEN
	        #GLOB.MODE.PLC.IN.ERROR := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_SEOC THEN
	        #GLOB.MODE.PLC.IN.ERROR_SEOC := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.CONTROLLED_STOP THEN
	        #GLOB.MODE.PLC.IN.REQ_CONTROLLED_STOP := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.WARNING THEN
	        #GLOB.MODE.PLC.IN.WARNING := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.MESSAGE THEN
	          #GLOB.MODE.PLC.IN.MESSAGE := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_SEQUENCE_FLOW THEN
	          #GLOB.MODE.PLC.IN.ERROR_SEQUENCE_FLOW := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.MESSAGE_PERI_NOT_READY THEN
	        // vorerst wird zusätzlich noch Message gesetzt, damit Filterung im Störstack möglich ist !
	        #GLOB.MODE.PLC.IN.MESSAGE_PERI_NOT_READY := TRUE;
	        #GLOB.MODE.PLC.IN.MESSAGE := TRUE;
	      ELSE
	        //Fehlermeldungen mit einer unbekannten Klasse werden als 
	        //Fehler in die Struktur eingetragen
	        #GLOB.MODE.PLC.IN.ERROR := TRUE;
	      END_IF;
	      
	       //Setzen der IPST Meldeklasse in der Struktur
	      "MODE_SET_IPST_PRIO_FC"(IPST_CLASS := #MESS_HANDLER.IPST_PRIO,
	                               IPST := #GLOB.MODE.PLC.IN.IPST);
	      
	      // Setzen der Farbe für den Overflow Picture Button 
	       "MODE_ANIMATE_OV_PIC_REV2_FC"(MESS_HANDLER := #MESS_HANDLER,
	                                     GLOB := #GLOB,
	                                     OVERFLOW_PIC_RED := #GLOB.MODE.PLC.IN.OVERFLOW_PIC_RED,
	                                     OVERFLOW_PIC_YELLOW := #GLOB.MODE.PLC.IN.OVERFLOW_PIC_YELLOW);
	      
	      //----------------------------------------------------------------------------------------------------------------------------
	      //SG Ebene
	      //----------------------------------------------------------------------------------------------------------------------------
	    2:
	      IF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_SAFETY THEN
	        #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.ERROR_SAFETY := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_DROP_START THEN
	        #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.ERROR_DROP_START := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START THEN
	        #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.ERROR := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_SEOC THEN
	        #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.ERROR_SEOC := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.CONTROLLED_STOP THEN
	        #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.REQ_CONTROLLED_STOP := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.WARNING THEN
	        #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.WARNING := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.MESSAGE THEN
	          #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.MESSAGE := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_SEQUENCE_FLOW THEN
	          #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.ERROR_SEQUENCE_FLOW := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.MESSAGE_PERI_NOT_READY THEN
	        // vorerst wird zusätzlich noch Message gesetzt, damit Filterung im Störstack möglich ist !
	        #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.MESSAGE_PERI_NOT_READY := TRUE;
	        #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.MESSAGE := TRUE;
	      ELSE
	        //Fehlermeldungen mit einer unbekannten Klasse werden als 
	        //Fehler in die Struktur eingetragen
	        #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.ERROR := TRUE;
	      END_IF;
	      
	      //Setzen der IPST Meldeklasse in der Struktur
	      "MODE_SET_IPST_PRIO_FC"(IPST_CLASS := #MESS_HANDLER.IPST_PRIO,
	                              IPST := #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.IPST);
	      
	      // Setzen der Farbe für den Overflow Picture Button 
	      "MODE_ANIMATE_OV_PIC_REV2_FC"(MESS_HANDLER := #MESS_HANDLER,
	                                    GLOB := #GLOB,
	                                    OVERFLOW_PIC_RED := #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.OVERFLOW_PIC_RED,
	                                    OVERFLOW_PIC_YELLOW := #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].IN.OVERFLOW_PIC_YELLOW);
	      
	      //----------------------------------------------------------------------------------------------------------------------------
	      //FG Ebene
	      //----------------------------------------------------------------------------------------------------------------------------
	    3:
	      IF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_SAFETY THEN
	        #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.ERROR_SAFETY := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_DROP_START THEN
	        #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.ERROR_DROP_START := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START THEN
	        #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.ERROR := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_SEOC THEN
	        #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.ERROR_SEOC := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.CONTROLLED_STOP THEN
	        #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.REQ_CONTROLLED_STOP := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.WARNING THEN
	        #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.WARNING := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.MESSAGE THEN
	          #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.MESSAGE := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.ERROR_SEQUENCE_FLOW THEN
	          #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.ERROR_SEQUENCE_FLOW := TRUE;
	      ELSIF #MESS_HANDLER.ERROR_CLASS = #GLOB.SYS.CONST.MESS.MESSAGE_PERI_NOT_READY THEN
	        // vorerst wird zusätzlich noch Message gesetzt, damit Filterung im Störstack möglich ist !
	        #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.MESSAGE_PERI_NOT_READY := TRUE;
	        #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.MESSAGE := TRUE;
	      ELSE
	        //Fehlermeldungen mit einer unbekannten Klasse werden als 
	        //Fehler in die Struktur eingetragen
	        #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.ERROR := TRUE;
	      END_IF;
	      
	      //Setzen der IPST Meldeklasse in der Struktur
	      "MODE_SET_IPST_PRIO_FC"(IPST_CLASS := #MESS_HANDLER.IPST_PRIO,
	                              IPST := #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.IPST);
	      
	      // Setzen der Farbe für den Overflow Picture Button 
	      "MODE_ANIMATE_OV_PIC_REV2_FC"(MESS_HANDLER := #MESS_HANDLER,
	                                    GLOB := #GLOB,
	                                    OVERFLOW_PIC_RED := #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.OVERFLOW_PIC_RED,
	                                    OVERFLOW_PIC_YELLOW := #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].IN.OVERFLOW_PIC_YELLOW);
	  END_CASE;
	END_IF;
	
	
END_FUNCTION

FUNCTION "TOOL_DINT_TO_STRING_FC" : Word
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      IN : DInt;   // Number to be converted to a string
      MODE : USInt;   // 0: Positive no sign, negative with sign; 1: always with sign; 2 always without sign
      MIN_LEN : USInt;   // Minimum length: 0 => String is only returned with the required length; <> 0 padding characters are added to achieve the string length
      FILL_CHAR : Char;   // Character with which to pad the string
   END_VAR

   VAR_OUTPUT 
      OUT : String;
   END_VAR

   VAR_TEMP 
      loop : Int;
      LoopEnd : Int;
      divisor : DInt;
      StartValue : DInt;
      RestValue : DInt;
      Value : DInt;
      Chr : Char;
      StartChrFound : Bool;
      MinLenActive : Bool;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             TOOL_DINT_TO_STRING_FC     
	              Kommentar :         Wandelt einen Zahl in einen String um. Dabei kann angegeben werden ob führende Zeichen
	                                  oder ein Vorzeichen integriert werden soll.
	
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR
	              Datum :             18.04.2013
	              Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                                  [x] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [ ] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	            Hardware- Bindung     [ ] 319F   [ ] 15xx           [x] auf 319F und 15xx lauffähig
	            Aufrufumgebung        [] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	            aufgerufene Bausteine    :   keine weiteren                                     
	
	****************************************************************************************************************************
	MODE =  0:  Bei negativen Zahlen wird ein '-' als Vorzeichen mit eingefügt
	MODE =  1:  Es wird immer ein Vorzeichen mit eingefügt werden.
	MODE =  2:  Es wird kein Vorzeichen eingefügt
	
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	Binärwert           Hexwert Beschreibung
	yyyyyyyy_xxxxxxxx   yyxx    "yy = Störklasse xx = Meldenummer"
	
	10100000_00000001   A001    Unbekannter Modus ausgewählt
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Autor         Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	18.04.2013  Breu          Grundversion
	07.04.2016  V1.34.x  Schnellbögl   Bugfix : Wenn man eine MIN_Len größer als 9 vorgegeben hat, wurden die Füllzeichen falsch befüllt
	@CHANGELOG@
	
	*)
	
	#OUT := '';
	
	CASE #MODE OF
	  0: //Nur negative Zahlen mit Vorzeichen
	    IF #IN < 0 THEN
	      #OUT := '-';
	     END_IF;
	  1: //Immer mit Vorzeichen
	  IF #IN < 0 THEN
	    #OUT := '-';
	  ELSE
	    #OUT := '+';
	  END_IF;
	  2: //ohne Vorzeichen
	    #OUT := '';
	  ELSE
	    //Modus unbekannt
	    #TOOL_DINT_TO_STRING_FC := w#16#A001;
	    RETURN;
	END_CASE;
	
	IF #IN < 0 THEN
	  #StartValue := #IN * -1;
	ELSE
	  #StartValue := #IN;
	END_IF;
	
	IF #MIN_LEN > 9 THEN
	    #LoopEnd := #MIN_LEN - 10;
	    FOR #loop := 1 TO #LoopEnd DO
	        #OUT := CONCAT(IN1 := #OUT, IN2 := #FILL_CHAR);
	    END_FOR;
	END_IF;
	
	
	FOR #loop := 9 TO 0 BY -1 DO
	  #divisor := ROUND(1* 10 ** #loop);
	  #Value := #StartValue / #divisor;
	  #RestValue := #StartValue MOD #divisor;
	  
	  //Solange noch kein Zeichen gefunden wurde und eine mi
	  #MinLenActive := (#MIN_LEN > 0 AND #loop < #MIN_LEN) AND NOT #StartChrFound AND #Value = 0;
	
	  IF  #MinLenActive THEN
	    #OUT := CONCAT(IN1:= #OUT, IN2:= #FILL_CHAR);
	  ELSIF #Value > 0 OR #StartChrFound OR (#Value = 0 AND #loop = 0) THEN
	    //Den Zahlenwert in ein Asciizeichen umwandeln
	    #Chr := BYTE_TO_CHAR(DINT_TO_BYTE(#Value) OR CHAR_TO_BYTE('0')) ;
	    
	    //Zum String hinzufügen
	    #OUT := CONCAT(IN1:= #OUT, IN2:= #Chr);  
	    
	    //Es wurde ein Zeichen gefunden, ab Sofort alle Zeichen eintragen
	    #StartChrFound := true;
	    #StartValue := #RestValue;
	  END_IF;
	  
	END_FOR;
	
	//Rückgabewert aufbereiten
	#TOOL_DINT_TO_STRING_FC := 0; 
	
	
	
	
END_FUNCTION

TYPE "MESS_HANDLE_SINGLE_IFACE_UDT"
VERSION : 0.1
   STRUCT
      DIAG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // FC>FB diagnostic information
      BUFFER_MESSAGE_COMING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FC(set) >FB(reset): INCOMING message  ->  must be saved in static area
      SEND_STORED_MESSAGE_COMING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FC(set) >FB(reset): INCOMING message from static area must be entered in active register
      BUFFER_MESSAGE_GOING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FC(set) >FB(reset): OUTGOING message   ->  must be saved in static area
      SEND_MESSAGE_GOING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FC(set) >FB(reset): OUTGOING message: Report active message as outgoing
      MESSAGE_COMING_BUFFERED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FB (set + reset): INCOMING message saved in static area
      MESSAGE_GOING_BUFFERED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FB (set + reset): OUTGOING message saved in static area
      FB_READY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FB (set + reset): FB ready for new messages
      ERROR_DOUBLE_USE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // FB (set + reset): Error: Instance called several times
      RECENT_MESSAGE_NR_SENT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // FB (set + reset): Current sent text number (deleted with outgoing event)
      RECENT_ERROR_CLASS_SENT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // FB (set + reset): Current sent error class (deleted with outgoing event)
      RECENT_MESSAGE_PTR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // FB (set + reset): Pointer for currently active sent text number
      TRIGGER_READ_HEADER { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger: Read header into HEADER structure
      TRIGGER_READ_OPERAND { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Trigger: Read operand into DATA structure
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "MESS_GET_LIST_FB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      "FAMILY" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];   // Family name of list
   END_VAR

   VAR_OUTPUT 
      REF_DB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DB_ANY;   // Reference DB from list
      DIAG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Diagnostics word
   END_VAR

   VAR_IN_OUT 
      GLOB { S7_PredefinedAssignment := '"GLOB_DB"'; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : "GLOB_UDT";   // Global data
   END_VAR

   VAR 
      IndexNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;
   END_VAR

   VAR_TEMP 
      loop : Int;
      LoopEnd : Int;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             MESS_GET_LIST_FB   
	              Kommentar :         Gibt anhand eines Familiennamen den RefernzDBs aus der Globalen Liste zurück
	
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR
	              Datum :             27.03.2013        
	              Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                                  [x] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [ ] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	            Hardware- Bindung     [ ] 319F   [ ] 15xx           [x] auf 319F und 15xx lauffähig
	            Aufrufumgebung        [] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	            aufgerufene Bausteine    :   keine weiteren                                     
	
	****************************************************************************************************************************
	
	@DESCRIPTION_DIAG@
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version Autor         Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	27.03.2013  V0.0    Breu          Grundversion
	04.10.2013  V0.1    Breu          Erfassung anzahl der Bausteine die auf eine Liste zugreifen
	29.01.2013  V1.4.x  Breu          Erfassung der Anzahl für HMI in andere zweite Variable verschoben
	@CHANGELOG@
	*)
	
	//Diagnosewort ablöschen
	#DIAG := 0;
	
	//Prüfen Suchen erforderlich
	IF NOT #GLOB.MESS.REF_PTR.INIT OR #IndexNr = 0 THEN
	
	  #LoopEnd := #GLOB.MESS.REF_PTR.SIZE;
	  FOR #loop := 1 TO #LoopEnd DO
	    
	    //Prüfen ob der Familienname gleich ist
	    IF #FAMILY = #GLOB.MESS.REF_PTR.PTR[#loop].FAMILY THEN
	      //Wenn der Name gefunden wurde, werden die Daten
	      #REF_DB := #GLOB.MESS.REF_PTR.PTR[#loop].REF_DB;
	      #IndexNr := INT_TO_USINT(#loop);
	      EXIT;
	    END_IF;
	
	  END_FOR;
	END_IF;
	
	//Wurde in der Liste für diese Famile keine Eintarg gefunden, so wird ein Fehler 
	//ausgegeben
	IF #IndexNr = 0 THEN
	  #REF_DB := 0;
	  #DIAG := w#16#a001;
	ELSE
	  //Für die Statistik erfassen wieviele Bausteine auf eine Liste zugreifen
	  #GLOB.MESS.REF_PTR.PTR[#IndexNr].COUNTER := #GLOB.MESS.REF_PTR.PTR[#IndexNr].COUNTER + 1;
	END_IF;
	
	  
	
	    
	
	
	
	
	
	
	
END_FUNCTION_BLOCK

TYPE "MESS_HANDLE_SINGLE_CONF_UDT"
VERSION : 0.1
   STRUCT
      LABEL_ID { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // No. for text from text list (default: LABEL_MESS)
      LABEL_DB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DB_ANY;   // DB number of text list (0=default: LABEL_MESS)
      FLICKER_MAX_COUNT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt := 3;   // Maximum number of times a message may change its state in the time period (rapid state change detection)
      FLICKER_TIME_SPAN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := t#10s;   // Time span in which the number of signal changes is logged (to detect rapid state changes)
      ASSOCIATED_NR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // Associated value for number
      ASSOCIATED_TEXT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[16];   // Associated value for text
   END_STRUCT;

END_TYPE

TYPE "CVFL_FLXXX_SEQ_UDT"
VERSION : 0.1
   STRUCT
      STATUS_READY_IN_RET : Bool;   // Status ready to feed in RET side (out status)
      STATUS_READY_IN_ADV : Bool;   // Status ready to feed in ADV side (out status)
      STATUS_OUT_RET : Bool;   // Status outfeed RET side (path flag) (out status)
      STATUS_OUT_ADV : Bool;   // Status outfeed ADV side (path flag) (out status)
      STATUS_DRIVE_THROUGH_RET : Bool;   // Status pass through RET side (out status)
      STATUS_DRIVE_THROUGH_ADV : Bool;   // Status pass through ADV side (out status)
      STATUS_SELECT_TRANSP_RET : Bool;   // Status selection cross-convey RET side (out status)
      STATUS_SELECT_TRANSP_ADV : Bool;   // Status selection cross-convey ADV side (out status)
      STATUS_SELECT_TRANSP_FAST : Bool;   // Status selection cross-convey fast (out status)
      STATUS_BUTTON_RET : Bool;   // Status status button RET (out status)
      STATUS_BUTTON_ADV : Bool;   // Status status button ADV (out status)
      STATUS_SERVICE_MODE_ACTIVE : Bool;   // Status selection safety overridden (out status)
      STATUS_EMPTY : Bool;   // Status empty/release (out status)
      STATUS_OCCUPIED : Bool;   // Status busy (out status)
      STATUS_DRIVE_RUNNING : Bool;   // Status motor running (out status)
      STATUS_DRIVE_RUNNING_FAST : Bool;   // Status motor running fast (out status)
      STATUS_AUTOMATIC : Bool;   // Status automatic (out status)
      STATUS_MANUAL : Bool;   // Status manual (out status)
      STATUS_DRIVE_ERROR : Bool;   // Status error motor (motor not running) (out status)
      STATUS_RESET_EDGE_POS : Bool;   // Status status reset edge positive (out status)
      STATUS_TYPE_SHIFT_EDGE_OUT_RET : Bool;   // Status type push from separate type to RET side (out status)
      STATUS_TYPE_SHIFT_EDGE_OUT_ADV : Bool;   // Status type push from separate type to ADV side (out status)
      STATUS_EXTERN_OCCUPIED_SET : Bool;   // Set status occupied externally, (e.g., for corner transfer units or elevators) (in status)
      STATUS_EXTERN_OCCUPIED_RESET : Bool;   // Reset status occupied externally, (e.g., for corner transfer units or elevators) (in status)
      STATUS_COLLISION_PROTECTION_DRIVE_SLOW : Bool;   // Status collision protection motor slow (in status)
      STATUS_COLLISION_PROTECTION_DRIVE_STOP : Bool;   // Status collision protection motor stop (in status)
      STATUS_ENABLE_SHUTTLE_FUNCTION_IN_RET : Bool;   // Status Activation Shuttle function retract to position RET (out status)
      STATUS_ENABLE_SHUTTLE_FUNCTION_IN_ADV : Bool;   // Status Activation Shuttle function retract to position ADV (out status)
      STATUS_NEW_COMPONENT_RETRACTED_RET : Bool;   // Status new part retracted RET (out status)
      STATUS_NEW_COMPONENT_RETRACTED_ADV : Bool;   // Status new part retracted ADV (out status)
      STATUS_PART_CHANGE : Bool;   // Status hide parts present monitoring (out status)
      STATUS_IN_POSITION : Bool;   // Status in position (out status)
      STATUS_VERSION : Byte := 0;   // Status version
      STATUS_NAME : String[30];   // Status name (INSTANCE NAME) (out status)
      STATUS_TYPE_NEW : Int;   // Status type new (in/out status)
      STATUS_TYPE_ASC_NEW : String[10];   // Status type new ASC (in/out status)
      STATUS_TYPE : Int;   // Status type (in/out status)
      STATUS_TYPE_ASC : String[10];   // Status type ASC (in/out status)
      STATUS_TYPE_TYPE_NR_NEW : USInt;   // Status type number from dataset (out status)
      STATUS_TYPE_UNIT_NEW : "TYPE_REF_UDT";   // Status type dataset reference new (in/out status)
      STATUS_TYPE_TYPE_NR : USInt;   // Status type number from dataset (out status)
      STATUS_TYPE_UNIT : "TYPE_REF_UDT";   // Status type dataset reference (in/out status)
   END_STRUCT;

END_TYPE

TYPE "HMI_REGISTER_HEADER_UDT"
VERSION : 0.1
   STRUCT
      IN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct   // Write sheet blocks
         EXIST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..16] of Bool;
         ACTIVE_REGISTER { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;   // No. of register to be activated
         FAULT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         WARNING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         COMMISSIONING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning
         PARAMETER_FAULT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parameterization error
         "COUNTER" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;
         BUTTON_PREVIOUS_FAULT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error
         BUTTON_PREVIOUS_WARNING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Warning
         BUTTON_PREVIOUS_COMMISSIONING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning
         BUTTON_PREVIOUS_PARAMETER_FAULT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parameterization error
         BUTTON_NEXT_FAULT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Error
         BUTTON_NEXT_WARNING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Warning
         BUTTON_NEXT_COMMISSIONING { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning
         BUTTON_NEXT_PARAMETER_FAULT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Parameterization error
      END_STRUCT;
      OUT : Struct   // HMI data (are the same for one cycle)
         EXIST : Array[0..16] of Bool;
         ACTIVE_REGISTER : Int;   // No. of register to be activated
         FAULT : Bool;
         WARNING : Bool;
         COMMISSIONING : Bool;   // Commissioning
         PARAMETER_FAULT : Bool;   // Parameterization error
         BUTTON_PREVIOUS_FAULT : Bool;   // Error
         BUTTON_PREVIOUS_WARNING : Bool;   // Warning
         BUTTON_PREVIOUS_COMMISSIONING : Bool;   // Commissioning
         BUTTON_PREVIOUS_PARAMETER_FAULT : Bool;   // Parameterization error
         BUTTON_NEXT_FAULT : Bool;   // Error
         BUTTON_NEXT_WARNING : Bool;   // Warning
         BUTTON_NEXT_COMMISSIONING : Bool;   // Commissioning
         BUTTON_NEXT_PARAMETER_FAULT : Bool;   // Parameterization error
      END_STRUCT;
      SHEETS : Array[0..16] of String[10];   // Texts for instance names
   END_STRUCT;

END_TYPE

TYPE "MODE_FG_WORK_DATA_UDT"
VERSION : 0.1
   STRUCT
      FG_NR : Int;   // FG number
      SG_NR : Int;   // SG number
      DIAG : Word;   // Diagnostics word when reading the FG data
      OUT : "MODE_FG_DETAIL_OUT_UDT";   // Signals from FG
      IN : "MODE_FG_DETAIL_IN_UDT";   // Signals to FG
   END_STRUCT;

END_TYPE

TYPE "HMI_REGISTER_SHEET_UDT"
VERSION : 0.1
   STRUCT
      INSTANCE_NAME : String[40];   // Becomes the variable prefix
      CAPTION_NAME : String[17];   // Name of tab
      SCREEN_NAME : String[50];   // Image name called in the register
      ICON_NUMBER : UInt;   // No. of icon in graphics list
      FAULT : Bool;   // Red color
      WARNING : Bool;   // Yellow color
      EXIST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      COMMISSIONING : Bool;   // Commissioning
      PARAMETER_FAULT : Bool;   // Parameterization error
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "DEV_SELECT_FB"
TITLE = DEV_SELECT_FB
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW
FAMILY : DEV
//The block manages the release for controlling actuators in manual operating mode. It ensures that only one actuator can be selected per panel. Furthermore, it provides the interface for group selection. Group selection requires a variable of the DEV_GROUP_UDT type. It is named "GROUP" in the default blocks. DEV_GROUP_FB is used for connecting several actuators as a group. Furthermore, there is the possibility to select multiple actuators. The buttons coming from the HMI are reset in the block if this is possible. The buttons are thus defined as IN/OUT parameters.
//Actuators can only be selected if the FG concerned is in manual operating mode. Manual release must also be in place. If an actuator is enabled, another actuator that is currently enabled is then disabled. An exception here is if multi-selection is enabled. If this is the case, as many actuators as required can be selected at the same time. All of the panel's actuators are deselected on changing the screen in the HMI.
//The MAN_ADV and MAN_RET signals in the output interface are intended for manually controlling the actuator.
//They switch to "1" in the following conditions:
//- FG in manual operating mode
//- FG manual release
//- actuator or group selected
//- advance or retract button actuated via the HMI, or advance or retract buttons pressed on the operating panel (e.g., BVO)
//In case of multi-selection and groups, there is the possibility to actuate individual actuators inversely. This means, e.g., that when the group is actuated in advance direction, the actuator - which is in REVERSE mode - is actuated in reverse direction.
   VAR_INPUT 
      RELEASE_SELECT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;
   END_VAR

   VAR_OUTPUT 
      SELECTED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Actuator selected
      MAN_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual advance
      MAN_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Manual retract
   END_VAR

   VAR_IN_OUT 
      FG : "MODE_FG_WORK_DATA_UDT";   // FG structure for FG in which the actuator is projected
      GROUP : "DEV_GROUP_UDT";   // Structure for group selection
      GLOB { S7_PredefinedAssignment := '"GLOB_DB"'; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : "GLOB_UDT";   // Global data
      HMI_BUTTON_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Advance button
      HMI_BUTTON_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Retract button
      HMI_SELECT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activate actuator button
      HMI_REVERSE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // On multiple selection, opposite actuation
   END_VAR

   VAR 
      devSelect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      fp_devSelect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      devSelfSelected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      devSelected { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      imp_devSelect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      releaseDevSelect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      fp_ScreenChange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      fp_Multiselection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      fp_AreaChange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      fp_GroupActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      panelDev : "PANEL_DEVICE_UDT";
      panelHmi : "PANEL_HMI_INTFACE_TO_PANEL_UDT";
      panelNr : Int;
      panelActiv : Bool;
      releaseMan : Bool;
      releaseManFG : Bool;
      manAdv : Bool;
      manRet : Bool;
      MultiSelection : Bool;
      hm_devSelect : Bool;
      groupAdv : Bool;
      groupRet : Bool;
      imp_ScreenChange : Bool;
      imn_Multiselection : Bool;
      imp_Multiselection : Bool;
      imp_AreaChange : Bool;
      imn_GroupActive : Bool;
      imp_GroupActive : Bool;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             DEV_SELECT_FB 
	              Kommentar :         Der Baustein verwaltet die Freigabe zur Ansteuerung von Stellgeräten in der Betriebsart Hand. 
	                                  Er regelt dass pro Panel nur ein Stellgerät angewählt sein kann. Außerdem stellt er die 
	                                  Schnittstelle zur Gruppenwahl bereit. Die Gruppenanwahl benötigt eine Variable vom Typ DEV_GROUP_UDT.  
	                                  Diese hat in den Standardbausteinen den Namen „GROUP“. Zur Verschaltung von mehreren Stellgeräten 
	                                  zu einer Gruppe wird der DEV_GROUP_FB verwendet. Des Weiteren gibt es noch die Möglichkeit 
	                                  ein Multiselection von Stellgeräten zu machen. Die Buttons die von der HMI kommen werden im 
	                                  Baustein zurückgesetzt wenn dies möglich ist. Deswegen sind diese als IN/OUT Parameter festgelegt. 
	                                  Stellgeräte Anwahl kann nur erfolgen wenn die betreffende FG in der Betriebsart Hand ist. 
	                                  Zusätzlich muss die Handfreigabe vorhanden sein. Wird ein Stellgerät aktiviert werden automatisch 
	                                  an anderes noch aktiviertes Stellgerät abgewählt. Eine Ausnahme ist hierbei wenn Multiselction 
	                                  aktiviert ist. Dann können so viele Stellgeräte  wie gewünscht gleichzeitig angewählt werden. 
	                                  Beim Bildwechsel in der HMI werden alle Stellgeräte des Panels abgewählt.
	                                  Die Signale MAN_ADV und MAN_RET in der Ausgangschnittstelle sind zur Ansteuerung des Stellgeräts 
	                                  in Hand vorgesehen. 
	                                  Diese werden „1“ unter folgender Bedingung:
	                                  - FG in Betriebsart Hand
	                                  - FG Handfreigabe
	                                  - Stellgerät oder Gruppe angewählt 
	                                  - Button vor bzw. rück von der HMI betätigt oder die Tasten vor bzw. rück am Bedienpanel gedrückt (z.B. BVO) 
	                                  Bei Multiselection und bei Gruppen gibt es die Möglichkeit einzelne Stellgeräte umgekehrt anzusteuern. 
	                                  Das bedeutet z.B. wenn die Gruppe vor angesteuert wird, dass Stellgerät das im REVERSE (umgekehrt) Modus ist, 
	                                  rück angesteuert wird.
	
	    
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR
	              Datum :             23.07.2013        
	              Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                                  [x] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [ ] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	            Hardware- Bindung     [ ] 319F   [ ] 15xx           [x] auf 319F und 15xx lauffähig
	            Aufrufumgebung        [] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	            aufgerufene Bausteine    :   keine weiteren                                     
	
	****************************************************************************************************************************
	
	@DESCRIPTION_DIAG@
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version   Autor        Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	30.05.2012            Breu          Grundversion
	20.06.2012            Breu          Automatisches Abwählen des Stellgerät bei FG wechsel
	20.07.2012            Breu          Integration Multiselection und Screenchange, Abfrage der maximalen Panelnummer über SYS_DB
	28.01.2013            Breu          Änderung Stellgerät kann auch von anderen FG selektiert werden, Neue Ausgänge zur Anzeige 
	                                    in der HMI
	04.03.2013            Breu          Zur Anzeige des Stellgräts in einer anderen FG wird die Freigabe zur Handbedienung nun 
	                                    als Doppelwort an die HMI übergeben. Damit kann diese auswerten und anzeigen ob ein
	                                    fremdes Panel oder das Eigen Bedienfreigabe für ein FG fremdes Stellgerät hat  
	05.03.2013            Breu          Optimierung der Zugriffe auf die vorhandenen DBs 
	26.03.2013  V0.0      Breu          Umstellung für Typen auf Global DB                                                                      
	23.07.2013  V0.1      Breu          Dokumentation
	10.11.2014  V1.34.x   Breu          Buttons ADV / RET und wurden nicht abgelöscht wenn die Handfreigabe fehlt. Diese
	                                    wurde nun zusätzulich mit verknüpft
	10.09.2018  V1.35.x   Rieger        Ergänzung Input-Parameter RELEASE_SELECT
	@CHANGELOG@
	*)
	
	//****************************************************************************************************************************
	//Panelnummer auslesen und Struktur holen
	//****************************************************************************************************************************
	
	//Gibt es in der aufrufstruktur des Stellgerät einen Fehler wird der Baustein verlassen
	//und die Ausgangsvariablen initalisert
	IF #FG.DIAG <> 0 THEN
	  #SELECTED := false;
	  #MAN_ADV := false;
	  #MAN_RET := false;
	  RETURN;
	END_IF;
	
	//Auslesen der Panelnummer und prüfen gültiges Panel aktiv
	#panelNr := #FG.OUT.OP_RELEASE_PANEL_NR;
	#panelActiv := #panelNr > 0 AND #panelNr <= #GLOB.SYS.CONST.PANEL_MAX;
	
	//Wenn Panel gültig werden die erforderlichen Variablen umkopiert
	IF #panelActiv THEN
	  #panelDev          := #GLOB.PANEL_ORG.DEV_PANEL[#panelNr];
	  #panelHmi       := #GLOB.PANEL_ORG.HMI_INTFACE_PANEL[#panelNr].TO_PANEL;
	  #MultiSelection := #GLOB.PANEL_ORG.HMI_INTFACE_PANEL[#panelNr].FROM_PANEL.MULTISELECTION;
	END_IF;
	
	
	//****************************************************************************************************************************
	//Flanke bliden Button Anwahl STG in HMI
	//****************************************************************************************************************************
	#hm_devSelect := #HMI_SELECT
	                OR (
	                  (#HMI_BUTTON_ADV OR #HMI_BUTTON_RET)
	                  AND NOT #devSelfSelected
	                );
	              
	#imp_devSelect := #hm_devSelect AND NOT #fp_devSelect;
	#fp_devSelect := #hm_devSelect;
	#HMI_SELECT := false;
	
	
	//****************************************************************************************************************************
	//Flanke Multiselection abgewählt
	//****************************************************************************************************************************
	#imp_Multiselection := #MultiSelection AND NOT #fp_Multiselection;
	#imn_Multiselection := NOT #MultiSelection AND #fp_Multiselection;
	#fp_Multiselection := #MultiSelection;
	
	
	//****************************************************************************************************************************
	//Flanke Grouppenanwahl erfolgt
	//****************************************************************************************************************************
	#imp_GroupActive := #GROUP.GROUP_ACTIVE AND NOT #fp_GroupActive;
	#imn_GroupActive := NOT #GROUP.GROUP_ACTIVE AND #fp_GroupActive;
	#fp_GroupActive := #GROUP.GROUP_ACTIVE;
	
	
	//Bei Wechsel des Bereichs wird auch multiselection abgewählt
	IF #panelActiv AND (#panelHmi.AREA_CHANGE OR #imp_GroupActive) THEN
	   #GLOB.PANEL_ORG.HMI_INTFACE_PANEL[#panelNr].FROM_PANEL.MULTISELECTION := false;
	END_IF;
	
	
	//****************************************************************************************************************************
	//Abwahl der anderen Stellgeräte anstossen
	//****************************************************************************************************************************
	IF #imp_devSelect AND NOT #MultiSelection THEN 
	  #panelDev.DEV_CHANGE_ACTIVE := true;
	   #devSelect := true;
	END_IF;
	
	
	IF #devSelect AND NOT #imp_devSelect THEN
	  #devSelect := false;
	  #panelDev.DEV_CHANGE_ACTIVE := false;
	END_IF;
	
	
	//****************************************************************************************************************************
	//Singale Stellgerät angewählt, freigabe, usw ...
	//****************************************************************************************************************************
	//Freigabe zur Handbedinung ausgeben
	#releaseManFG := #FG.OUT.MAN AND #FG.OUT.MAN_RELEASE;
	
	
	#releaseDevSelect := #releaseManFG
	                AND #RELEASE_SELECT
	                AND #panelActiv
	                AND NOT #panelHmi.SCREEN_CHANGE
	                AND NOT #imn_Multiselection
	                AND (NOT #GROUP.GROUP_ACTIVE OR #imp_devSelect)
	                AND ( NOT #panelDev.DEV_CHANGE_ACTIVE OR #devSelect) ;
	
	//FlipFlop Anwahl Stellgerät
	#devSelfSelected := #releaseDevSelect AND ( #devSelfSelected XOR #imp_devSelect);
	
	
	
	//Freigabe bedienen in Hand
	#releaseMan := #releaseManFG AND (#devSelfSelected OR  #GROUP.GROUP_ACTIVE);
	
	//Rückmeldung Stellgerätgruppe aktiv
	#GROUP.DEV_SELECTED := #releaseMan AND #GROUP.GROUP_ACTIVE;                  
	
	//Stellgerät ist aktiviert 
	#devSelected :=  #devSelfSelected OR #GROUP.DEV_SELECTED;
	
	//bei Gruppenanwahl wird die Vorwahl für Rückwärts von der Gruppe übernommen
	//Damit erfolgt im HMI ein andersfarbiger Farbumschlag
	IF #GROUP.DEV_SELECTED THEN
	  #HMI_REVERSE := #GROUP.REVERSE;
	END_IF;
	
	
	
	//****************************************************************************************************************************
	// Zurücksetzen der Visutasten
	//****************************************************************************************************************************
	
	//Ist Multiselektion nicht angewählt und auch keine Gruppenanwahl aktiv 
	//oder keine Freigabe zum aktivieren des Stellgeräts vorhanden
	// werden die Tasten von der HMI zurückgesetzt
	//oder die FG ist nicht mehr in Hand
	IF NOT #MultiSelection
	  AND NOT #GROUP.GROUP_ACTIVE
	  AND NOT #releaseDevSelect
	  OR #imp_Multiselection
	THEN
	  #HMI_REVERSE := false;
	END_IF;
	
	
	IF NOT #releaseDevSelect AND NOT #GROUP.GROUP_ACTIVE THEN
	  #HMI_BUTTON_ADV     := false;
	  #HMI_BUTTON_RET     := false;
	  #HMI_REVERSE        := false;
	  #GROUP.BUTTON_ADV   := false;
	  #GROUP.BUTTON_RET   := false;
	  #GROUP.GROUP_ACTIVE := false;
	  #GROUP.DEV_SELECTED := false;
	  #GROUP.REVERSE      := false;
	END_IF;
	
	
	//****************************************************************************************************************************
	//Ansteuerung Stellgerät vor / rück
	//****************************************************************************************************************************
	
	#manAdv := #devSelfSelected
	            AND #releaseMan
	            AND NOT #FG.OUT.MAN_RETRACT
	            AND NOT #HMI_BUTTON_RET
	            AND (#FG.OUT.MAN_ADVANCE OR #HMI_BUTTON_ADV);
	
	#manRet := #devSelfSelected
	            AND #releaseMan
	            AND NOT #FG.OUT.MAN_ADVANCE
	            AND NOT #HMI_BUTTON_ADV
	            AND (#FG.OUT.MAN_RETRACT OR #HMI_BUTTON_RET);
	
	#groupAdv:= #GROUP.GROUP_ACTIVE
	            AND #releaseMan
	            AND NOT #FG.OUT.MAN_RETRACT
	            AND NOT #GROUP.BUTTON_RET
	            AND (#FG.OUT.MAN_ADVANCE OR #GROUP.BUTTON_ADV);
	
	#groupRet:= #GROUP.GROUP_ACTIVE
	            AND #releaseMan
	            AND NOT #FG.OUT.MAN_ADVANCE
	            AND NOT #GROUP.BUTTON_ADV
	            AND (#FG.OUT.MAN_RETRACT OR #GROUP.BUTTON_RET);
	
	//****************************************************************************************************************************
	//Ausgänge beschalten
	//****************************************************************************************************************************
	#SELECTED := #devSelected;
	
	#MAN_ADV := #manAdv AND (NOT #HMI_REVERSE OR NOT #MultiSelection)
	          OR #manRet AND #HMI_REVERSE AND #MultiSelection
	          OR #groupAdv AND NOT #HMI_REVERSE
	          OR #groupRet AND #HMI_REVERSE;
	
	#MAN_RET := #manRet AND (NOT #HMI_REVERSE OR NOT #MultiSelection)
	          OR #manAdv AND #HMI_REVERSE AND #MultiSelection
	          OR #groupRet AND NOT #HMI_REVERSE
	          OR #groupAdv AND #HMI_REVERSE;
	
	
	//****************************************************************************************************************************
	//Paneldaten zurückschreiben
	//****************************************************************************************************************************
	IF #panelActiv THEN
	  #GLOB.PANEL_ORG.DEV_PANEL[#panelNr] := #panelDev;
	END_IF;
	
END_FUNCTION_BLOCK

FUNCTION "HMI_REGISTER_HEADER_FC" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_IN_OUT 
      HEADER : "HMI_REGISTER_HEADER_UDT";
   END_VAR

   VAR_TEMP 
      i : Int;
      ErrorRegisterArea : Bool;
      RegisterExist : Bool;
      FirstExistRegister : Int;
      ParameterFaul : Bool;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	Titel :             HMI_REGISTER_HEADER_FC
	Kommentar :         
	    
	Copyright 20xx      BMW AG .....
	Ersteller :         ??? 
	         
	****************************************************************************************************************************
	BAUSTEINBESCHREIBUNG
	 
	Hardware- Bindung     [x] 15xx
	Aufrufumgebung        [x] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	intern aufgerufene Bausteine mit eigenem Diagwort
	ID  Baustein
	
	
	----------------------------------------------------------------------------------------------------------------------------
	Hexwert Beschreibung
	abxx    a = A, C oder ID  b = Störklasse (ID)  xx = Meldenummer
	
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version     Autor         Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	
	@CHANGELOG@
	*)
	//******************************************************************************************************************************** 
	//         umkopieren auf OUT Struktur 
	//******************************************************************************************************************************** 
	
	//----- Aktuelle Seite -------------------------------
	IF #HEADER.IN.ACTIVE_REGISTER < 1 OR #HEADER.IN.ACTIVE_REGISTER > 16 THEN     
	#ErrorRegisterArea:=true;
	END_IF;
	
	 #i:=0;
	 FOR #i:=1 TO 16 DO  
	  IF #HEADER.IN.EXIST[#i]= TRUE THEN     //Prüfe ob eine Registerkarte existiert
	    IF #RegisterExist= false THEN             
	      #FirstExistRegister:=#i;           //Die erste existierende Registerkarte merken
	    END_IF;
	    #RegisterExist:= true;
	  END_IF;
	END_FOR;
	
	IF #RegisterExist = false THEN              //Es existiert kein Register
	  #HEADER.OUT.ACTIVE_REGISTER := 1;
	  #ParameterFaul:= true;
	 
	ELSIF #ErrorRegisterArea =true THEN         //Active Register Anforderung ausserhalb dem Bereich (aber es existiert ein Register)
	  #HEADER.OUT.ACTIVE_REGISTER :=  #FirstExistRegister;
	  #ParameterFaul:= true;
	  
	ELSIF #HEADER.IN.EXIST[#HEADER.IN.ACTIVE_REGISTER]= true THEN    //Angefordertes Register existiert
	  #HEADER.OUT.ACTIVE_REGISTER := #HEADER.IN.ACTIVE_REGISTER;
	  
	ELSE                                                        //Angefordertes Register existiert nicht (aber es existiert ein anderes)
	  #HEADER.OUT.ACTIVE_REGISTER:=  #FirstExistRegister;
	  #ParameterFaul:= true;
	END_IF;
	
	//----- Grundsymbol -------------------------------------------------------
	#HEADER.OUT.FAULT := #HEADER.IN.FAULT;
	#HEADER.OUT.WARNING := #HEADER.IN.WARNING;
	#HEADER.OUT.COMMISSIONING := #HEADER.IN.COMMISSIONING;
	#HEADER.OUT.PARAMETER_FAULT := #HEADER.IN.PARAMETER_FAULT OR #ParameterFaul;
	
	//----- Button Next --------------------------------------------------------
	#HEADER.OUT.BUTTON_NEXT_FAULT := #HEADER.IN.BUTTON_NEXT_FAULT;
	#HEADER.OUT.BUTTON_NEXT_WARNING := #HEADER.IN.BUTTON_NEXT_WARNING;
	#HEADER.OUT.BUTTON_NEXT_COMMISSIONING := #HEADER.IN.BUTTON_NEXT_COMMISSIONING;
	#HEADER.OUT.BUTTON_NEXT_PARAMETER_FAULT := #HEADER.IN.BUTTON_NEXT_PARAMETER_FAULT;
	
	//----- Button Previos ------------------------------------------------------
	#HEADER.OUT.BUTTON_PREVIOUS_FAULT := #HEADER.IN.BUTTON_PREVIOUS_FAULT;
	#HEADER.OUT.BUTTON_PREVIOUS_WARNING := #HEADER.IN.BUTTON_PREVIOUS_WARNING;
	#HEADER.OUT.BUTTON_PREVIOUS_COMMISSIONING := #HEADER.IN.BUTTON_PREVIOUS_COMMISSIONING;
	#HEADER.OUT.BUTTON_PREVIOUS_PARAMETER_FAULT := #HEADER.IN.BUTTON_PREVIOUS_PARAMETER_FAULT;
	
	//----- Existierende Seiten -----------------------------------------------
	#HEADER.OUT.EXIST := #HEADER.IN.EXIST;
	//-------------------------------------------------------------------
	
	
	//******************************************************************************************************************************** 
	//         Initialisierung 
	//******************************************************************************************************************************** 
	//----- Grundsymbol -----------------------------
	#HEADER.IN.FAULT := false;
	#HEADER.IN.WARNING := false;
	#HEADER.IN.COMMISSIONING := false;
	#HEADER.IN.PARAMETER_FAULT := false;
	
	//----- Button Next ------------------------------
	#HEADER.IN.BUTTON_NEXT_FAULT := false;
	#HEADER.IN.BUTTON_NEXT_WARNING := false;
	#HEADER.IN.BUTTON_NEXT_COMMISSIONING := false;
	#HEADER.IN.BUTTON_NEXT_PARAMETER_FAULT := false;
	
	//----- Button Previos ----------------------------
	#HEADER.IN.BUTTON_PREVIOUS_FAULT := false;
	#HEADER.IN.BUTTON_PREVIOUS_WARNING := false;
	#HEADER.IN.BUTTON_PREVIOUS_COMMISSIONING := false;
	#HEADER.IN.BUTTON_PREVIOUS_PARAMETER_FAULT := false;
	
	//----- Existierende Seiten ------------------------
	FOR #i := 1 TO 16 DO
	  #HEADER.IN.EXIST[#i] := false;
	END_FOR;
	//-------------------------------------------------
	
	
	#HEADER.IN.COUNTER := 0;
	
	
	
	
	
END_FUNCTION

FUNCTION "TOOL_DIAG_WORD_FC" : Void
TITLE = TOOL_DIAG_WORD_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW
FAMILY : TOOL
//Block for preparing and prioritizing diagnostic words. The block receives the incoming diagnostic word (DIAG_NEW), the diagnostic word to be passed through (DIAG_INOUT), and an ID to be integrated. If the incoming diagnostic word has a higher priority that the diagnostic word to be passed through, the incoming diagnostic word is output with the ID (DIAG_INOUT).
   VAR_INPUT 
      ID : USInt;   // Index number to be entered
      DIAG_NEW : Word;   // Diagnostics word to be output
   END_VAR

   VAR_IN_OUT 
      DIAG_INOUT : Word;   // Diagnostics word passed from call to call
   END_VAR

   VAR_TEMP 
      NewComMode : Bool;
      NewParaErr : Bool;
      NewErrIntern : Bool;
      NewErr : Bool;
      NewErrClass : Int;
      InOutComMode : Bool;
      InOutErrIntern : Bool;
      InOutParaErr : Bool;
      InOutNoErr : Bool;
      InOutErrClass : Int;
      InOutDiag : Word;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             TOOL_DIAG_WORD_FC     
	              Kommentar :         Baustein zur Aufbereitung und Priorisierung des Diagnosewortes. 
	                                  Der Baustein bekommt das eingehende Diagnosewort (DIAG_NEW), das durchzureichende 
	                                  Diagnosewort (DIAG_INOUT) und eine ID, die mit integriert werden soll. 
	                                  Hat das eingehende DIAG-Wort eine höhere Prio als das durchzureichende,
	                                  so wird das eigehende DIAG-Wort mit der ID ausgegeben (DIAG_INOUT).
	                                                     
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR
	              Datum :             30.09.2013
	              Bausteinstatus :    [x] freigegeben :       vollständig getestet
	                                  [ ] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [ ] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	            Hardware- Bindung     [ ] 319F   [ ] 15xx           [x] auf 319F und 15xx lauffähig
	            Aufrufumgebung        [] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	            aufgerufene Bausteine    :   keine weiteren                                     
	
	****************************************************************************************************************************
	
	@DESCRIPTION_DIAG@
	@DESCRIPTION_DIAG@
	
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Autor     Version   Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	30.09.2012  Breu      V0.0      Grundversion
	12.01.2015  Rahm      V1.34.x   Erweiterung Kennung "F", falls eingehendes DIAG-Wort bereits 
	                                mit TOOL_DIAG_WORD_FC oder TOOL_DIAG_MESS_HANDLE_FB behandelt wurde
	25.03.2015  Meyer R.  V1.35.x   Parameterkommentare überarbeitet  
	@CHANGELOG@
	*)
	
	//***************************************************************************************************************************
	//Auswertung nur wenn neuer Fehler vorhanden ist.
	//***************************************************************************************************************************
	IF #DIAG_NEW <> 0 THEN
	    // Speichern des durchgereichten DIAG-Wortes
	    #InOutDiag := #DIAG_INOUT;
	    
	    //***************************************************************************************************************************
	    //Auswertung der Fehler die schon im DIAG Wort sind
	    //***************************************************************************************************************************
	    #InOutNoErr := #DIAG_INOUT = 0;
	    
	    //Inbetriebnahmemodus aktiv
	    #InOutComMode := (#DIAG_INOUT AND w#16#F000) = w#16#C000;
	    
	    //Parametrierfehler aktiv
	    #InOutParaErr := (#DIAG_INOUT AND w#16#F000) = w#16#A000;
	    
	    //DIAG-Wort wurde bereits intern verschaltet
	    #InOutErrIntern := (#DIAG_INOUT AND w#16#F000) = w#16#F000;
	    
	    //Fehlerklasse ermitteln
	    #InOutErrClass := WORD_TO_INT(SHR(IN := #DIAG_INOUT AND w#16#0f00, N := 8));
	    
	    //***************************************************************************************************************************
	    //Auswertung der eigenen Fehler
	    //***************************************************************************************************************************
	    
	    //Inbetriebnahmemodus aktiv
	    #NewComMode := (#DIAG_NEW AND w#16#F000) = w#16#C000;
	    
	    //Parametrierfehler aktiv
	    #NewParaErr := (#DIAG_NEW AND w#16#F000) = w#16#A000;
	    
	    //Fehlerklasse ermitteln
	    #NewErrClass := WORD_TO_INT(SHR(IN := #DIAG_NEW AND w#16#0f00, N := 8));
	    
	    //Eingehendes DIAG-Wort wurde bereits mit TOOL_DIAG_WORD_FC oder TOOL_DIAG_MESS_HANDLE_FB behandelt
	    #NewErrIntern := #NewErrClass <> 0; // steht fest, sobald im 2. Halbbyte von links der Wert <> 0
	    
	    //***************************************************************************************************************************
	    //Auswertung der aufbereiteten Informationen
	    //DIAG-Wort wird nur ausgewertet, wenn durchzureichendes DIAG-Wort noch nicht intern verschaltet wurde (Kennung F)
	    //1.Prio: Inbetriebnahmemodus hat die höchste Priorität. Ist schon ein Inbetriebnahme Modus aktiv, wird dieser nicht überschrieben
	    //2.Prio: Als nächstes wird er Parameterfehler betrachtet. Ist dieser schon im Diag Wort aktiv, wird er nicht überschrieben
	    //3.Prio: Als nächstes werden die normalen Fehler betrachtet. Die Prioritäten werden über die Fehlerklasse ausgewertet. Die 
	    //        Fehlerklasse mit der niedrigsten Zahl hat die höchste Priorität
	    //***************************************************************************************************************************
	    
	    // Prüfen ob eingehendes DIAG-Wort höhere Prio, als das durchzureichende hat
	    IF NOT #InOutComMode AND NOT #InOutErrIntern THEN
	        IF #NewComMode OR #NewParaErr AND NOT #InOutParaErr THEN
	            #DIAG_INOUT := #DIAG_NEW OR SHL(IN := USINT_TO_WORD(#ID), N := 8);
	        ELSE
	            IF NOT #NewComMode
	                AND NOT #NewParaErr
	                AND NOT #InOutParaErr
	                AND (#NewErrClass < #InOutErrClass OR #InOutNoErr)
	            THEN
	                #DIAG_INOUT := #DIAG_NEW OR SHL(IN := USINT_TO_WORD(#ID), N := 12);
	            END_IF;
	        END_IF;
	    END_IF;
	    
	    // Kennung FX00 für Bausteininternen Fehler schreiben, falls eigenes DIAG-Wort übernommen wurde (höhere Prio)
	    IF (#DIAG_INOUT <> #InOutDiag) AND #NewErrIntern THEN
	        // DIAG-Wort mit F überschreiben
	        #DIAG_INOUT := w#16#F000;
	        // ID an 2. Stelle schreiben
	        #DIAG_INOUT := #DIAG_INOUT OR SHL(IN := USINT_TO_WORD(#ID), N := 8);
	    END_IF;
	    
	END_IF;
END_FUNCTION

FUNCTION "TOOL_DIAG_MESSHANDLER_REV2_FC" : Void
TITLE = TOOL_DIAG_MESSHANDLER_REV2_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW
FAMILY : TOOL
VERSION : 0.1
   VAR_INPUT 
      ID : USInt;   // Index number to be entered
   END_VAR

   VAR_IN_OUT 
      DIAG_INOUT : Word;   // Diagnostics word passed from call to call
      MESS : "MESS_HANDLE_SINGLE_UDT";
   END_VAR

   VAR_TEMP 
      InOutComMode : Bool;
      InOutParaErr : Bool;
      InOutNoErr : Bool;
      InOutErrClass : Int;
      MessNr : Int;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             TOOL_DIAG_MESSHANDLER_FC     
	              Kommentar :         Baustein zur Aufbereitung und Priorisierung des Diagnosewortes. Baustein bekommt das
	                                  Diagnosewort das ausgegeben werden soll und ein ID die mit Integriert werden soll. 
	                                  Über den IN_OUT Parameter DIAG_OUT wird das was bisher im Diag Wort steht ausgewertet
	                                  und im Bedarfsfall das neue ausgegegeben.
	              
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR
	              Datum :             30.09.2013
	              Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                                  [x] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [ ] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	            Hardware- Bindung     [ ] 319F   [ ] 15xx           [x] auf 319F und 15xx lauffähig
	            Aufrufumgebung        [] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	            aufgerufene Bausteine    :   keine weiteren                                     
	
	****************************************************************************************************************************
	
	@DESCRIPTION_DIAG@
	@DESCRIPTION_DIAG@
	
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version   Autor     Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	30.09.2013  V0.0      Breu          Grundversion
	29.10.2013  V1.1.x    Breu          Begrenzung der Fehlernummer wenn diese größer 255
	15.09.2013  V1.33.x   Schnellbögl   Umstellung auf neue MESS_HANDLE_SINGLE_UDT Struktur
	31.01.2019  V1.34.x   Eichlinger    Bugfix Fehlernummer begrenzen
	@CHANGELOG@
	*)
	
	
	//***************************************************************************************************************************
	//Auswertung der Fehler die schon im DIAG Wort sind
	//***************************************************************************************************************************
	#InOutNoErr := #DIAG_INOUT = 0;
	
	//Inbetriebnahmemodus aktiv
	#InOutComMode := (#DIAG_INOUT AND w#16#F000) = w#16#C000;
	
	//Parametrierfehler aktiv
	#InOutParaErr := (#DIAG_INOUT AND w#16#F000) = w#16#A000;
	
	//Fehlerklasse ermitteln
	#InOutErrClass := WORD_TO_INT(SHR(IN := #DIAG_INOUT AND w#16#0f00, N := 8));
	
	//***************************************************************************************************************************
	//Auswerteung der aufbereiteten Informationen
	//Inbetriebnahmemodus und Paramtrierfehler hat die höchste Proiorität. Ist ein solcher schon vorhanden wird dieses 
	//nicht überschrieben. Ab dann wird die Fehlerklasse zur Priorisierung verwendet
	//***************************************************************************************************************************
	IF (#MESS.LIST_PTR[0].NR > 0)
	  AND NOT #InOutComMode
	  AND NOT #InOutParaErr
	  AND (#MESS.ERROR_CLASS < #InOutErrClass OR #InOutNoErr)
	THEN
	  
	  //Fehlernummer begrenzen wenn diese größer 255 damit es zu keinem Überlauf bzw. Doppeldeutige
	  //Meldungen gibt
	  IF #MESS.LIST_PTR[0].NR < 256 THEN
	    #MessNr := #MESS.LIST_PTR[0].NR;
	  ELSE
	    #MessNr := 255;
	  END_IF;
	  
	  #DIAG_INOUT := SHL(IN := INT_TO_WORD(#MESS.ERROR_CLASS), N := 8) OR INT_TO_WORD(#MessNr) OR SHL(IN := USINT_TO_WORD(#ID), N := 12);
	END_IF;
	
	
END_FUNCTION

FUNCTION "MESS_GET_MESS_DETAIL_WINDOW_REV2_FC" : "MESS_DETAIL_WINDOW_UDT"
TITLE = MESS_GET_MESS_DETAIL_WINDOW_REV2_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW_TUE
FAMILY : MESS
VERSION : 0.1
//Retrieving texts from text lists, e.g., for display in a detailed window
   VAR_INPUT 
      MESS_HANDLER : "MESS_HANDLE_SINGLE_UDT";   // Error message to be displayed in the HMI detail window
      REFRESH : Bool;   // Additional condition in which the error text must be updated
   END_VAR

   VAR_IN_OUT 
      GLOB : "GLOB_UDT";   // Global data
   END_VAR

   VAR_TEMP 
      Data : "MESS_DETAIL_WINDOW_UDT";
      SeqGetText1 : "MESS_GET_TEXT_SEQ_UDT";
      SeqGetText2 : "MESS_GET_TEXT_SEQ_UDT";
      PanelView : Bool;
      PanelNr : USInt;
      Language : Int;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	Titel :             MESS_GET_MESS_DETAIL_WINDOW_REV2_FC     
	Kommentar :         Holen von Texten aus Textlisten zur Anzeige in einem Deteilfenster
	    
	Copyright 20xx      BMW AG .....
	Ersteller :         Markus Breu, SAR
	  
	Datum :             09.03.2013        
	Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                    [ ] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                    [ ] Entwicklungsstand : Programmcode noch in Bearbeitung
	                    [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	
	@DESCRIPTION_DIAG@
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version      Autor        Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	21.07.2014  V1.33.x      Schnellbögl  Ersterstellung basierend auf der MESS_HANDLE_SINGLE_UDT Struktur
	27.10.2014  V1.34.x      Schnellbögl  Erweiterung auf Ausgabe der zweiten Textliste 
	08.12.2014  V1.35.x      Schnellbögl  Formatierung Textausgabe
	30.10.2015  V1.36.x      Schnellbögl  Formatierung Textausgabe
	22.05.2015  V1.37.x      Schnellbögl  Umstellung auf Textlisten in 5 Sprachen
	24.02.2020  V1.38.x      Schnellbögl  Erweiterung auf >5 Onlinesprachen
	@CHANGELOG@
	*)
	
	//Auswerten auf welcher Ebene der Baustein aufgerufen wurde
	CASE "MODE_GET_LEVEL_INFO_FC"(#GLOB) OF
	  1:
	    #PanelView := #GLOB.MODE.PLC.OUT.PANEL_VIEW;
	    #PanelNr := #GLOB.MODE.PLC.OUT.PANEL_NR_VIEW;
	    
	  2:
	    #PanelView := #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].OUT.PANEL_VIEW;
	    #PanelNr := #GLOB.MODE.SG[#GLOB.MODE.RECENT_SG].OUT.PANEL_NR_VIEW;
	    
	  3:
	    #PanelView := #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].OUT.PANEL_VIEW;
	    #PanelNr := #GLOB.MODE.FG[#GLOB.MODE.RECENT_FG].OUT.PANEL_NR_VIEW;
	END_CASE;
	
	//Auslesen der Sprache des Panels
	IF #PanelNr > 0 AND #PanelNr <= #GLOB.SYS.CONST.PANEL_MAX THEN
	  #Language := #GLOB.PANEL_ORG.HMI_INTFACE_PANEL[#PanelNr].FROM_PANEL.LANGUAGE;
	END_IF;
	
	
	IF #PanelView OR #REFRESH THEN
	  
	  //Sprache auswählen
	//   IF (#Language = 0) OR (#Language > 5) THEN
	//     #Language := #GLOB.SYS.DEFAULT_HMI_LANGUAGE;
	//   ELSIF ((#Language >= 3) AND (#Language <= 5)) THEN
	//     #Language := 3;
	// END_IF;
	// Änderung 24.02.2020
	IF (#Language <= 0) THEN
	    #Language := #GLOB.SYS.DEFAULT_HMI_LANGUAGE;
	END_IF;
	IF (#Language >= 3) THEN
	    #Language := 3;
	END_IF;
	
	  
	  //Fehlermeldung für HMI aufbereiten
	  
	  IF #MESS_HANDLER.LIST_PTR[0].NR <> 0 THEN
	    #Data.CLASS := #MESS_HANDLER.ERROR_CLASS;
	    #Data.NR := #MESS_HANDLER.LIST_PTR[0].NR;
	    #Data.IPST_PRIO := #MESS_HANDLER.IPST_PRIO;
	    
	    //Text aus der Liste holen
	    "MESS_GET_TEXT_FC"(REF_DB := #MESS_HANDLER.LIST_PTR[0].DB,
	                       TEXT_NR := #MESS_HANDLER.LIST_PTR[0].NR,
	                       GLOB := #GLOB,
	                       SEQ := #SeqGetText1);
	    
	    // optionalen zweiten Text holen
	    IF #MESS_HANDLER.LIST_PTR[1].NR <> 0 THEN
	      "MESS_GET_TEXT_FC"(REF_DB := #MESS_HANDLER.LIST_PTR[1].DB,
	                         TEXT_NR := #MESS_HANDLER.LIST_PTR[1].NR,
	                         GLOB := #GLOB,
	                         SEQ := #SeqGetText2);
	    END_IF;
	    
	    //Prüfen Sprache vom Panel im richtigen bereich
	    IF #Language >= 1 AND #Language <= 3 THEN
	      //Text kopieren
	      IF #MESS_HANDLER.LIST_PTR[1].NR <> 0 THEN
	        #Data.TEXT := CONCAT(IN1 := #SeqGetText1.TEXT.LANG[#Language], IN2 := STRING_TO_WSTRING(', '));
	        #Data.TEXT := CONCAT(IN1 := #Data.TEXT, IN2 := #SeqGetText2.TEXT.LANG[#Language]);
	      ELSE
	        #Data.TEXT := #SeqGetText1.TEXT.LANG[#Language];
	      END_IF;
	    END_IF;
	    
	  END_IF;
	END_IF;
	
	//Funktion verlassen
	#MESS_GET_MESS_DETAIL_WINDOW_REV2_FC := #Data;
END_FUNCTION

TYPE "CVFL_FLXXX_HMI_UDT"
VERSION : 0.1
   STRUCT
      OUT : Struct
         LOCATION : String[30] := '?xxFLxx?';   // ID place 'pattern place abcdef'
         ERROR_AZ : "MESS_DETAIL_WINDOW_UDT";   // Error display
         DIAG : Word;   // Diagnostics information
         Error : Bool;   // General error
         ERROR_CLEARANCE : Bool;   // Error gap monitoring
         WARNING : Bool;   // General warning
         manual : Bool;   // Manual
         automatic : Bool;   // Automatic
         Power_on : Bool;   // Power on
         release_reset : Bool;   // Release reset
         SI_gebrueckt : Bool;   // Safety features overridden
         Pos_RET_stop : Bool;   // Final position retract
         Pos_RET_slow : Bool;   // Change-over V2/V1 retract
         Pos_MID_RET : Bool;   // Final position center position RET
         Pos_MID_ADV : Bool;   // Final position center position ADV
         Pos_ADV_stop : Bool;   // Final position advance
         Pos_ADV_slow : Bool;   // Change-over V2/V1 advance
         contr_retr : Bool;   // Control retract
         contr_adv : Bool;   // Control advance
         contr_active : Bool;   // Control active (advance or retract)
         contr_slow : Bool;   // Control slow
         INTERLOCK_ADV : Bool;   // Interlock advance
         INTERLOCK_RET : Bool;   // Interlock retract
         home : Bool;   // Home position
         empty : Bool;   // Empty
         occupied : Bool;   // Conveyor occupied
         Traverse_comes : Bool;   // Bar coming (hide Beros)
         SAVE_SLOWLY_RET : Bool;   // Saved F1/F2 change-over RET
         SAVE_SLOWLY_ADV : Bool;   // Saved F1/F2 change-over ADV
         Status_Bereit_Einf_RET : Bool;   // Ready for drive on RET side
         Status_Bereit_Einf_ADV : Bool;   // Ready for drive on ADV side
         Status_Ausfoerdern_RET : Bool;   // drive_out RET side
         Status_Ausfoerdern_ADV : Bool;   // drive_out ADV side
         Status_SK : Int;   // Status SK 0..n
         Anwahl_Einfoerdern_RET : Bool;   // Selection infeed RET side
         Anwahl_Einfoerdern_ADV : Bool;   // Selection infeed ADV side
         Wegmerker_RET : Bool;   // Path marker RET side
         Wegmerker_ADV : Bool;   // Path marker ADV side
         interlock_transport_RET : Bool;   // Interlock transport RET side
         interlock_transport_ADV : Bool;   // Interlock transport ADV side
         mode_reverse : Bool;   // Mode reverse 0=ADV, 1=RET (final pos.)
         "Type" : Int;   // 1 = STROKE, 2 = floor conveyor
         exists_V2 : Bool;   // V2 speed exists
         EXISTS_BUTTON_SLOWLY : Bool;   // Slow button exists
         exists_RET : Bool;   // RET (Beros) exists
         exists_Traverse : Bool;   // Paint bar exists
         exists_MID_Pos : Bool;   // Final position center position exists
         DevName : String[24];   // Name
         OP_RELEASE : Bool;   // Operator release using panel[xx]
         ACTUATOR_HOME_POSTION : Bool;   // Actual home position for selected home position (for visu)
         COMMISSIONING : Bool;   // Commissioning active for this actuator
         PARAMETER_ERROR : Bool;   // Parameterization error in actuator FB (for visu)
         ACTUATOR_SELECT : Bool;   // Actuator selected
         AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET : Bool;   // Advance automatically when occupied until RET
         AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV : Bool;   // Advance automatically when occupied until ADV
         AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET_CONFIG : Bool;   // Advance automatically when occupied until RET CONFIG
         AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV_CONFIG : Bool;   // Advance automatically when occupied until ADV CONFIG
         RELEASE_MAN : Bool;   // Release manual operation
         CONFIG_FG : Int;   // Configured FG of actuator
         SEQ_NR : Int;   // Sequence number
         SEQ_RET_connected : Bool;   // Status RET side actively connected
         SEQ_RET_mode_reverse : Bool;   // Status RET side swap side RET<>ADV
         SEQ_ADV_connected : Bool;   // Status ADV side actively connected
         SEQ_ADV_mode_reverse : Bool;   // Status ADV side swap side RET<>ADV
         SEQ_RET : "CVFL_FLXXX_SEQ_UDT";   // Status RET side
         SEQ : "CVFL_FLXXX_SEQ_UDT";   // Status
         SEQ_ADV : "CVFL_FLXXX_SEQ_UDT";   // Status ADV side
         TYPE_ENABLE_CHECK : Bool := FALSE;   // Allow test
         TYPE_RELEASE_PART_NO_CHECK : Bool := TRUE;   // Move on if check was failed
         SLOWLY_SAVE_RET : Bool;   // SAVE speed slowly retract
         SLOWLY_SAVE_ADV : Bool;   // SAVE speed slowly advance
         DRIVE_THROUGH_RET : Bool;   // Pass through RET side (if possible)
         DRIVE_THROUGH_ADV : Bool;   // Pass through ADV side (if possible)
         TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_RET : Bool;   // Transport drive ends when the V2/V1 RET switch is reached
         TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_ADV : Bool;   // Transport drive ends when the V2/V1 ADV switch is reached
         ENABLE_SHUTTLE_FUNCTION_IN_RET : Bool;   // Activation shuttle function retract RET
         ENABLE_SHUTTLE_FUNCTION_IN_ADV : Bool;   // Activation shuttle function retract ADV
         INPUT_SHUTTLE_IN_RET : Bool;   // Input RET shuttle function retract (new part coming)
         INPUT_SHUTTLE_IN_ADV : Bool;   // Input ADV shuttle function retract (new part coming)
         ENABLE_START_UP_WARNING_FUNCTION : Bool;   // Activation start-up warning function
         START_UP_WARNING_RELEAS_TO_START : Bool := false;   // Start-up warning Start release
         START_UP_WARNING_READY_TO_START : Bool;   // Start-up warning Ready to start or empty
      END_STRUCT;
      IN : Struct
         button_transport_RET : Bool;   // Transport RET button
         button_transport_ADV : Bool;   // Transport ADV button
         button_reset : Bool;   // Reset button
         button_slowly : Bool;   // Slow button
         button_invert_occupied : Bool;   // Invert busy button
         BUTTON_ADV : Bool;   // Advance button
         BUTTON_CENTER : Bool;   // Center button
         BUTTON_RET : Bool;   // Retract button
         SELECT : Bool;   // Activate actuator button
         REVERSE : Bool;   // On multiple selection, opposite actuation
      END_STRUCT;
      REG : Struct
         HEADER : "HMI_REGISTER_HEADER_UDT";   // Texts for instance names
         INTERN : "HMI_REGISTER_SHEET_UDT";   // Register for oneself
         SHEET_02 : "HMI_REGISTER_SHEET_UDT";   // Register for .......  Depending on application
         SHEET_03 : "HMI_REGISTER_SHEET_UDT";   // Register for .......  Depending on application
         SHEET_04 : "HMI_REGISTER_SHEET_UDT";   // Register for .......  Depending on application
         SHEET_DRV : "HMI_REGISTER_SHEET_UDT";   // Register for .......  Depending on application
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION "MESS_HANDLE_SINGLE_FC" : Bool
TITLE = MESS_HANDLE_SINGLE_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW_TUE
FAMILY : MESS
VERSION : 0.1
//MESS_HANDLE_SINGLE_FC and MESS_HANDLE_SINGLE_FB are a fixed unit
//MESS_HANDLE_SINGLE_FC: Triggers entry and removal of fault messages into/from the active register.
//#"MESSAGE".DATA.LIST_PTR.ITEM[0].NR   <> 0         :   Output INCOMING message
//#"MESSAGE".DATA.LIST_PTR.ITEM[0].NR   =  0         :   Output OUTGOING message
//#"MESSAGE".DATA.LIST_PTR.ITEM[0].NR   change      :   Output OUTGOING + INCOMING messages
//
//A message is only output if "NO_MESSAGE" is not set at message level
//Return value: Cycle in which the message is copied to the active register
//MESS_HANDLE_SINGLE_FB: Executes entry and removal of fault messages into/from the active register.
   VAR_OUTPUT 
      DIAG : Word;
   END_VAR

   VAR_IN_OUT 
      MESSAGE : "MESS_HANDLE_SINGLE_UDT";
      IFACE : "MESS_HANDLE_SINGLE_IFACE_UDT";
      GLOB : "GLOB_UDT";
   END_VAR

   VAR_TEMP 
      SgNr : Int;
      FgNr : Int;
      CO_SizeActReg : Int;
      ActiveWritePointer : Int;
      Index : Int;
      MaxActivityReached : Bool;
      NoMessage : Bool;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	Titel :             MESS_HANDLE_SINGLE_FC
	Kommentar :         MESS_HANDLE_SINGLE_FC und MESS_HANDLE_SINGLE_FB bilden eine feste Einheit
	                    MESS_HANDLE_SINGLE_FC : Triggert das Ein- und Austragen der Störmeldungen ins /aus dem Aktiv Register.
	                      #"MESSAGE".DATA.LIST_PTR.ITEM[0].NR   <> 0         :   KOMMEND Meldung absetzen             
	                      #"MESSAGE".DATA.LIST_PTR.ITEM[0].NR   =  0         :   GEHEND Meldung absetzen     
	                      #"MESSAGE".DATA.LIST_PTR.ITEM[0].NR   Änderung     :   GEHEND + KOMMEND Meldung absetzen  
	                      
	                    Eine Meldung wird nur abgesetzt, wenn in der Meldungsebene "NO_MESSAGE" nicht gesetzt ist 
	                    
	                    Rückgabewert : Zyklus, in dem die Meldung ins Aktivregister kopiert wird
	                    
	                    MESS_HANDLE_SINGLE_FB : Führt das Ein- und Austragen der Störmeldungen ins /aus dem Aktiv Register aus.
	              
	Copyright 20xx      BMW AG .....
	Ersteller :         G. Schnellbögl                   
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	Hardware- Bindung     [ ] 319F   [x] 15xx
	Aufrufumgebung        [ ] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [x] Anwender
	aufgerufene Bausteine    :                                    
	
	TODO :
	   
	
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	   
	A001  Laufzeitfehler FG Nummer falsch
	A002  Laufzeitfehler SG Nummer falsch
	A003  Laufzeitfehler keine gültige Referenz auf Text DB
	A004  Laufzeitfehler keine gültiger Schreibzeiger für Aktivregister
	A005  Laufzeitfehler keine gültiger Indexzeiger für Aktivregister
	A006  Maximale Anzahl von Aktivitäten für diesen Zyklus erreicht
	A007  Initalisierung vom Meldesystem aktiv
	A008  Keine Meldung absetzen von MODE Struktur angewählt
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version Autor             Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	
	03.07.2014  V1.33.x Schnellbögl        Ersterstellung
	01.08.2014  V1.34.x Schnellbögl        Logik Trigger Operand invertiert
	10.09.2014  V1.35.x Schnellbögl        Erweiterung um Auswertung #"MESSAGE".DATA.COMMISSIONING_MODE : keine Meldung absetzen, keine Error Generierung
	02.10.2014  V1.36.x Schnellbögl        Bugfix Bildung DIAG Wort
	02.01.2015  V1.37.x Schnellbögl        Rückgabewert angepasst : Header muss auch bei ErrordoubleUse gelesen werden !
	11.03.2015  V1.38.x Schnellbögl        Umstellung auf globale Konstanten  CO_MODE_FG_MAX, CO_MODE_SG_MAX 
	02.11.2016  V1.39.x Schnellbögl        Trigger für neue Meldung jetzt auch über Änderung der ERROR_CLASS
	29.08.2019  V1.40.x Schnellbögl        maxEintrag ins Aktivregister pro Zyklus um 1 reduziert, sonst u.U. Überlauf Change Regiszer möglich !
	@CHANGELOG@
	*)
	
	//**************************************************************************************************************************
	// Konstantendeklarationen
	//**************************************************************************************************************************
	//"CO_MODE_FG_MAX"  wird direkt verwendet
	//"CO_MODE_SG_MAX"  wird direkt verwendet
	#CO_SizeActReg := #GLOB.MESS.ACTIVE.MAX_SIZE;
	
	// Rückgabewert default
	#MESS_HANDLE_SINGLE_FC := FALSE;
	
	//*************************************************************************************************************************************
	//                                  Fehlerebene ermitteln                ( SG Ebene  : FG = 0 !)
	//                                                                       ( PLC Ebene : SG = 0, Fg = 0)        
	//*************************************************************************************************************************************
	#SgNr := #GLOB.MODE.RECENT_SG;
	#FgNr := #GLOB.MODE.RECENT_FG;
	
	//***************************************************************************************************************************
	//     DIAGNOSE   : Parametrierfehler
	//***************************************************************************************************************************
	#DIAG := 0;
	#IFACE.DIAG := w#16#0000;
	IF (#FgNr < 0) OR (#FgNr > "CO_MODE_FG_MAX") THEN
	  #DIAG := w#16#A001;
	  #IFACE.DIAG := w#16#A001;
	  RETURN;
	END_IF;
	IF (#SgNr < 0) OR (#SgNr > "CO_MODE_SG_MAX") THEN
	  #DIAG := w#16#A002;
	  #IFACE.DIAG := w#16#A002;
	  RETURN;
	END_IF;
	//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Prüfen ob Fehler nicht anders abgefangen werden kann
	// IF DB_ANY_TO_UINT(#REF_DB_LIST_1) = 0 THEN
	//   #DIAG := w#16#A003;
	// END_IF;
	
	//**************************************************************************************************************************
	// interne Variablen beschreiben
	//**************************************************************************************************************************
	
	#ActiveWritePointer := #GLOB.MESS.ACTIVE.PTR_IN;
	
	//**************************************************************************************************************************
	// Prüfen ob Zeiger und Index Plausibel sind und Ressourcen noch vorhanden
	//************************************************************************************************************************** 
	IF #ActiveWritePointer <= 0 OR #ActiveWritePointer > #CO_SizeActReg THEN
	  #DIAG := w#16#a004;
	  #IFACE.DIAG := w#16#A004;
	  RETURN;
	END_IF;
	
	#Index := #GLOB.MESS.ACTIVE.LINE_INDEX[#ActiveWritePointer];
	IF #Index < 0 OR #Index > #CO_SizeActReg THEN
	  #DIAG := w#16#a005;
	  #IFACE.DIAG := w#16#A005;
	  RETURN;
	END_IF;
	
	// reine Meldung:  Anzahl zulässiger Einträge pro Zyklus überschritten ->  wird in nächsten Zyklus verschoben !
	#MaxActivityReached := #GLOB.MESS.ACTIVE.CUR_ACTIVE >= (#GLOB.MESS.ACTIVE.MAX_ACTIVE-1);
	IF #MaxActivityReached THEN
	  #DIAG := w#16#a006;
	  #IFACE.DIAG := w#16#A006;
	END_IF;
	
	//Meldung: Initalisierung vom Meldesystem ist aktiv
	IF #GLOB.MESS.ACTIVE.INIT THEN
	  #DIAG := w#16#a007;
	  #IFACE.DIAG := w#16#A007;
	END_IF;
	
	
	//**************************************************************************************************************************
	// keine Meldungen senden, falls NO_MESSAGE gesetzt ist 
	//**************************************************************************************************************************
	
	IF (#SgNr = 0) AND (#FgNr = 0) THEN
	  // PLC Ebene
	  #NoMessage := #GLOB.MODE.PLC.OUT.CO_NO_MESSAGE;
	ELSIF ((#SgNr <> 0) AND (#FgNr = 0)) THEN
	  // SG Ebene
	  #NoMessage := #GLOB.MODE.SG[#SgNr].OUT.CO_NO_MESSAGE;
	ELSIF (#FgNr <> 0) THEN
	  // FG Ebene
	  #NoMessage := #GLOB.MODE.FG[#FgNr].OUT.CO_NO_MESSAGE;
	END_IF;
	
	//Wenn no Message aktiv ist diese als Meldung ausgeben
	IF #NoMessage THEN
	  #DIAG := w#16#a008;
	END_IF;
	
	// ebenfalls keine Meldung absetzen, wenn COMMISSIONING_MODE angewählt ist !
	#NoMessage := #NoMessage OR #MESSAGE.COMMISSIONING_MODE;
	
	//**************************************************************************************************************************
	// Neue KOMMEND Meldung puffern : BACKUP Meldung im FB inkl KOMMEND Zeit                        #IFACE.BUFFER_MESSAGE_COMING
	//**************************************************************************************************************************
	// Der FC gibt den Impuls an den FB zum Speichern der Meldung und zum Abspeichern der Kommendzeit
	// Der FB setzt das Bit nach Ausführung wieder zurück !
	// Bedingung ist, dass aktuell keine Meldung ansteht : #IFACE.RECENT_MESSAGE_PTR = 0
	// und dass noch kein Speicherauftrag vorhanden ist :  #IFACE.MESSAGE_COMING_BUFFERED
	// und dass Meldungen Senden freigegeben ist
	
	IF (#MESSAGE.LIST_PTR[0].NR > 0) AND (#IFACE.RECENT_MESSAGE_PTR = 0) AND NOT #IFACE.MESSAGE_COMING_BUFFERED
	  AND NOT #NoMessage AND #IFACE.FB_READY AND NOT #GLOB.MESS.ACTIVE.INIT THEN
	  #IFACE.BUFFER_MESSAGE_COMING := TRUE;
	END_IF;
	
	//**************************************************************************************************************************
	// gepufferte KOMMEND Meldung ins Aktivregister eintragen                                  #IFACE.SEND_STORED_MESSAGE_COMING
	//**************************************************************************************************************************
	// Der FC gibt den Impuls an den FB zum Eintrag ins Aktivregister
	// Der FB setzt das Bit nach Ausführung wieder zurück !
	// Bedingung ist, dass noch ins Aktivregister eingetragen werden darf , dass keine Anforderung für ein GEHEND Ereignis ansteht,
	// denn sonst würde der Zeiger überschrieben werden und die alte Meldung könnte nicht mehr gelöscht werden !
	
	IF (#IFACE.MESSAGE_COMING_BUFFERED OR #IFACE.BUFFER_MESSAGE_COMING) AND NOT #IFACE.SEND_MESSAGE_GOING AND NOT #MaxActivityReached
	  AND #IFACE.FB_READY AND NOT #GLOB.MESS.ACTIVE.INIT THEN
	  #IFACE.SEND_STORED_MESSAGE_COMING := TRUE;
	END_IF;
	
	//**************************************************************************************************************************
	// Änderung der Textnummer oder Error Class :  GEHEND Anstoss generieren
	//**************************************************************************************************************************
	// Bei erkannter Änderung der Textnummer wird ein GEHEND Anstoss generiert
	// Ist dieser ausgeführt, wird automatisch über den Fall "Neue KOMMEND Meldung puffern" eine neue Meldung gesendet
	// 
	IF (#MESSAGE.LIST_PTR[0].NR > 0) AND ((#MESSAGE.LIST_PTR[0].NR <> #IFACE.RECENT_MESSAGE_NR_SENT) OR (#MESSAGE.ERROR_CLASS <> #IFACE.RECENT_ERROR_CLASS_SENT)) AND
	  (#IFACE.RECENT_MESSAGE_PTR > 0) AND #IFACE.FB_READY AND NOT #GLOB.MESS.ACTIVE.INIT AND NOT #IFACE.MESSAGE_GOING_BUFFERED THEN
	  #IFACE.BUFFER_MESSAGE_GOING := TRUE;
	END_IF;
	
	//**************************************************************************************************************************
	// No Message  :  GEHEND Anstoss generieren
	//**************************************************************************************************************************
	
	IF #NoMessage AND (#MESSAGE.LIST_PTR[0].NR > 0) AND (#IFACE.RECENT_MESSAGE_PTR > 0)
	  AND #IFACE.FB_READY AND NOT #GLOB.MESS.ACTIVE.INIT AND NOT #IFACE.MESSAGE_GOING_BUFFERED THEN
	  #IFACE.BUFFER_MESSAGE_GOING := TRUE;
	END_IF;
	
	//**************************************************************************************************************************
	// GEHEND Meldung puffern : BACKUP GEHEND Zeit                                                   #IFACE.BUFFER_MESSAGE_GOING
	//**************************************************************************************************************************
	// Der FC gibt den Impuls an den FB zum Abspeichern der Gehendzeit
	// Der FB setzt das Bit nach Ausführung wieder zurück !
	// Bedingung ist, dass aktuell eine Meldung ansteht : #IFACE.RECENT_MESSAGE_PTR > 0
	// und dass noch kein Speicherauftrag vorhanden ist :  #IFACE.MESSAGE_GOING_BUFFERED
	
	IF (#MESSAGE.LIST_PTR[0].NR = 0) AND (#IFACE.RECENT_MESSAGE_PTR > 0) AND NOT #IFACE.MESSAGE_GOING_BUFFERED
	  AND #IFACE.FB_READY AND NOT #GLOB.MESS.ACTIVE.INIT THEN
	  #IFACE.BUFFER_MESSAGE_GOING := TRUE;
	END_IF;
	
	//**************************************************************************************************************************
	// gepufferte GEHEND Meldung im Aktivregister als gehend markieren                                 #IFACE.SEND_MESSAGE_GOING
	//**************************************************************************************************************************
	// Der FC gibt den Impuls an den FB zum Eintrag ins Aktivregister
	// Der FB setzt das Bit nach Ausführung wieder zurück !
	// Bedingung ist, dass noch ins Aktivregister eingetragen werden darf 
	
	IF (#IFACE.MESSAGE_GOING_BUFFERED OR #IFACE.BUFFER_MESSAGE_GOING) AND NOT #MaxActivityReached THEN
	  #IFACE.SEND_MESSAGE_GOING := TRUE;
	END_IF;
	
	//**************************************************************************************************************************
	// Rückgabewert    :  1 Zyklus - nachgelagerte Programmteile können Daten in die MESS_HANDLE_SINGLE_UDT Struktur kopieren
	//                               da Meldung in diesem Zyklus ins Aktivregister eingetragen wird
	//                               Ausnahme : Error_Double_Use
	//**************************************************************************************************************************
	#IFACE.TRIGGER_READ_HEADER := #IFACE.SEND_STORED_MESSAGE_COMING;
	#MESS_HANDLE_SINGLE_FC := #IFACE.SEND_STORED_MESSAGE_COMING OR #IFACE.ERROR_DOUBLE_USE;
	
	//**************************************************************************************************************************
	//   vorgelagerte Programmteile können Daten in die MESS_HANDLE_SINGLE_UDT Struktur kopieren        
	//**************************************************************************************************************************
	// Status False   :   Operand wird gelesen !
	#IFACE.TRIGGER_READ_OPERAND := NOT ((#IFACE.RECENT_MESSAGE_PTR = 0) AND NOT #IFACE.MESSAGE_COMING_BUFFERED
	AND #IFACE.FB_READY AND NOT #GLOB.MESS.ACTIVE.INIT);
	
	
END_FUNCTION

FUNCTION "HMI_REGISTER_SHEET_HS_SS_FC" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      "NAME" : String[254];
   END_VAR

   VAR_IN_OUT 
      HEADER : "HMI_REGISTER_HEADER_UDT";
      SHEET : "HMI_REGISTER_SHEET_UDT";
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	Titel :             HMI_REGISTER_SHEET_HS_SS_FC
	Kommentar :         
	    
	Copyright 20xx      BMW AG .....
	Ersteller :         ??? 
	         
	****************************************************************************************************************************
	BAUSTEINBESCHREIBUNG
	 
	Hardware- Bindung     [x] 15xx
	Aufrufumgebung        [x] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	intern aufgerufene Bausteine mit eigenem Diagwort
	ID  Baustein
	
	
	----------------------------------------------------------------------------------------------------------------------------
	Hexwert Beschreibung
	abxx    a = A, C oder ID  b = Störklasse (ID)  xx = Meldenummer
	
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version     Autor         Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	
	@CHANGELOG@
	*)
	
	#HEADER.IN.COUNTER := #HEADER.IN.COUNTER + 1;
	
	
	//Sammelbits für Grundsymbol
	IF #SHEET.PARAMETER_FAULT THEN
	  #HEADER.IN.PARAMETER_FAULT := true;
	END_IF;
	
	IF #SHEET.COMMISSIONING THEN
	  #HEADER.IN.COMMISSIONING := true;
	END_IF;
	
	IF #SHEET.FAULT THEN
	  #HEADER.IN.FAULT := true;
	END_IF;
	
	IF #SHEET.WARNING THEN
	  #HEADER.IN.WARNING := true;
	END_IF;
	
	
	//Sammelsignale für Buttons zum blättern
	IF #HEADER.IN.COUNTER > 8 THEN
	  
	  //SammelSignale ButtonNext
	  IF #SHEET.PARAMETER_FAULT THEN
	    #HEADER.IN.BUTTON_NEXT_PARAMETER_FAULT := true;
	    
	    IF #HEADER.IN.ACTIVE_REGISTER <> 0 THEN
	      #HEADER.IN.ACTIVE_REGISTER  := #HEADER.IN.COUNTER;
	    END_IF;
	    
	  END_IF;
	  
	  IF #SHEET.COMMISSIONING THEN
	    #HEADER.IN.BUTTON_NEXT_PARAMETER_FAULT := true;
	  END_IF;
	  
	  IF #SHEET.FAULT THEN
	    #HEADER.IN.BUTTON_NEXT_FAULT := true;
	  END_IF;
	  
	  IF #SHEET.WARNING THEN
	    #HEADER.IN.BUTTON_NEXT_WARNING := true;
	  END_IF;
	  
	ELSE
	    //SammelSignale ButtonPrvious
	    IF #SHEET.PARAMETER_FAULT THEN
	    #HEADER.IN.BUTTON_PREVIOUS_FAULT := true;
	  END_IF;
	  
	  IF #SHEET.COMMISSIONING THEN
	    #HEADER.IN.BUTTON_PREVIOUS_PARAMETER_FAULT := true;
	  END_IF;
	  
	  IF #SHEET.FAULT THEN
	    #HEADER.IN.BUTTON_PREVIOUS_FAULT := true;
	    
	    IF #HEADER.IN.ACTIVE_REGISTER <> 0 THEN
	      #HEADER.IN.ACTIVE_REGISTER  := #HEADER.IN.COUNTER;
	    END_IF;
	    
	  END_IF;
	  
	  IF #SHEET.WARNING THEN
	    #HEADER.IN.BUTTON_PREVIOUS_WARNING := true;
	  END_IF;
	
	END_IF;
	
	// exist
	#HEADER.IN.EXIST[#HEADER.IN.COUNTER ] := #SHEET.EXIST;
	#HEADER.SHEETS[#HEADER.IN.COUNTER]:= #NAME;
	
	
	
	  
	
	
	
END_FUNCTION

FUNCTION "MESS_HANDLE_READ_HEADER_FC" : Void
TITLE = MESS_HANDLE_READ_HEADER_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW_TUE
FAMILY : MESS
VERSION : 0.1
//Block used to input the header data in MESS_HANDLE_SINGLE_UDT
   VAR_INPUT 
      "TYPE" : WString;
      LOCATION : WString;
   END_VAR

   VAR_IN_OUT 
      MESSAGE : "MESS_HANDLE_SINGLE_UDT";
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	Titel :             MESS_READ_HEADER_FC
	Kommentar :         Baustein wird zum Einlesen der Headerdaten in die MESS_HANDLE_SINGLE_UDT verwendet
	                    
	              
	Copyright 20xx      BMW AG .....
	Ersteller :         G. Schnellbögl                   
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	Hardware- Bindung     [ ] 319F   [x] 15xx
	Aufrufumgebung        [ ] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [x] Anwender
	aufgerufene Bausteine    :                                    
	
	
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	nicht vorhanden
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version Autor             Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	
	16.07.2014  V1.00.x Schnellbögl        Ersterstellung   
	@CHANGELOG@                                   
	*)
	#MESSAGE.HEADER.TYPE :=     WSTRING_TO_STRING(#TYPE);
	#MESSAGE.HEADER.LOCATION := WSTRING_TO_STRING(#LOCATION);
END_FUNCTION

FUNCTION "MODE_SET_CONTROLLED_STOP_REV2_FC" : Void
TITLE = MODE_SET_CONTROLLED_STOP_REV2_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW_TUE
FAMILY : MODE
VERSION : 0.1
//Manipulation of the controlled stop group bit via the MESS_HANDLE_SINGLE_UDT structure,
//Call only permissible at FG level: the controlled stop group bit is reset by way of the reset input
//This block is intended for use in all actuator blocks which need to manipulate the controlled stop state.
//At the same time, the block manages the DIAG_CONTROLLED_STOP stack at FG level
   VAR_INPUT 
      RESET_CONTROLLED_STOP : Bool;   // The Controlled STOP FG group bit is reset for TRUE
      INSTANCE_NAME : String;   // Multiple instance name of block
   END_VAR

   VAR_OUTPUT 
      DIAG : Word;   // Diagnostics information
   END_VAR

   VAR_IN_OUT 
      MESS_HANDLER : "MESS_HANDLE_SINGLE_UDT";   // Active message :   Data structure
      GLOB : "GLOB_UDT";   // Global data
   END_VAR

   VAR_TEMP 
      FgNr : Int;
      SgNr : Int;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	Titel :             MODE_SET_CONTROLLED_STOP_REV2_FC     
	Kommentar :         Manipulation des Controlled Stop Sammelbits über die MESS_HANDLE_SINGLE_UDT Struktur,
	                    Aufruf nur auf FG Ebene zulässig : mit dem Reset Eingang wird das Controlled Stop Sammelbit rückgesetzt
	                    Dieser Baustein ist zur Verwendung in allen Aktorbausteinen gedacht, die den Controlled Stop Zustand beeinflussen müssen.
	                    Zugleich verwaltet der Baustein den Stack DIAG_CONTROLLED_STOP auf FG Ebene
	    
	Copyright 20xx      BMW AG .....
	Ersteller :         TP-114 Schnellbögl                   
	           
	****************************************************************************************************************************
	BAUSTEINBESCHREIBUNG
	 
	Hardware- Bindung     [x] 15xx  
	Aufrufumgebung        [x] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	Hexwert   Beschreibung
	abxx      a = A,C oder ID     b = Störklasse (oderID)      xx = Meldenummer
	
	A001      Konfigurationsfehler FG Nummer falsch
	A002      Konfigurationsfehler SG Nummer falsch
	A003      Konfigurationsfehler : Baustein nicht auf FG Ebene aufgerufen
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version       Autor         Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	01.07.2014  V1.33.0       Schnellbögl   Ersterstellung 
	30.07.2014  V1.34.x       Schnellbögl   Stackbefüllung nur falls Anforderung CONTROLLED STOP existiert und noch AUT Start anliegt
	11.03.2015  V1.35.x       Schnellbögl   Umstellung auf globale Konstanten  CO_MODE_FG_MAX, CO_MODE_SG_MAX 
	18.06.2015  V1.36.x       Breu          Stackbefüllung Controlled Stopp Betriebsartenunabhängig
	@CHANGELOG@
	*)
	// Arraygrenzen absichern
	// nicht notwendig, da nur geschrieben wird, falls noch Platz im Stack ist !
	
	//Ebeneninformation auslesen
	#FgNr := #GLOB.MODE.RECENT_FG;
	#SgNr := #GLOB.MODE.RECENT_SG;
	
	#DIAG := 0;
	IF (#FgNr < 0) OR (#FgNr > "CO_MODE_FG_MAX") THEN
	  #DIAG := w#16#A001;
	  RETURN;
	END_IF;
	IF (#SgNr < 0) OR (#SgNr > "CO_MODE_SG_MAX") THEN
	  #DIAG := w#16#A002;
	  RETURN;
	END_IF;
	//Auswerten auf welcher Ebene der Baustein aufgerufen wurde
	IF (#FgNr = 0) OR (#SgNr = 0) THEN
	  #DIAG := w#16#A003;
	  RETURN;
	END_IF;
	
	
	// Controlled Stop rücksetzen
	IF #RESET_CONTROLLED_STOP THEN
	  #GLOB.MODE.FG[#FgNr].IN.CONTROLLED_STOP := FALSE;
	END_IF;
	
	// Overflow_Pic auf Grundbild = 2#1 normieren
	IF (#MESS_HANDLER.OVERFLOW_PIC = 2#0) THEN
	  #MESS_HANDLER.OVERFLOW_PIC := 2#1;
	END_IF;
	
	// Stackverwaltung
	IF #RESET_CONTROLLED_STOP AND #GLOB.MODE.FG[#FgNr].OUT.REQ_CONTROLLED_STOP THEN
	  // COUNT immer erhöhen...Wert kann somit höher sein als die Stackgrösse
	  #GLOB.MODE.FG[#FgNr].IN.DIAG_CONTROLLED_STOP.COUNT := #GLOB.MODE.FG[#FgNr].IN.DIAG_CONTROLLED_STOP.COUNT + 1;
	  // Stack nur schreiben, falls noch Platz frei !
	  IF (#GLOB.MODE.FG[#FgNr].IN.DIAG_CONTROLLED_STOP.COUNT <= #GLOB.MODE.FG[#FgNr].IN.DIAG_CONTROLLED_STOP.MAX_INDEX_STACK) AND (#GLOB.MODE.FG[#FgNr].IN.DIAG_CONTROLLED_STOP.COUNT >= 0) THEN
	    
	    #GLOB.MODE.FG[#FgNr].IN.DIAG_CONTROLLED_STOP.STACK[(#GLOB.MODE.FG[#FgNr].IN.DIAG_CONTROLLED_STOP.COUNT - 1)].#INSTANCE_NAME := #INSTANCE_NAME;
	    #GLOB.MODE.FG[#FgNr].IN.DIAG_CONTROLLED_STOP.STACK[(#GLOB.MODE.FG[#FgNr].IN.DIAG_CONTROLLED_STOP.COUNT - 1)].#OVERFLOW_PIC := #MESS_HANDLER.OVERFLOW_PIC;
	  END_IF;
	END_IF;
END_FUNCTION

FUNCTION "MESS_HANDLE_READ_OPERAND_FC" : Void
TITLE = MESS_HANDLE_READ_OPERAND_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW_TUE
FAMILY : MESS
VERSION : 0.1
//Block used to input the operand in MESS_HANDLE_SINGLE_UDT
   VAR_INPUT 
      OPERAND : WString;
   END_VAR

   VAR_IN_OUT 
      MESSAGE : "MESS_HANDLE_SINGLE_UDT";
      IFACE : "MESS_HANDLE_SINGLE_IFACE_UDT";
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	Titel :             MESS_READ_OPERAND_FC
	Kommentar :         Baustein wird zum Einlesen des Operanden in die MESS_HANDLE_SINGLE_UDT verwendet
	                    
	              
	Copyright 20xx      BMW AG .....
	Ersteller :         G. Schnellbögl                   
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	Hardware- Bindung     [ ] 319F   [x] 15xx
	Aufrufumgebung        [ ] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [x] Anwender
	aufgerufene Bausteine    :                                    
	
	
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	nicht vorhanden
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version Autor             Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	
	16.07.2014  V1.33.x Schnellbögl        Ersterstellung
	01.08.2014  V1.34.x Schnellbögl        Logik Trigger Operand invertiert
	@CHANGELOG@
	*)
	IF NOT #IFACE.TRIGGER_READ_OPERAND THEN
	  #MESSAGE.#OPERAND := WSTRING_TO_STRING(#OPERAND);
	END_IF;
END_FUNCTION

FUNCTION "MODE_FG_GET_DATA_FC" : "MODE_FG_WORK_DATA_UDT"
TITLE = MODE_GET_FG_DATE_FC
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW
FAMILY : MODE
//Block retrieves the FG[x].OUT and the FG[x].IN data from the call environment and returns them. It returns an error if the block is called outside the FG level. The structure data are completely deleted.
//The bits for manual / automatic / error acknowledgment etc. are included in these structures. The signals from the FG are included in the OUT structure. Response to the FG can be sent in the IN structure.
   VAR_OUTPUT 
      DIAG : Word;   // Diagnostics word
   END_VAR

   VAR_IN_OUT 
      GLOB { S7_HiddenAssignment := 'Hide'} : "GLOB_UDT";   // Global data
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	              Titel :             MODE_GET_FG_DATE_FC     
	              Kommentar :         Baustein holt anhand der Aufrufumgebung die FG[x].OUT und die FG[x].IN Daten und gibt 
	                                  diese zurück. Sollte der Baustein außerhalb der FG Ebene aufgerufen werden, gibt er ein 
	                                  Fehler zurück. Die Strukturdaten werden komplett abgelöscht. In diesen Strukturen sind 
	                                  die Bits für Hand / Automatik / Störung quittieren usw. enthalten. In der OUT Struktur 
	                                  sind die Signale von der FG enthalten. In der IN Struktur können Rückmeldungen an 
	                                  die FG gegeben.
	
	    
	              Copyright 20xx      BMW AG .....
	              Ersteller :         Markus Breu, SAR
	              Version :           V 0.1     
	              Datum :             07.01.2013        
	              Bausteinstatus :    [ ] freigegeben :       vollständig getestet
	                                  [x] Testphase :         Programmcode erstellt, volle Funktionalität, noch keine Freigabe
	                                  [ ] Entwicklungsstand : Programmcode noch in Bearbeitung
	                                  [ ] Testmuster 
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	            Hardware- Bindung     [ ] 319F   [ ] 15xx           [x] auf 319F und 15xx lauffähig
	            Aufrufumgebung        [] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	            aufgerufene Bausteine    :   keine weiteren                                     
	
	****************************************************************************************************************************
	TODO:
	----------------------------------------------------------------------------------------------------------------------------
	
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	Binärwert           Hexwert Beschreibung
	10100000_00000001   A001    Konfigurationsfehler FG Nummer falsch
	10100000_00000010   A002    Konfigurationsfehler SG Nummer falsch
	    
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version    Autor        Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	07.01.2013  V0.1      Breu          Grundversion
	24.07.2013  V0.2      Breu          Dokumentation
	11.03.2015  V1.34.x  Schnellbögl    Umstellung auf globale Konstanten  CO_MODE_FG_MAX, CO_MODE_SG_MAX 
	
	@CHANGELOG@
	*)
	
	//
	#MODE_FG_GET_DATA_FC.DIAG:= 0;
	
	//Aktuelle FG Nummer auslesen
	#MODE_FG_GET_DATA_FC.FG_NR := #GLOB.MODE.RECENT_FG;
	//Aktuelle SG Nummer auslesen
	#MODE_FG_GET_DATA_FC.SG_NR := #GLOB.MODE.RECENT_SG;
	
	
	IF (#MODE_FG_GET_DATA_FC.FG_NR <= 0) OR (#MODE_FG_GET_DATA_FC.FG_NR > "CO_MODE_FG_MAX") THEN
	  #MODE_FG_GET_DATA_FC.DIAG:= w#16#A001;
	END_IF;
	IF (#MODE_FG_GET_DATA_FC.SG_NR <= 0) OR (#MODE_FG_GET_DATA_FC.SG_NR > "CO_MODE_SG_MAX") THEN
	  #MODE_FG_GET_DATA_FC.DIAG:= w#16#A002;
	END_IF;
	
	IF #MODE_FG_GET_DATA_FC.DIAG = 0 THEN
	  //Bits aus dem Mode DB umrangieren
	  #MODE_FG_GET_DATA_FC.OUT :=#GLOB.MODE.FG[#MODE_FG_GET_DATA_FC.FG_NR].OUT;
	  #MODE_FG_GET_DATA_FC.IN :=#GLOB.MODE.FG[#MODE_FG_GET_DATA_FC.FG_NR].IN;
	
	END_IF;
	
	//Diagnosewort ausgeben
	#DIAG := #MODE_FG_GET_DATA_FC.DIAG;
	
END_FUNCTION

FUNCTION_BLOCK "TYPE_DELETE_FB"
TITLE = TYPE_DELETE_FB
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW
FAMILY : 'TYPE'
VERSION : 0.1
//This block is used to delete an existing reference to a data place in the "TYPE_DATA_DB" data block in order to release the place.
   VAR_OUTPUT 
      DIAG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Diagnostics information
   END_VAR

   VAR_IN_OUT 
      UNIT : "TYPE_REF_UDT";   // Data record reference
      SEQ : "TYPE_DELETE_SEQ_UDT";   // Sequence interface
      GLOB_DB { S7_PredefinedAssignment := '"GLOB_DB"'; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : "GLOB_UDT";   // Global data
      TYPE_GLOB_DB { S7_PredefinedAssignment := '"TYPE_GLOB_DB"'; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : "TYPE_GLOB_UDT";   // Type global data
      TYPE_DATA_CTRL_DB { S7_PredefinedAssignment := '"TYPE_DATA_CTRL_DB"'; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : "TYPE_DATA_CTRL_UDT";   // Check data
   END_VAR

   VAR 
      EP_Delete { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      PP_Delete { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR


BEGIN
	
	(**************************************************************************************************************************
	 
	Titel :             TYP_DELETE_FB
	Kommentar :         Dieser Baustein dient dazu eine bestehende Referenz auf ein Datenfach im Datenbaustein „TYPE_DATA_DB“  zu löschen, um damit das Fach wieder frei zu geben.
	    
	Copyright 20xx      BMW AG .....
	Ersteller :         TP-246 Senger 
	
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	
	Hardware- Bindung     [x] 15xx
	Aufrufumgebung        [x] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [ ].....
	
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	Hexwert Beschreibung
	abxx    a = A, C oder ID  b = Störklasse (ID)  xx = Meldenummer
	
	0001    keine zu löschenden Daten vorhanden
	    
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version Autor         Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	10.07.2012          Senger        Ersterstellung
	29.03.2013          Senger        Umstellung für Typen auf Globaldaten
	09.10.2013  V1.3.x  Senger        Anpassung Kopf
	27.11.2013  V1.4.x  Senger        Umstellung Typverwaltung auf neue Funktionen
	10.11.2014  V1.34.x Senger        Data_exist_online wird nun auch gelöscht
	11.06.2015  V1.35.x Senger        Typenummer mit ablöschen
	@CHANGELOG@
	*)
	
	//***************************************************************************************************************************
	//     Initialisierung
	//***************************************************************************************************************************
	#DIAG := w#16#0;
	//***************************************************************************************************************************
	//     Flanke Referenz löschen
	//***************************************************************************************************************************
	#PP_Delete := #SEQ.DELETE AND NOT #EP_Delete;
	#EP_Delete := #SEQ.DELETE;
	
	//***************************************************************************************************************************
	//     nächsten freien Platz suchen
	//***************************************************************************************************************************
	IF #PP_Delete THEN
	  IF #UNIT.REFERENZ > 0 THEN
	    #TYPE_DATA_CTRL_DB.DATA[#UNIT.REFERENZ].DATA_EXIST := FALSE;
	    #TYPE_DATA_CTRL_DB.DATA[#UNIT.REFERENZ].DATA_EXIST_ONLINE := FALSE;
	    #TYPE_DATA_CTRL_DB.DATA[#UNIT.REFERENZ].DELETE := FALSE;
	    #TYPE_DATA_CTRL_DB.DATA[#UNIT.REFERENZ].TYPE_NR := 0;
	    #UNIT.REFERENZ := 0;
	    #UNIT.RESTORE := FALSE;
	  ELSE
	    #DIAG:=w#16#0001;
	  END_IF;     
	END_IF;
	
	
END_FUNCTION_BLOCK

TYPE "DRV_REMOTE_SEQ_UDT"
VERSION : 0.1
   STRUCT
      IN : Struct   // Input information from DRV
         COMMAND_EXTERNAL : Bool;   // Actuation from external
         FAULT : Bool;   // Error
         WARNING : Bool;   // Warning/message
         POSITION_DEV : Byte;   // X0=RETRACT/X1=ADVANCE/X2=CENTER/X3......etc. (Position)
         STATUS : Byte;   // O_X0=MOTOR_TURNING//X1=MOTOR_F2(FAST)/X2......etc. (position)
         REGISTER_SHEET : "HMI_REGISTER_SHEET_UDT";   // HMI register
         HMI_BUTTON_SLOW_SELECTED : Bool;   // DEV speed low button selected
         HMI_BUTTON_DEV_RET : Bool;   // DEV retract button [RETRACT / DOWN / BOTTOM / LEFT]
         HMI_BUTTON_DEV_CEN : Bool;   // DEV center/middle button
         HMI_BUTTON_DEV_ADV : Bool;   // DEV advance button [ADVANCE / UP / TOP / RIGHT]
         HMI_BUTTON_DEV_LOADING : Bool;   // Load/retract DEV button
         HMI_BUTTON_DEV_UNLOADING : Bool;   // Unload/extend DEV button
      END_STRUCT;
      OUT : Struct   // Output information to DRV
         COMMAND_EXTERNAL : Bool;   // Actuation from external
         COMMAND_RESET : Bool;   // Reset error
         COMMAND_F1_F2 : Bool;   // Inverter speed f1/f2
         COMMAND : Byte;   // X0=RETRACT/X1=ADVANCE/X2=CENTER/X3=LOADING/X4=UNLOADING/X5=DEV_SELECTED.....etc. (Command)
         POSITION : Byte;   // X0=RETRACT/X1=ADVANCE/X2=CENTER/X3......etc. (Position)
         INTERLOCK : Byte := 16#FF;   // X0=RETRACT/X1=ADVANCE/X2=CENTER/X3......etc. (feasibility)
         REMOTE_MODE : Word;   // X0=All errors off/X1=All errors on/X2=Only device errors/X3=Position from device......etc. (Mode)
         HMI_BUTTON_SLOW_SELECTED : Bool;   // DEV speed low button selected
         HMI_CONF_BUTTON_DEV_SLOW : Bool;   // Configuration button DEV speed low
         HMI_CONF_BUTTON_DEV_RET : Bool;   // Configuration button DEV retract [RET / DOWN / BOTTOM / LEFT]
         HMI_CONF_BUTTON_DEV_CEN : Bool;   // Configuration button DEV center/middle
         HMI_CONF_BUTTON_DEV_ADV : Bool;   // Configuration button DEV advance [ADVANCE / UP / TOP / RIGHT]
         HMI_CONF_BUTTON_DEV_LOADING : Bool;   // Configuration button DEV load/retract
         HMI_CONF_BUTTON_DEV_UNLOADING : Bool;   // Configuration button DEV unload/extend
      END_STRUCT;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "MESS_HANDLE_SINGLE_FB"
TITLE = MESS_HANDLE_SINGLE_FB
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : BMW_TUE
FAMILY : MESS
VERSION : 0.1
//MESS_HANDLE_SINGLE_FC and MESS_HANDLE_SINGLE_FB are a fixed unit
//MESS_HANDLE_SINGLE_FC: Triggers entry and removal of fault messages into/from the active register.
//MESS_HANDLE_SINGLE_FB: Executes entry and removal of fault messages into/from the active register.
//Additionally, a check is performed whether duplicate instances have been called, and whether rapid state changes of messages are occurring!
//The block also manipulates the operating mode!
   VAR_OUTPUT 
      DIAG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
   END_VAR

   VAR_IN_OUT 
      MESS_HANDLER : "MESS_HANDLE_SINGLE_UDT";
      CONF : "MESS_HANDLE_SINGLE_CONF_UDT";   // Configuration parameters:  stat. variable range in block to be called
      GLOB { S7_PredefinedAssignment := '"GLOB_DB"'; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : "GLOB_UDT";
   END_VAR

   VAR 
      GetMessListGlob { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_GET_LIST_FB";
      GetMessListLabel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_GET_LIST_FB";
      IFACE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_HANDLE_SINGLE_IFACE_UDT";
      MessHandleData { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_HANDLE_SINGLE_UDT";
      Coming_DT {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;
      Going_DT {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DTL;
      LocalCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      CycleId { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ErrorDoubleUse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      HM_ErrorDoubleUse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ReqErrorDoubleUse { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ErrorDoubleUseCollect { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      TextNrLastCycle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      EdgeTextNrChange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      LastTextNr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      FlickerCount { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      FlickerMessageExist { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      FlickerMessageSent { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      T_Flicker {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TOF_TIME;
   END_VAR

   VAR_TEMP 
      SgNr : Int;
      FgNr : Int;
      CO_SizeActReg : Int;
      ActiveWritePointer : Int;
      Index : Int;
      MaxActivityReached : Bool;
      line : "MESS_REGLINE_UDT";
      LevelName : String[20];
      RetVal : Word;
      MessHandleInit : "MESS_HANDLE_SINGLE_UDT";
      InitFb : Bool;
      ErrorLocalCount : Bool;
      ErrorCycleIdOld : Bool;
      ErrorCycleIdRecent : Bool;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	Titel :             MESS_HANDLE_SINGLE_FB
	Kommentar :         MESS_HANDLE_SINGLE_FC und MESS_HANDLE_SINGLE_FB bilden eine feste Einheit
	                    MESS_HANDLE_SINGLE_FC : Triggert das Ein- und Austragen der Störmeldungen ins /aus dem Aktiv Register.
	                    MESS_HANDLE_SINGLE_FB : Führt das Ein- und Austragen der Störmeldungen ins /aus dem Aktiv Register aus.
	                    zusätzlich wird noch überprüft, ob Instanzen doppelt aufgerufen werden, oder ob Meldungen flackern !
	                    Der Baustein führt auch die Betriebsartenbeeinflussung durch !
	              
	Copyright 20xx      BMW AG .....
	Ersteller :         G. Schnellbögl                   
	           
	****************************************************************************************************************************
	 BAUSTEINBESCHREIBUNG
	 
	Hardware- Bindung     [ ] 319F   [x] 15xx
	Aufrufumgebung        [ ] zyklisch    [ ] Anlauf  [ ] Zeitalarm     [x] Anwender
	aufgerufene Bausteine    :                                    
	
	  TODO  :        
	
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	   
	A001  Laufzeitfehler FG Nummer falsch
	A002  Laufzeitfehler SG Nummer falsch
	A003  Laufzeitfehler keine gültige Referenz auf Text DB
	A004  Laufzeitfehler keine gültiger Schreibzeiger für Aktivregister
	A005  Laufzeitfehler keine gültiger Indexzeiger für Aktivregister
	A006  Maximale Anzahl von Aktivitäten für diesen Zyklus erreicht
	A007  Initalisierung vom Meldesystem aktiv
	A008  Keine Meldung absetzen von MODE Struktur angewählt
	A009  Mehrfache Verwendung der gleichen Multiinstanz erkannt.
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version Autor             Beschreibung
	----------------------------------------------------------------------------------------------------------------------------
	
	03.07.2014  V1.33.x Schnellbögl        Ersterstellung
	04.09.2014  V1.34.x Schnellbögl        Rangierung der Label ID als dritte Liste !
	29.10.2014  V1.35.x Breu               Erfassung aktiver Störmeldungen
	08.12.2014  V1.36.x Schnellbögl        Aktivierung des IPST_Send bits
	02.01.2015  V1.37.x Schnellbögl        Optimierung Fehlerauswertungen ... 
	                                       (u.a. :ErrorDoubleUse wird nur mehr bausteinbezogen behandelt, kein Soforthalt PLC mehr)
	13.02.2015  V1.38.x Breu / Schnellbögl Bugfix: Beim einspielen der Instanz und aktiver Störmeldung bereingiung des 
	                                       Aktivregisters angestossen                                       
	27.02.2015  V1.39.x Schnellbögl        Anpassung für internen Aufruf  LOCATION wird zusammengesetzt !                                    
	11.03.2015  V1.40.x Schnellbögl        Umstellung auf globale Konstanten  CO_MODE_FG_MAX, CO_MODE_SG_MAX 
	24.09.2015  V1.41.x Schnellbögl        Bugfix : Bildung Location bei internem MessHandle Aufruf
	                                                Meldung Flackert schaltet wieder auf normale Meldung um, wenn sie stabil ansteht
	30.09.2016  V1.42.x Schnellbögl        Integration MESS_PERI_NOT_READY  : diese Meldung wird beim Eintrag ins Aktivregister als MESSAGE umdeklariert, da die HMI Filter noch fehlen
	02.11.2016  V1.43.x Schnellbögl        Trigger für neue Meldung jetzt auch über Änderung der ERROR_CLASS 
	03.08.2017  V1.44.x Schnellbögl        Meldung flackert nur generieren bei immer gleicher Fehlernummer
	16.03.2020  V1.45.x Schnellbögl        Anpassungen für Fehlernummern bis 65000
	@CHANGELOG@
	*)
	
	//**************************************************************************************************************************
	// Konstantendeklarationen
	//**************************************************************************************************************************
	//"CO_MODE_FG_MAX"  wird direkt verwendet
	//"CO_MODE_SG_MAX"  wird direkt verwendet
	#CO_SizeActReg := #GLOB.MESS.ACTIVE.MAX_SIZE;
	
	//*************************************************************************************************************************************
	//                                  Fehlerebene ermitteln                ( SG Ebene  : FG = 0 !)
	//                                                                       ( PLC Ebene : SG = 0, Fg = 0)        
	//*************************************************************************************************************************************
	#SgNr := #GLOB.MODE.RECENT_SG;
	#FgNr := #GLOB.MODE.RECENT_FG;
	
	//**************************************************************************************************************************
	// Meldeliste ermitteln
	//**************************************************************************************************************************
	#GetMessListGlob(FAMILY := 'GLOB',
	                 GLOB := #GLOB);
	#GetMessListLabel(FAMILY := 'LABEL',
	                  GLOB := #GLOB);
	
	
	//***************************************************************************************************************************
	//     DIAGNOSE   : Parametrierfehler
	//***************************************************************************************************************************
	
	// ***************************      einige Fehler werden vom MESS_HANDLE_SINGLE_FC generiert      ***************************
	#DIAG := #IFACE.DIAG;
	// danach keine weitere Bearbeitung notwendig
	IF (#DIAG >= w#16#A001) AND (#DIAG <= w#16#A005) THEN
	    RETURN;
	END_IF;
	
	
	//**************************************************************************************************************************
	//Prüfungen
	//**************************************************************************************************************************
	
	// Erster Durchlauf des Bausteins
	IF #LocalCount = 0 THEN
	    // Initalisierung des Bausteins
	    #InitFb := TRUE;
	    //Bereinigung Aktivregister anstossen
	    #GLOB.MESS.ACTIVE.COUNT_CHANGE := TRUE;
	END_IF;
	
	// ErrorLocalCount 
	IF NOT #InitFb AND (#LocalCount <> #GLOB.MESS.ACTIVE.COUNT_MESS_HANDLER + 1) THEN
	    #ErrorLocalCount := true;
	    
	END_IF;
	
	// ErrorCycleID Recent    
	IF NOT #InitFb AND (#CycleId = #GLOB.MESS.ACTIVE.CYCLE_ID) THEN
	    #ErrorCycleIdRecent := true;
	END_IF;
	
	// ErrorCycleID Old    
	IF NOT #InitFb AND NOT #ErrorCycleIdRecent AND (#CycleId <> (#GLOB.MESS.ACTIVE.CYCLE_ID - 1)) THEN
	    #ErrorCycleIdOld := true;
	END_IF;
	
	//**************************************************************************************************************************
	// Speichern der Cyle ID
	#CycleId := #GLOB.MESS.ACTIVE.CYCLE_ID;
	
	//**************************************************************************************************************************
	// Fehler :  eigener Baustein wird mehrmals aufgerufen ( doppelte Instanzen )
	// falls es nicht mehr der erste Aufruf ist, wird der Baustein nicht weiter bearbeitet !
	//**************************************************************************************************************************
	#ErrorDoubleUse := #ErrorDoubleUseCollect; // Sammelsignal aus letztem Zyklus
	
	#ErrorDoubleUseCollect := NOT #InitFb AND #ErrorCycleIdRecent AND NOT #GLOB.MESS.ACTIVE.INIT;
	IF #ErrorDoubleUseCollect THEN
	    #DIAG := w#16#A009;
	    RETURN;
	END_IF;
	
	//**************************************************************************************************************************
	// hier geht's nur weiter, wenn es sich nicht um mehrfache Aufrufe von Instanzen handelt !!!
	//************************************************************************************************************************** 
	
	//**************************************************************************************************************************
	// Anzahl der Messhandler die in der PLC aufgerufen sind ermitteln
	// Es wird der aktuelle Zahlenwert für diese Instanz auch local gespeichert
	//**************************************************************************************************************************
	
	#GLOB.MESS.ACTIVE.COUNT_MESS_HANDLER := #GLOB.MESS.ACTIVE.COUNT_MESS_HANDLER + 1;
	
	//Speichern des Zählwertes in der Localen Instanz
	#LocalCount := #GLOB.MESS.ACTIVE.COUNT_MESS_HANDLER;
	
	//**************************************************************************************************************************
	// Normalbetrieb : Aktualisierung der CYCLE ID in aktiven Meldungen 
	//**************************************************************************************************************************  
	// Normalbetrieb, kein Fehler  oder ErrorDoubleUse  und Meldung ist gespeichert 
	IF NOT #InitFb AND NOT #ErrorCycleIdOld
	    AND (#IFACE.RECENT_MESSAGE_PTR > 0) AND (#IFACE.RECENT_MESSAGE_PTR <= #CO_SizeActReg) THEN
	    #GLOB.MESS.ACTIVE.LINE[#IFACE.RECENT_MESSAGE_PTR].CYCLE_ID := #GLOB.MESS.ACTIVE.CYCLE_ID;
	END_IF;
	
	
	//**************************************************************************************************************************
	// Fehler :  irgendein Baustein wurde ausgehängt ( oder auch vorher neue hinzugefügt )
	// aber im eigenen Baustein fehlt nichts
	//**************************************************************************************************************************  
	IF NOT #InitFb AND #ErrorLocalCount AND NOT #ErrorCycleIdOld AND NOT #ErrorCycleIdRecent AND NOT #ErrorDoubleUse THEN
	    // das Bit steuert den REG_ORG_FB : Putzen aller nicht mehr aktuellen aktiven Meldungen
	    #GLOB.MESS.ACTIVE.COUNT_CHANGE := TRUE;
	END_IF;
	
	
	//**************************************************************************************************************************
	//Fehler :  eigener Baustein war ausgehängt und kommt wieder dazu
	//**************************************************************************************************************************  
	IF NOT #InitFb AND #ErrorCycleIdOld THEN
	    // Meldung neu absetzen denn vorher wurde sie schon durch über REG_ORG_FB rausgeputzt 
	    //sollte über RECENT_MESSAGE_PTR auf Null setzen gelöst werden können !
	    #IFACE.RECENT_MESSAGE_PTR := 0;
	END_IF;
	
	//**************************************************************************************************************************
	// Auswahl der Liste für die diese Störung abgesetzt werden soll. Wird die Instanz doppelt verwendet
	// muss sichergestellt werden dass nur die eine Meldung abgesetzt wird
	//**************************************************************************************************************************
	IF #ErrorDoubleUse THEN
	    // Struktur sauber initialisieren
	    #MessHandleData := #MessHandleInit;
	    #MessHandleData.LIST_PTR[0].NR := 111;
	    #MessHandleData.LIST_PTR[0].DB := #GetMessListGlob.REF_DB;
	    #MessHandleData.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	    #MessHandleData.IPST_PRIO := 'T';
	    #MessHandleData.FIRST_UP_FAULT := true;
	    
	    //----------------------------------------------------------------------------------------------------------------------------
	    //Text für die Ebene zusammenbauen
	    //----------------------------------------------------------------------------------------------------------------------------
	    IF #SgNr = 0 AND #FgNr = 0 THEN
	        #LevelName := 'Level: PLC';
	    ELSIF #SgNr <> 0 AND #FgNr = 0 THEN
	        #RetVal := "TOOL_DINT_TO_STRING_FC"(IN := #SgNr, MODE := 0, MIN_LEN := 2, FILL_CHAR := '0', OUT => #LevelName);
	        #LevelName := CONCAT(IN1 := 'Level: SG', IN2 := #LevelName);
	    ELSE
	        #RetVal := "TOOL_DINT_TO_STRING_FC"(IN := #FgNr, MODE := 0, MIN_LEN := 2, FILL_CHAR := '0', OUT => #LevelName);
	        #LevelName := CONCAT(IN1 := 'Level: FG', IN2 := #LevelName);
	    END_IF;
	    
	    //Diagnosewort Fehlercode
	    #DIAG := w#16#a009;
	END_IF;
	
	// Impuls bilden für Meldung ErrorDoubleUse : einen Zyklus verzögern, damit der Header eingelesen werden kann !
	IF #ErrorDoubleUse AND #IFACE.ERROR_DOUBLE_USE AND NOT #HM_ErrorDoubleUse THEN
	    #ReqErrorDoubleUse := true;
	END_IF;
	#HM_ErrorDoubleUse := #ErrorDoubleUse AND #IFACE.ERROR_DOUBLE_USE;
	// den FC triggern zum Einlesen des Headers
	#IFACE.ERROR_DOUBLE_USE := #ErrorDoubleUse;
	
	
	//**************************************************************************************************************************
	// interne Variablen beschreiben
	//**************************************************************************************************************************
	
	#ActiveWritePointer := #GLOB.MESS.ACTIVE.PTR_IN;
	
	#Index := #GLOB.MESS.ACTIVE.LINE_INDEX[#ActiveWritePointer];
	
	
	//**************************************************************************************************************************
	// Rücksetzbedingung Erkennung Meldung flackert
	//**************************************************************************************************************************
	IF NOT #T_Flicker.Q OR #GLOB.MESS.ACTIVE.INIT THEN
	    //Wenn die Meldung wieder Stabil ansteht, wird die Meldung nochmal 
	    //neu gehend und kommend gemeldet, dmit sie wieder mit dem normalen Text im Störstack
	    //dies erfolgt dadurch, dass während des erkannten Zustandes FB_READY rückgesetzt wird !
	    
	    //Rücksetzen der Hilfsvariablen zum Erkennen von flackernden Meldungen
	    #FlickerCount := 0;
	    #FlickerMessageExist := FALSE;
	    IF #FlickerMessageSent THEN
	        #FlickerMessageSent := FALSE;
	        // Falls die Meldung noch ansteht wird ein GEHEND Anstoss generiert
	        // Ist dieser ausgeführt, wird automatisch über den Fall "Neue KOMMEND Meldung puffern" (MESS_HANDLE_SINGLE_FC) eine neue Meldung gesendet
	        IF (#MESS_HANDLER.LIST_PTR[0].NR > 0) AND (#IFACE.RECENT_MESSAGE_NR_SENT > 0) AND
	            (#IFACE.RECENT_MESSAGE_PTR > 0) AND NOT #ErrorDoubleUse AND NOT #GLOB.MESS.ACTIVE.INIT AND NOT #IFACE.MESSAGE_GOING_BUFFERED THEN
	            #IFACE.BUFFER_MESSAGE_GOING := TRUE;
	        END_IF;
	    END_IF;
	    //#FlickerMessageComming := false;
	END_IF;
	
	//**************************************************************************************************************************
	// Dem MESS_HANDLE_SINGLE_FC mitteilen, ob man bereit ist,
	// wenn nicht, dann unter Umständen IFACE initialisieren
	//**************************************************************************************************************************
	#IFACE.FB_READY := NOT #ErrorDoubleUse AND NOT #GLOB.MESS.ACTIVE.INIT AND NOT #FlickerMessageSent;
	
	IF #GLOB.MESS.ACTIVE.INIT THEN
	    #IFACE.MESSAGE_COMING_BUFFERED := FALSE;
	    #IFACE.MESSAGE_GOING_BUFFERED := FALSE;
	    #IFACE.RECENT_MESSAGE_NR_SENT := 0;
	    #IFACE.RECENT_ERROR_CLASS_SENT := 0;
	    #IFACE.RECENT_MESSAGE_PTR := 0;
	END_IF;
	
	IF NOT #IFACE.FB_READY THEN
	    #IFACE.BUFFER_MESSAGE_COMING := FALSE;
	    #IFACE.SEND_STORED_MESSAGE_COMING := FALSE;
	    #IFACE.BUFFER_MESSAGE_GOING := FALSE;
	    #IFACE.SEND_MESSAGE_GOING := FALSE;
	END_IF;
	// in diesem Zustand ist der FC quasi abgekoppelt, der FB kann sich selber steuern !
	
	
	//**************************************************************************************************************************
	// Meldung ErrorDoubleUse   :       !!!!!           FB steuert das Meldung absetzen ohne den FC    !!!!!!!
	//**************************************************************************************************************************
	// die Meldung ErrorDoubleUse hat höchste Priorität, steht aber eine Meldung an, so muss diese erst als Gehend gemeldet werden !
	
	#MaxActivityReached := #GLOB.MESS.ACTIVE.CUR_ACTIVE >= #GLOB.MESS.ACTIVE.MAX_ACTIVE;
	IF #ReqErrorDoubleUse AND NOT #MaxActivityReached THEN
	    // Falls eine Meldung ansteht, diese als Gehend senden !
	    IF (#IFACE.RECENT_MESSAGE_PTR > 0) THEN
	        #IFACE.MESSAGE_GOING_BUFFERED := TRUE;
	        #IFACE.SEND_MESSAGE_GOING := TRUE;
	        // Meldung speichern  : exakter GEHEND Zeit
	        #Going_DT := #GLOB.SYS."TIME".LOCAL;
	    ELSE
	        #ReqErrorDoubleUse := FALSE;
	        // Daten wurden schon vorher in die Struktur geschrieben
	        #IFACE.MESSAGE_COMING_BUFFERED := TRUE;
	        #IFACE.SEND_STORED_MESSAGE_COMING := TRUE;
	        // Meldung speichern  inkl exakter KOMMEND Zeit
	        #Coming_DT := #GLOB.SYS."TIME".LOCAL;
	    END_IF;
	END_IF;
	
	//**************************************************************************************************************************
	// Backup KOMMEND Meldung
	//**************************************************************************************************************************
	//wird genau eine Zyklus lang ausgeführt
	IF #IFACE.BUFFER_MESSAGE_COMING THEN
	    //Handshakebits aktualisieren
	    #IFACE.BUFFER_MESSAGE_COMING := FALSE;
	    #IFACE.MESSAGE_COMING_BUFFERED := TRUE;
	    // Meldung speichern  inkl exakter KOMMEND Zeit
	    #MessHandleData := #MESS_HANDLER;
	    #Coming_DT := #GLOB.SYS."TIME".LOCAL;
	END_IF;
	
	//**************************************************************************************************************************
	// KOMMEND Meldung ins Aktivregister eintragen
	//**************************************************************************************************************************
	
	// Prüfen Meldung flackert, bzw. kommt zu häufg
	
	//Trigger für neue Meldung
	#EdgeTextNrChange := (#MESS_HANDLER.LIST_PTR[0].NR > 0) AND (#MESS_HANDLER.LIST_PTR[0].NR <> #TextNrLastCycle) AND (#MESS_HANDLER.LIST_PTR[0].NR = #LastTextNr);
	#TextNrLastCycle := #MESS_HANDLER.LIST_PTR[0].NR;
	// letzte gesendete Meldenummer
	IF #MESS_HANDLER.LIST_PTR[0].NR > 0 THEN
	    #LastTextNr := #MESS_HANDLER.LIST_PTR[0].NR;
	END_IF;
	
	//Ausschaltverzögerung Letzte Änderung der Störung
	#T_Flicker(IN := #EdgeTextNrChange,
	           PT := #CONF.FLICKER_TIME_SPAN);
	
	IF #EdgeTextNrChange AND NOT #FlickerMessageExist THEN
	    #FlickerCount := #FlickerCount + 1;
	    IF #FlickerCount > #CONF.FLICKER_MAX_COUNT THEN
	        #FlickerMessageExist := true;
	    END_IF;
	END_IF;
	
	//wird genau eine Zyklus lang ausgeführt
	IF #IFACE.SEND_STORED_MESSAGE_COMING AND #IFACE.MESSAGE_COMING_BUFFERED THEN
	    
	    //Handshakebits aktualisieren
	    #IFACE.SEND_STORED_MESSAGE_COMING := FALSE;
	    #IFACE.MESSAGE_COMING_BUFFERED := FALSE;
	    // Anzahl Aktivitäten erhöhen
	    #GLOB.MESS.ACTIVE.CUR_ACTIVE := #GLOB.MESS.ACTIVE.CUR_ACTIVE + 1;
	    // BlockName für CodeViewer eintragen
	    #line.INSTANCENAME := #GLOB.MODE.PLC.INTERNAL.INSTANCENAME;
	    // Zeiger merken und auf nächsten freien Registerplatz setzen       
	    #IFACE.RECENT_MESSAGE_PTR := #Index;
	    #GLOB.MESS.ACTIVE.PTR_IN := #GLOB.MESS.ACTIVE.PTR_IN + 1;
	    //Gesendete Nr merken
	    #IFACE.RECENT_MESSAGE_NR_SENT := #MessHandleData.LIST_PTR[0].NR;
	    //Gesendete Error Class merken
	    #IFACE.RECENT_ERROR_CLASS_SENT := #MessHandleData.ERROR_CLASS;
	    
	    // Meldung ins Aktivregister eintragen
	    
	    #line.SG := #SgNr;
	    #line.FG := #FgNr;
	    #line.APP_TIME := #Coming_DT;
	    #line.APP_FLAG := TRUE;
	    #line.DISAPP_FLAG := FALSE;
	    
	    #line.MESS.ITEM := #MessHandleData.LIST_PTR;
	    //Eintrag der Labellist Infos   :
	    IF (DB_ANY_TO_UINT(#CONF.LABEL_DB) > 0) THEN
	        #line.MESS.ITEM[2].DB := #CONF.LABEL_DB;
	    ELSE
	        #line.MESS.ITEM[2].DB := #GetMessListLabel.REF_DB;
	    END_IF;
	    #line.MESS.ITEM[2].NR := #CONF.LABEL_ID;
	    #line.ERROR_CLASS := #MessHandleData.ERROR_CLASS;
	    // Umschreiben MESS_PERI_NOT_READY in normale Message :  Übergangslösung, bis im HMI die Filter angepasst sind ! 
	    IF #MessHandleData.ERROR_CLASS = #GLOB.SYS.CONST.MESS.MESSAGE_PERI_NOT_READY THEN
	      #line.ERROR_CLASS := #GLOB.SYS.CONST.MESS.MESSAGE;
	    END_IF;
	    #line.IPST_PRIO := #MessHandleData.IPST_PRIO;
	    #line.IPST_SEND := #MessHandleData.IPST_SEND;
	    #line.OPERAND := #MessHandleData.OPERAND;
	    #line.PAGING := #MessHandleData.PAGING;
	    #line.CODE_VIEWER := #MessHandleData.CODE_VIEWER;
	    #line.EPLAN_VIEWER := #MessHandleData.EPLAN_VIEWER;
	    #line.PN_DEVICE := #MessHandleData.PN_DEVICE;
	    #line.OVERFLOW_PIC := #MessHandleData.OVERFLOW_PIC;
	    #line.FIRST_UP_FAULT := #MessHandleData.FIRST_UP_FAULT;
	    
	    #line.ASSOCIATED_TEXT := #CONF.ASSOCIATED_TEXT;
	    #line.ASSOCIATED_NR := #CONF.ASSOCIATED_NR;
	    
	    // über Trigger eingelesener Header
	    #line.TYPE := #MESS_HANDLER.HEADER.TYPE;
	    #line.LOCATION := #MESS_HANDLER.HEADER.LOCATION;
	    
	    // wenn es ein interner Aufruf ist, müssen diese Variablen genommen werden !
	    IF LEN(#GLOB.MODE.PLC.INTERNAL.MESS_HANDLE_HEADER.LOCATION) > 0 THEN
	        #line.LOCATION := CONCAT(IN1 := #GLOB.MODE.PLC.INTERNAL.MESS_HANDLE_HEADER.LOCATION, IN2 := '.');
	        #line.LOCATION := CONCAT(IN1 := #line.LOCATION, IN2 := #MESS_HANDLER.HEADER.LOCATION);
	    END_IF;
	    
	    //Handelt es sich um eine Flackernde Meldung wird die 2. Meldeliste zum Anhängen dieser information verwendet
	    IF #FlickerMessageExist THEN
	        #FlickerMessageSent := TRUE;
	        #line.MESS.ITEM[1].DB := #GetMessListGlob.REF_DB;
	        #line.MESS.ITEM[1].NR := 110;
	    END_IF;
	    
	    // CYCLE_ID eintragen
	    #line.CYCLE_ID := #GLOB.MESS.ACTIVE.CYCLE_ID;
	    
	    //Zeile im Register DB abspeichern
	    #GLOB.MESS.ACTIVE.LINE[#Index] := #line;
	END_IF;
	
	//**************************************************************************************************************************
	// Backup GEHEND Meldung
	//**************************************************************************************************************************
	//wird genau eine Zyklus lang ausgeführt
	IF #IFACE.BUFFER_MESSAGE_GOING THEN
	    //Handshakebits aktualisieren
	    #IFACE.BUFFER_MESSAGE_GOING := FALSE;
	    #IFACE.MESSAGE_GOING_BUFFERED := TRUE;
	    // Meldung speichern  : exakter GEHEND Zeit
	    #Going_DT := #GLOB.SYS."TIME".LOCAL;
	END_IF;
	
	//**************************************************************************************************************************
	// GEHEND Meldung im Aktivregister als gehend markieren
	//**************************************************************************************************************************
	//wird genau eine Zyklus lang ausgeführt
	IF #IFACE.SEND_MESSAGE_GOING AND #IFACE.MESSAGE_GOING_BUFFERED THEN
	    //Handshakebits aktualisieren
	    #IFACE.SEND_MESSAGE_GOING := FALSE;
	    #IFACE.MESSAGE_GOING_BUFFERED := FALSE;
	    // Anzahl Aktivitäten erhöhen
	    #GLOB.MESS.ACTIVE.CUR_ACTIVE := #GLOB.MESS.ACTIVE.CUR_ACTIVE + 1;
	    //bei gültigem Zeiger die Zeile markieren
	    IF (#IFACE.RECENT_MESSAGE_PTR > 0) AND (#IFACE.RECENT_MESSAGE_PTR <= #CO_SizeActReg) THEN
	        #GLOB.MESS.ACTIVE.LINE[#IFACE.RECENT_MESSAGE_PTR].DISAPP_FLAG := TRUE;
	        #GLOB.MESS.ACTIVE.LINE[#IFACE.RECENT_MESSAGE_PTR].DISAPP_TIME := #Going_DT;
	    END_IF;
	    // Zeiger rücksetzen
	    #IFACE.RECENT_MESSAGE_PTR := 0;
	    //Gesendete Nr löschen
	    #IFACE.RECENT_MESSAGE_NR_SENT := 0;
	    //Gesendete Error Class löschen
	    #IFACE.RECENT_ERROR_CLASS_SENT := 0;
	END_IF;
	
	
	//**************************************************************************************************************************
	// Zählen einer aktiven Meldung
	//**************************************************************************************************************************
	IF #IFACE.RECENT_MESSAGE_PTR > 0 AND #MessHandleData.IPST_SEND THEN
	    #GLOB.MESS.ACTIVE.COUNT_ACTIVE_MESSAGES := #GLOB.MESS.ACTIVE.COUNT_ACTIVE_MESSAGES + 1;
	END_IF;
	
	
	//**************************************************************************************************************************
	// Fehlerreaktion
	//**************************************************************************************************************************  
	"MODE_SET_ERROR_LEVEL_REV2_FC"(MESS_HANDLER := #MESS_HANDLER,
	                               GLOB := #GLOB);
	
END_FUNCTION_BLOCK

TYPE "CVFL_FLXXX_CONF_UDT"
VERSION : 0.1
   STRUCT
      TIME_CHANGE_POSITION { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#40S;   // Runtime (not monitored if = 0)
      TIME_CHANGE_POSITION_MIN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#0S;   // Minimum runtime (not monitored if = 0)
      TIME_FOLLOW_UP_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#0MS;   // Overrun time RET (none if = 0)
      TIME_FOLLOW_UP_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#0MS;   // Overrun time ADV (none if = 0)
      TIME_POS_CONTROLL_PROXI_POS_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#10s;   // Position monitoring RET        [RET / DOWN/ BOTTOM / LEFT] final position retract
      TIME_POS_CONTROLL_PROXI_FS_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#10s;   // Position monitoring RET_FS [RET / DOWN/ BOTTOM / LEFT] change-over V2/V1 retract
      TIME_POS_CONTROLL_PROXI_FS_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#10s;   // Position monitoring ADV_FS [ADV / UP / TOP / RIGHT] change-over V2/V1 advance
      TIME_POS_CONTROLL_PROXI_POS_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#10s;   // Position monitoring ADV        [ADV / UP / TOP / RIGHT] final position advance (STOP - Normal)
      TIME_POS_CONTROLL_PROXI_POS_MID_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#10s;   // Position monitoring MID_RET final position center position RET
      TIME_POS_CONTROLL_PROXI_POS_MID_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#10s;   // Position monitoring MID_ADV final position center position ADV
      TIME_AFTER_RUN_UP_POS_ACTIVE_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#2500MS ;   // Overrun time final positions active RET (none if = 0)
      TIME_AFTER_RUN_UP_POS_ACTIVE_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#2500MS ;   // Overrun time final positions active ADV (none if = 0)
      COMMISSIONING_MODE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Commissioning mode
      HMI_ALWAYS_REFRESH { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Actuator must always be fully visualized. This setting is necessary if an actuator is to be displayed and operated in other FGs.
      EXISTS_MID_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Final position center position exists
      AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Advance automatically when occupied until RET
      AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Advance automatically when occupied until ADV
      DRIVE_THROUGH_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pass through RET side (if possible)
      DRIVE_THROUGH_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Pass through ADV side (if possible)
      BUTTON_SLOWLY_SHOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Show fast/slow button (despite 1 speed)
      DISABLE_INTERLOCK_BRIDGE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Deactivate locking mechanism override
      DISABLE_ENDPOS_IGNORED_MODE_ACTIVE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Deactivate limit switch override
      DISABLE_WARNING_BUTTON_SLOWLY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := false;   // Deactivate warning button slow selected (automatic)
      TYPE_ENABLE_CHECK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // Allow test
      TYPE_RELEASE_PART_NO_CHECK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Move on if check was failed
      DRIVE_RIDE_RET_IN_AUTOMATIC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Drive also moves backwards in automatic (corner transfer unit)
      DISABLE_SEOC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Stop after end of cycle (Stop End Of Cycle) - deactivate
      ENABLE_CONTROLLED_STOP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := true;   // Block takes part in controlled stop
      ENABLE_HOME_WITHOUT_STOP_POSITION { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Allow home position without final position occupied
      TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transport drive ends when the V2/V1 RET switch is reached
      TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Transport drive ends when the V2/V1 ADV switch is reached
      ENABLE_SHUTTLE_FUNCTION_IN_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activation shuttle function retract to position RET
      ENABLE_SHUTTLE_FUNCTION_IN_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activation shuttle function retract to position ADV
      ENABLE_START_UP_WARNING_FUNCTION { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activation start-up warning function
      DISABLE_SHOW_UNDEFECTED_POSITION { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Deactivating display undefined position
      ENABLE_UNDEFECTED_POSITION_ERROR { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activation undefined position error
      TIME_UNDEFECTED_POSITION { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#10S ;   // Error undefined position time
      DRY_RUN_TIME_IN_FAST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#10S;   // Runtime retract fast in dry run
      DRY_RUN_TIME_IN_SLOW { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#4S;   // Runtime retract slowly in dry run
      DRY_RUN_TIME_OUT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time := T#20S;   // Runtime advance in dry run
      DRY_RUN_ENABLE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Allow dry run
      DRY_RUN_ENABLE_OCCUPIED_SET_ADV_OR_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Allow dry run, set occupied on RET (0 = ADV / 1 = RET occupied)
      ENABLE_OCUUPIED_CHECK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Activation occupied sensor and occupied message not plausible test
      ENABLE_TYPE_DELETE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   // Activation delete type in case of reset
      ENABLE_RESET_EXTERN_AUTO_MODE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Allow RESET_EXTERN in automatic mode
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "CVFL_TLXXX_FB"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Jentzen
FAMILY : CVFL
VERSION : 1.0
//Floor system block (TL/TQ) transport conveyor
   VAR_INPUT 
      OVERFLOW_PIC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Byte;   // Overrun image [2#0 or 2#1 : base image] , multiple drawing possible
      POWER_ON { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Power on
      NUMBER_OF_SPEEDS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := 2;   // 1= Motor with 1 speed/ 2=Motor with 2 speeds
      POSITION_EXISTS_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool := TRUE;   // Retract position exists
      EXISTS_TRAVERSE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool := TRUE;   // Traverse exists
      DRIVE_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Error motor switch/Movimot
      PERIPHERI_OK { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Peripherals OK
      ERROR_CLEARANCE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Gap check (light barrier)
      LC_OCCUPIED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Occupancy sensor (light barrier)
      AUTOMATIC_COMPOSITE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool := TRUE;   // Automatic composite must be true
      BG00_PROXI_POS_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // RET        [RET / DOWN/ BOTTOM / LEFT] final position retract
      BG02_PROXI_FS_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // RET_FS   [RET / DOWN/ BOTTOM / LEFT] change-over V2/V1 retract
      BG04_SHUTTLE_IN_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // ADV_FS [ADVANCE / UP / TOP / RIGHT] change-over V2/V1 advance
      BG05_SHUTTLE_IN_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // ADV_FS [ADVANCE / UP / TOP / RIGHT] change-over V2/V1 advance
      BG03_PROXI_FS_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // ADV_FS [ADVANCE / UP / TOP / RIGHT] change-over V2/V1 advance
      BG01_PROXI_POS_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // ADV        [ADVANCE / UP / TOP / RIGHT] final position advance (STOP - Normal)
      INTERLOCKING_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CV: Lock retract
      INTERLOCKING_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CV: Lock advance
      INTERLOCKING_TRANSPORT_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CV: Lock cross-convey, RET side
      INTERLOCKING_TRANSPORT_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CV: Lock cross-convey, ADV side
      START_TRANSPORT_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CV: Release cross-convey in automatic mode, RET side
      START_TRANSPORT_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // CV: Release cross-convey in automatic mode, ADV side
      RESET_EXTERN { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // RESET EXTERNAL
      OCCUPIED_SET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Busy set from externally, (e.g.: with corner transfer units or lifts)
      OCCUPIED_RESET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Busy reset from externally, (e.g.: with corner transfer units or lifts)
      START_UP_WARNING_RELEASE_TO_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool := FALSE;   // Start-up warning, release start
      SEQ_RET_CONNECTED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Status RET side active connected
      SEQ_RET_MODE_REVERSE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // Status RET side swap side RET<>ADV
      SEQ_ADV_CONNECTED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Status ADV side active connected
      SEQ_ADV_MODE_REVERSE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;   // Status ADV side swap side RET<>ADV
   END_VAR

   VAR_OUTPUT 
      DIAG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;   // Diagnostics word
      HOME_POSITION { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Home
      CONTROL_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Actuation drive retract
      CONTROL_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Actuation drive advance
      CONTROL_FAST { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Drive actuation fast
      CONTROL_RESET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Actuation reset drive error
      START_UP_WARNING_READY_TO_START { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool;   // Start-up warning, ready to start or empty
   END_VAR

   VAR_IN_OUT 
      GLOB { S7_PredefinedAssignment := '"GLOB_DB"'; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : "GLOB_UDT";   // Global data
      TYPE_GLOB { S7_PredefinedAssignment := '"TYPE_GLOB_DB"'; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : "TYPE_GLOB_UDT";   // Type global data
      TYPE_DATA_CTRL { S7_PredefinedAssignment := '"TYPE_DATA_CTRL_DB"'; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : "TYPE_DATA_CTRL_UDT";   // Check data
      SEQ_RET : "CVFL_FLXXX_SEQ_UDT";   // Status RET side
      SEQ : "CVFL_FLXXX_SEQ_UDT";   // Status
      SEQ_ADV : "CVFL_FLXXX_SEQ_UDT";   // Status ADV side
      DRV_REMOTE_SEQ { S7_PredefinedAssignment := '"DRV_REMOTE_SEQ_DB"'; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : "DRV_REMOTE_SEQ_UDT";   // Actuation drive via FU
      UNIT { S7_PredefinedAssignment := '"TYPE_GLOB_DB".UNIT_NO_USED'; S7_HiddenAssignment := 'Hide'; S7_ShowAssignmentIfParamsNotIdentical := 'true'} : "TYPE_REF_UDT";   // Status type dataset reference
   END_VAR

   VAR 
      INSTANCE_NAME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[30];
      RegisterText { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[30];
      HMI : "CVFL_FLXXX_HMI_UDT";
      CONF { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "CVFL_FLXXX_CONF_UDT";
   END_VAR
   VAR RETAIN
      REM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Belegt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Belegt_Lacktraversen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Wegmerker_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Wegmerker_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Wegmerker_RET_NHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Wegmerker_ADV_NHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Wegmerker_RET_NEG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Wegmerker_ADV_NEG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         x_B_SHUTTLE_IN_RET_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         x_B_SHUTTLE_IN_RET_NHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         x_B_SHUTTLE_IN_ADV_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         x_B_SHUTTLE_IN_ADV_NHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         NEW_COMPONENT_RETRACTED_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         NEW_COMPONENT_RETRACTED_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         AUTOMATIC_DRY_RUN_NHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_VAR
   VAR 
      MESS_CONF { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_HANDLE_SINGLE_CONF_UDT";
      GetMessList { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_GET_LIST_FB";
      Mess { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MESS_HANDLE_SINGLE_FB";
      Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      INIT_EDGE_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      DEV_01_FB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "DEV_SELECT_FB";
      DEV_01 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         BUTTON_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         BUTTON_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         BUTTON_ADV_RET_POS_HM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         BUTTON_ADV_RET_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         ACTUATOR_SELECT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         REVERSE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         GROUP { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "DEV_GROUP_UDT";
      END_STRUCT;
      M : Struct
         si_endpos_ignored_mode_active { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         si_service_mode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         si_interlocking_ret { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         si_interlocking_adv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         si_interlocking_transport_ret { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         si_interlocking_transport_adv { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         reset_release { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         reset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         reset_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         reset_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Quitt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Quitt_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Quitt_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         button_invert_occupied_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         button_invert_occupied_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_no_Anst_RET_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Ausf_RET_Dependent_Drive_1_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Ausf_RET_Dependent_Drive_2_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Ausf_ADV_Dependent_Drive_1_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Ausf_ADV_Dependent_Drive_2_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Einf_RET_Dependent_Drive_1_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Einf_RET_Dependent_Drive_2_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Einf_ADV_Dependent_Drive_1_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Einf_ADV_Dependent_Drive_2_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Ausf_ADV_Anst_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Ausf_RET_Anst_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Einf_ADV_Anst_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Einf_RET_Anst_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Anwahl_Ueberfoerdern_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Anwahl_Ueberfoerdern_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Belegt_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Belegt_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Belegt_NHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Belegt_NEG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Belegt_Reset_HM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Belegt_Reset_HM_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Belegt_Reset_HM_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Ausfoerdern_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Ausfoerdern_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Ausfoerdern_HM_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Ausfoerdern_HM_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Einfoerdern_new_Component_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Einfoerdern_new_Component_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Einfoerdern_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Einfoerdern_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Durchfahren_1_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Durchfahren_1_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Durchfahren_2_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Durchfahren_2_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Durchfahren_3_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Durchfahren_3_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Durchfahren_Nachlauf_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Auto_Durchfahren_Nachlauf_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Hand_Ueberfoerdern_RET_control_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Hand_Ueberfoerdern_RET_control_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Hand_Ueberfoerdern_ADV_control_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Hand_Ueberfoerdern_ADV_control_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Hand_Einfoerdern_RET_control_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Hand_Einfoerdern_RET_control_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Hand_Einfoerdern_ADV_control_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Hand_Einfoerdern_ADV_control_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         control_1_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         control_1_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         control_2_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         control_2_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         control_3_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         control_3_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         EMPTY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         occupied_set_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         occupied_set_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         occupied_reset_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         occupied_reset_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         slowly_RET_Error_fs_positions { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         slowly_RET_Save { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         slowly_RET_HM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         slowly_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         slowly_ADV_Error_fs_positions { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         slowly_ADV_Save { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         slowly_ADV_HM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         slowly_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         CONTROL_RET_TIME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         CONTROL_ADV_TIME { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         TIME_FOLLOW_UP_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         TIME_FOLLOW_UP_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         HOME_POSITION { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Travel_Started { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         STATUS_TYPE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         STATUS_TYPE_ASC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];
         HMI_TYPE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         HMI_TYPE_ASC { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String[10];
      END_STRUCT;
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Konfigurationsfehler_FG_Ebene { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Konfigurationsfehler_SG_Ebene { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Parametrierfehler { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Power_off { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Endschalter_ueberbrueckt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Interlock_ueberbrueckt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Spaltkontrolle { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Typedaten_nicht_plausible_oder_leer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Endlagen { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Endlagen_SL { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Endlagen_Parrstoerung { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Interlock { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Time_change_position { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Time_change_position_too_early { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_drive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_peripheri { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Position_controlle_PROXI_POS_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Position_controlle_PROXI_FS_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Position_controlle_PROXI_FS_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Position_controlle_PROXI_POS_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_collision_protection_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_collision_protection_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_unsecured_position_Warnung_EMPTY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_unsecured_position_EMPTY { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_unsecured_position_Warnung_OCCUPIED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_unsecured_position_OCCUPIED { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_controll_drive_in { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Error_Occupied_Check { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      TIME_DEV_time_change_position_SE {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_DEV_time_change_position_Min {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_Entprellzeit_RET {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_Entprellzeit_ADV {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_FOLLOW_UP_RET {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TOF_TIME;
      TIME_FOLLOW_UP_ADV {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TOF_TIME;
      TIME_CONTROL_RET {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TOF_TIME;
      TIME_CONTROL_ADV {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TOF_TIME;
      TIME_DRIVE_THROUGH_RET {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TOF_TIME;
      TIME_DRIVE_THROUGH_ADV {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TOF_TIME;
      TIME_POS_CONTROLL_PROXI_POS_RET {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_POS_CONTROLL_PROXI_FS_RET {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_POS_CONTROLL_PROXI_FS_ADV {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_POS_CONTROLL_PROXI_POS_ADV {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_TYPEDATA_PLAUSIBLE_ERRO_OFF {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_UNDEFECTED_POSITION_EMPTY {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_UNDEFECTED_POSITION_OCCUPIED {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_CONTROLL_DRIVE_IN {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_DRY_RUN_IN_FAST_RET {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_DRY_RUN_IN_SLOW_RET {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_DRY_RUN_OUT_RET {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_DRY_RUN_IN_FAST_ADV {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_DRY_RUN_IN_SLOW_ADV {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      TIME_DRY_RUN_OUT_ADV {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : TON_TIME;
      x_B_pos_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_RET_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_RET_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_RET_NHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_RET_NEG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_RET_NHM1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_RET_NEG1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_fs_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_fs_RET_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_fs_RET_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_fs_RET_NHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_fs_RET_NEG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_ADV_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_ADV_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_ADV_NHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_ADV_NEG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_ADV_NHM1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_pos_ADV_NEG1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_fs_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_fs_ADV_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_fs_ADV_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_fs_ADV_NHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_fs_ADV_NEG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_NEW_COMPONENT_RETRACTE_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_NEW_COMPONENT_RETRACTE_RET_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_NEW_COMPONENT_RETRACTE_RET_NEG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_NEW_COMPONENT_RETRACTE_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_NEW_COMPONENT_RETRACTE_ADV_POS { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_B_NEW_COMPONENT_RETRACTE_ADV_NEG { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      NEW_SHUTTLE_STOP_IN_POS_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      NEW_SHUTTLE_STOP_IN_POS_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      NEW_SHUTTLE_STOP_IN_FS_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      NEW_SHUTTLE_STOP_IN_FS_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_SEQ_Temp { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "CVFL_FLXXX_SEQ_UDT";
      x_SEQ_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "CVFL_FLXXX_SEQ_UDT";
      x_SEQ_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "CVFL_FLXXX_SEQ_UDT";
      x_SEQ_RETxxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Status_Bereit_Einf_xxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_Ausfoerdern_xxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_Enable_Shuttle_Funkction_in_xxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_new_component_retracted_xxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_Anwahl_Ueberfoerdern_xxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_button_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_button_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      x_SEQ_ADVxxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         Status_Bereit_Einf_xxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_Ausfoerdern_xxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_Enable_Shuttle_Funkction_in_xxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_new_component_retracted_xxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_Anwahl_Ueberfoerdern_xxx { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_button_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
         Status_button_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
      x_SEQ_RET_STATUS_OCCUPIED_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      x_SEQ_ADV_STATUS_OCCUPIED_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      TYPE_DELETE { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "TYPE_DELETE_FB";
      TYPE_DELETE_SEQ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "TYPE_DELETE_SEQ_UDT";
      BUTTON_TRANSPORT_RET_OR_ADV_PHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      DRY_RUN_BG00_PROXI_POS_RET { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      DRY_RUN_BG01_PROXI_POS_ADV { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ERROR_CONTROLL_DRIVE_IN_OFF { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      ERROR_CONTROLL_DRIVE_IN_OFF_NHM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      fg : "MODE_FG_WORK_DATA_UDT";
      MessHandler : "MESS_HANDLE_SINGLE_UDT";
      automatic_FG : Bool;
      automatic : Bool;
      manual : Bool;
      WARNING : Bool;
      FAULT : Bool;
      C1 : Int;
      seoc : Bool;
      controlled_stop : Bool;
      extern_manual : Bool;
      Hilfsbit1 : Bool;
      Hilfsbit2 : Bool;
      Hilfsbit3_1 : Bool;
      Temp_Zeitwert : Time;
      Start_up_warning_releas_to_start_RET : Bool;
      Start_up_Warning_releas_to_start_ADV : Bool;
      HM_TYPE_SHIFT_EDGE_IN_RET : Bool;
      HM_TYPE_SHIFT_EDGE_IN_ADV : Bool;
      TEMP_UNIT_REFERENZ : Int;
      DIAG_TEMP : Struct
         MODE_FG_GET_DATA_FC : Word;
         GetMessList : Word;
         MESS_HANDLE_SINGLE_FC : Word;
         MESS_HANDLE_SINGLE_FB : Word;
         TYPE_DELETE : Word;
         TYPE_REG1_REG2_FB_RET : Word;
         TYPE_REG1_REG2_FB_ADV : Word;
         MODE_SET_CONTROLLED_STOP_REV2_FC : Word;
      END_STRUCT;
      x_SEQ_RET_STATUS_OCCUPIED_POS : Bool;
      x_SEQ_ADV_STATUS_OCCUPIED_POS : Bool;
      Transport_retracted_ends_with_fs_pos_RET : Bool;
      Transport_retracted_ends_with_fs_pos_ADV : Bool;
      RET_my_Shuttle_Stop : Bool;
      ADV_my_Shuttle_Stop : Bool;
      RET_Version : Byte;
      ADV_Version : Byte;
      BUTTON_TRANSPORT_RET_OR_ADV_POS : Bool;
      automatic_dry_run : Bool;
      automatic_dry_run_NEG : Bool;
      IN_BG00_PROXI_POS_RET : Bool;
      IN_BG02_PROXI_FS_RET : Bool;
      IN_BG04_SHUTTLE_IN_RET : Bool;
      IN_BG05_SHUTTLE_IN_ADV : Bool;
      IN_BG03_PROXI_FS_ADV : Bool;
      IN_BG01_PROXI_POS_ADV : Bool;
      error_controll_drive_in_off_neg : Bool;
      temp_button_ADV : Bool;
      temp_button_RET : Bool;
      Reset_External : Bool;
   END_VAR


BEGIN
	(**************************************************************************************************************************
	 
	Titel :             CVFL_TLXXX_FB - Bodenförderer Förderer 
	Kommentar :         Über Diesen Baustein werden alle Bodenförderer gesteuert,(Applikationsunabhängig)
	                    TL,TQ Transportförderer - Längsförderer / Querförderer
	    
	Copyright           BMW AG .....
	Ersteller :         Werner Jentzen, TP-244
	         
	****************************************************************************************************************************
	----------------------------------------------------------------------------------------------------------------------------
	BAUSTEINBESCHREIBUNG
	----------------------------------------------------------------------------------------------------------------------------
	Beschreibung Diagnosewort
	----------------------------------------------------------------------------------------------------------------------------
	@DESCRIPTION_DIAG@
	intern aufgerufene Bausteine mit eigenem Diagwort
	ID  Baustein
	
	1   MODE_FG_GET_DATA_FC        
	2   GetMessList   
	3   MESS_HANDLE_SINGLE_FC  
	4   MESS_HANDLE_SINGLE_FB  
	5   TYPE_DELETE                Type Löschen
	6   TYPE_REG1_REG2_FB          Type schieben POS -> RET
	7   TYPE_REG1_REG2_FB          Type schieben POS -> ADV
	8   MODE_SET_CONTROLLED_STOP_REV2_FC
	
	----------------------------------------------------------------------------------------------------------------------------
	Hexwert Beschreibung
	abxx    a = A, C oder ID  b = Störklasse (ID)  xx = Meldenummer
	
	16#A001    Konfigurationsfehler Baustein nicht in FG Ebene aufgerufen
	16#A002    Konfigurationsfehler Baustein nicht in SG Ebene aufgerufen
	16#A003    Parametrierfehler
	---------------------------------------
	   00 : OK - kein error                     / no errors
	   01 : Konfigurationsfehler FG Nummer ungültig   / configuration error FG number not valid
	   02 : Konfigurationsfehler SG Nummer ungültig   / configuration error SG number not valid
	   03 : Parametrierfehler                   / Parameterization error
	   04 : Spaltkontrolle                      / Error Spaltkontrolle (Lichtschranke)
	   05 : Error_Endschalter_überbrueckt       / Error Endschalter überbrückt
	   06 : Error_Interlock_überbrueckt         / Error Sicherheit gebrückt
	   07 : Typedaten nicht plausible oder leer 
	   08 : Taste langsam angewählt ?
	   
	   10 : Power off                           / Power off 
	   11 : Error Antrieb                       / Error drive
	   12 : Error Peripheri                     / Error Peripheri 
	   
	   13 : Stoerung Positonsüberwachung RET    [ZURÜCK / AB/ UNTEN / LINKS] Endlage rück
	   14 : Stoerung Positonsüberwachung RET_FS [ZURÜCK / AB / UNTEN / LINKS] Umschaltung V2/V1 rück
	   15 : Stoerung Positonsüberwachung ADV_FS [vor / AUF / OBEN / RECHTS] Umschaltung V2/V1 vor
	   16 : Stoerung Positonsüberwachung ADV    [vor / AUF / OBEN / RECHTS] Endlage vor (STOP - Normal)
	   17 : Stoerung Positonsüberwachung MID_RET  Endlage Mittelposition RET
	   18 : Stoerung Positonsüberwachung MID_ADV  Endlage Mittelposition ADV
	   
	   20 : Stoerung Belegtstatus / Positionierung!
	   21 : Stoerung stop-Initiator / Initiator nicht erkannt!
	   22 : Stoerung S/L Umschaltung / Initiator nicht erkannt!
	   23 : Stoerung Laufzeit / Ausfoerdern dauert zu lange!
	   24 : Stoerung Verriegelung / Ansteuerung - VOR verriegelt!
	   25 : Stoerung Verriegelung / Ausfoerdern verriegelt!
	   26 : Stoerung Drehzahl / keine korrekte Drehzahlrueckmeldung!
	   
	   30 : Stoerung Endlage / Endlage fehlt!
	   31 : Stoerung Endlage / Endlagenpaar fehlt (S/L + stop)!
	   32 : Stoerung Endlage / Endlage Doppelbelegung!
	   33 : Stoerung Verriegelung / Ansteuerung ist verriegelt!
	   34 : Stoerung Laufzeit / Endlage in vorgegebener Zeit nicht erreicht
	   35 : Stoerung Kollisionsschutz Motor Stop RET
	   36 : Stoerung Kollisionsschutz Motor Stop ADV
	   37 : Stoerung Undefenierte Stellung
	   38 : Automatik Verbund fehlt sein
	   39 : Stoerung einlaufzeit ueberschritten 
	   40 : Stoerung Belegtsensor und Belegtmeldung nicht plausibel
	
	@DESCRIPTION_DIAG@
	****************************************************************************************************************************
	ÄNDERUNGSDOKUMENTATION:
	@CHANGELOG@
	Datum       Version   Autor        --------------------------------------------------------------------------
	27.08.2012  V1.0     Jentzen       Neu
	22.10.2013  V1.4.x   Jentzen       Diagnosewort / Remante Daten
	26.11.2013  v1.5.x   Schaub        Register Seite 1: Bild geändert
	23.01.2014  v1.6.x   Jentzen       Error DRIVE_OK geändert
	31.01.2014  v1.7.x   Jentzen       Stoerung mit 2 ELSIF aufbereitet
	05.03.2014  V1.8.x   Schnellbögl   Integration GetBlockName, GetInstanceName, GetSymbolName
	19.03.2014  v1.30.x  Jentzen       'Software Error :REF_DB not found (not available?)') entfernt
	06.06.2014  v1.35.x  Jentzen       SI_INTERLOCKING...
	25.06.2014  V1.36.x  Schnellbögl   Erweiterung um Parameter OVERFLOW_PIC 
	04.07.2014  V1.35.x  Jentzen       Positonsüberwachung
	09.07.2014  V1.40.x  Jentzen       Default Einputwerte : POWER_ON,DRIVE_OK,PERIPHERI_OK uf TREU Gesetzt
	                                    ERROR_CLEARANCE mit Überbrückung Sicherheit
	                                    TIMER TON=> TOF (TIME_FOLLOW_UP_...)
	16.07.2014  V1.41.x   Jentzen       Typen schieben und commad einfahren  #DRV_REMOTE_SEQ.OUT.COMMAND.%X3 :=                           
	31.07.2014  V1.42.X   Jentzen       Belegt_Lacktraversen erst duch negative wegmerker
	04.08.2014  V1.45.X  Jentzen       Sonderzeichen bei Registertext entfernt
	                                    - Taste langsam/Schnell über CONFIG Einblenden CONF: EXISTS_BUTTON_SLOWLY
	                                    - gespeicherte F1/F2 umschaltung RET/ADV in HMI Anzeigen
	                                    - bei Belegtmeldung automatisch vorfahren RET/ADV                          
	06.08.2014  V1.44.X  Jentzen       - Durchfahrt eingebaut
	                                   - bei Error Spaltkontrolle  Automatisch kein INTERLOCKING
	20.08.2014  V1.45.X  Jentzen       Endschalter überbrücken
	26.08.2014  V1.46.X  Jentzen       #ErrorText.LOCATION , Eingabe Typen in Hand Zulassen                                    
	29.08.2014  V1.47.x  Jentzen       Hängenbleibender V1/V2 umschaltung 
	16.09.2014  V1.48.x  Jentzen       bei keine Grundstellung FG_Home / zurückgesetzt
	17.09.2014  V1.49.x  Jentzen       Positonsüberwachung Beros bei (#CONTROL_RET OR #CONTROL_ADV) 
	23.10.2014  V1.50.x  Jentzen       Implementierung neuer Messhandler und allg. Optimierung
	21.11.2014  V1.51.x  Jentzen       DRV_REMOTE_SEQ.OUT.COMMAND.X5=DRV SELECT
	28.11.2014  V1.52.x  Jentzen       DISABLE_INTERLOCK_BRIDGE und DISABLE_ENDPOS_IGNORED_MODE_ACTIVE eingebaut
	18.03.2015  V1.53.x  Jentzen       #Error.Error_drive nicht an IPST Senden wen extern FU
	13.10.2015  V1.54.x  Jentzen       Type Schiebe information in der SEQ integriert
	05.08.2015  V1.55.x  Jentzen       DIAG abgelöscht
	24.02.2015  V1.56.x  Jentzen       Warnung ausgeben bei annwahl Taste langsam
	03.03.2015  V1.57.x  Jentzen       TYPE_GLOB Verssteckter param : "TYPE_GLOB_DB" (Type schieben "DATA_EXIST_ONLINE" für 1 Zykl setzen)
	31.05.2016  V1.58.x  Jentzen       RUN_EMPTY_MODE_ACTIVE entfernt - muss extern über START_TRANSPORT_xxx Programmiert werden
	28.06.2016  V1.59.x  Jentzen       nach Neustart PLC bleibt die belegtmeldung erhalten
	08.08.2016  V1.60.x  Jentzen       CONF.DRIVE_RIDE_RET_IN_AUTOMATIC (Antrieb fähr in Automatik auch Rückwerts (Eckumsetzer)) neu
	09.08.2016  V1.61.x  Jentzen       Wegmerker Remanet geschaltet / Bugfix Type schieben
	20.09.2016  V1.62.x  Jentzen       Bugfix hängenbleiben der V2/V1 umschaltung
	10.10.2016  V1.63.x  Jentzen       Typen Schieben + Löschen Bugfix 
	18.10.2016  V2.64.x  Jentzen       Bug-Fix , es kommt keine Zeitstörung, Umschaltung Langsam Positonsüberwachung (Zeit überwachung)
	07.11.2016  V2.65.x  Jentzen       Bug-Fix , RESET_EXTERN
	20.12.2016  V2.66.x  Jentzen       Halt nach Taktende über #CONF.DISABLE_SEOC
	11.01.2017  V2.67.x  Jentzen       CONF.TIME_AFTER_RUN_UP_POS_ACTIVE_xxx eingebaut , achlaufzeit Endlagen Aktiv 
	03.04.2017  V2.68.x  Jentzen       Error Laufzeit - #M.CONTROL_XXX_TIME getauscht mit #control_RET_HM Bugfix
	18.05.2017  V2.69.x  Jentzen       Bug-Fix ,Nachlaufzeit Wegmerker setzen nur wenn Connected , vorbereitung Elefantenbetrieb
	05.04.2017  V2.70.x  Jentzen       Elefantenbetrieb integriert - Einige verbesserung (SEQ Erwietert),  Anlaufwarnung integriert, Bei Halt nach Takt ende- keine Duchfahren, HOME_POSITION
	18.07.2017  V2.71.x  Jentzen       Resequencing Mode eingebaut (#fg.OUT.RESEQ_START)
	20.07.2017  V1.72.x  Jentzen       konfigurierbar :Zeige Undefenierte Stellung rot an , und Error ausgabe
	25.09.2017  V2.73.x  Jentzen       Typedate schieben (STATUS_TYPE_UNIT_NEW als Exist meden, und bei Schieben eigener STATUS_TYPE_UNIT als nicht exist melden) Bigfix 
	19.01.2018  V2.74.x  Jentzen       Name Input angepasst START_UP_WARNING_RELEASE_TO_START (E fehlte)
	25.01.2018  V2.75.x  Jentzen       #Error.Error_collision_protection_xxx Normales Quitt
	31.01.2018  V2.76.x  Jentzen       Belegt mit Lacktraversen mit Umschaltung V1/V2 bugfix
	01.02.2018  V2.76.x  Jentzen       Typen schieben Extern ers wenn frei
	01.02.2018  V2.77.x  Jentzen       Shuttle fahren obtimiert
	16.02.2018  V2.78.x  Jentzen       Bugfix Belegt_Lacktraversen mit V2/V1
	04.04.2018  V2.79.x  Jentzen       Bugfix Typeschieben wenn Instanz geladen wird.
	18.04.2018  V2.80.x  Jentzen       Bugfix NEW_SHUTTLE_STOP_IN_POS_xx & #SEQ.STATUS_TYPE_UNIT_NEW duch reset zurückgesetzt
	05.06.2018  V2.81.x  Jentzen       Controlled Stop eingebaut, Konfigurierbar ohne Endlage RET/ADV in Home
	07.06.2018  V2.82.x  Jentzen       Anwahl Stellgerät auch über button_transport_RET/ADV
	07.06.2018  V2.83.x  Jentzen       Bugfix (Load / Unlaod befehle über Remoute - #DRV_REMOTE_SEQ.OUT.COMMAND.%X3 )
	23.06.2018  V2.84.x  Jentzen       Bugfix AutoDurchfahren
	23.06.2018  V2.85.x  Jentzen       Automatik Verbund neuer eingang "AUTOMATIC_COMPOSITE" (Default auf TRUE)
	25.09.2018  V2.86.x  Jentzen       neuer Error Einlaufzeit, neuer SEQ bits STATUS_PART_CHANGE,STATUS_IN_POSITION
	03.10.2018  V2.87.x  Jentzen       Dry run intregriert
	06.10.2018  V2.88.x  Jentzen       Bugfix bei ende Dry run automatisch Reset ausfuehren
	06.10.2018  V2.89.x  Jentzen       Bugfix bei ende Dry 
	12.10.2018  V2.90.x  Jentzen       Neuer eingang "LC_OCCUPIED", Error Belegtsensor und  Belegtmeldung nicht plausibel
	09.01.2019  V2.91.x  Jentzen       Bugfix Type Schieben fehler REFERENZ DATA_EXIST & Bugfix Einfahrzeit & Shuttlebetrieb RET "#M.Ausfoerdern_RET" 
	05.03.2019  V2.92.x  Jentzen       Wenn Vorgänger Förderer Motorfehler hat (z.B. Kollisionsschutz) mein Motor mit abschalten
	21.03.2019  V2.93.x  Jentzen       #SEQ.STATUS_DRIVE_RUNNING Ausgabe unverzögert (Vorgänger sofort stoppen wenn Fehler) , Bug fix Auto_Ausfoerdern_HM_ADV/RET
	24.10.2019  V2.94.x  Jentzen       Buxfix Auto_Durchfahren : Berücksichtigung von Interlocking_xxx und Strat_Transport_xxx, bei undefinierte Position Antrieb abschalten 
	07.02.2020  V2.95.x  Jentzen       Parrstoerung nur wenn Fahren mit Traverse
	12.02.2020  V2.96.x  Jentzen       Bugfix bei error Umschaltung V2/V1 Bero nicht betätigt
	20.02.2020  V2.97.x  Jentzen       Type bei Reset löschen wen Leer uber CONF konfigurierbar 
	15.04.2020  V2.98.x  Jentzen       Bugfix: Nach einem Reset #M.slowly_xx_Save gesetzt wenn Stop + S/L-Ini dauerhaft belegt
	09.07.2020  V2.99.x  Jentzen       Erweiterung SEW Gen.c => DRV_REMOTE_SEQ_UDT
	15.01.2021  V2.100.x Orchard       Bugfix: SHEET_DRV, doppelte Meldung 39 entfernen
	22.02.2021  V2.101.x Orchard       #CONF.ENABLE_RESET_EXTERN_AUTO_MODE hinzugefügt
	27.04.2022  V2.102.x Orchard       #CONF.TIME_CHANGE_POSITION_MIN und neuer Meldung 43 hinzugefügt
	
	@CHANGELOG@
	*)
	// ==========================================================================================================================
	// ==========================================================================================================================
	// ==========================================================================================================================
	// G E N E R E R A L   /   A L L G E M E I N
	// ==========================================================================================================================
	// ==========================================================================================================================
	// ==========================================================================================================================
	// -------------------------------------------
	// Instanz Initialisieren
	// -------------------------------------------
	#INIT_EDGE_POS := NOT #Init;
	IF NOT #Init OR #RESET_EXTERN OR #HMI.IN.button_reset THEN
	    #Init := true;
	    //--------------------------------------------------------------------------------------------------------------------------  
	    // Multiinstanznamen auslesen
	    //--------------------------------------------------------------------------------------------------------------------------  
	    #INSTANCE_NAME := WSTRING_TO_STRING(GetInstanceName(0));
	    
	    #RegisterText := #INSTANCE_NAME;
	    WHILE FIND(IN1 := #RegisterText, IN2 := '#') <> 0 DO
	        #RegisterText := DELETE(IN := #RegisterText, L := 1, P := FIND(IN1 := #RegisterText, IN2 := '#'));
	    END_WHILE;
	    WHILE FIND(IN1 := #RegisterText, IN2 := '"') <> 0 DO
	        #RegisterText := DELETE(IN := #RegisterText, L := 1, P := FIND(IN1 := #RegisterText, IN2 := '"'));
	    END_WHILE;
	    
	END_IF;
	
	// -------------------------------------------
	// Errorwort ablöschen
	// -------------------------------------------
	#Error.Parametrierfehler := false;
	#DIAG := 0;
	//****************************************************************************************************************************
	// FG Daten holen
	//****************************************************************************************************************************
	#fg := "MODE_FG_GET_DATA_FC"(GLOB := #GLOB, DIAG => #DIAG_TEMP.MODE_FG_GET_DATA_FC);
	
	#Error.Konfigurationsfehler_FG_Ebene := #DIAG_TEMP.MODE_FG_GET_DATA_FC = w#16#A001;
	#Error.Konfigurationsfehler_SG_Ebene := #DIAG_TEMP.MODE_FG_GET_DATA_FC = w#16#A002;
	// -------------------------------------------
	// Parametrierfehler
	// -------------------------------------------
	// 1= Motor mit 1 geschwindigkeit / 2=Motor mit 2 geschwindigkeit
	IF #NUMBER_OF_SPEEDS = 0 OR #NUMBER_OF_SPEEDS > 2 THEN
	    #Error.Parametrierfehler := TRUE;
	END_IF;
	// Automatisch vorfahren
	IF #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET AND #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV THEN
	    #Error.Parametrierfehler := TRUE;
	END_IF;
	// Transport endet mit erreichen der Umschaltung V2/V1
	IF #NUMBER_OF_SPEEDS = 1 AND (#CONF.TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_RET OR #CONF.TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_ADV) THEN
	    #Error.Parametrierfehler := TRUE;
	END_IF;
	
	// -------------------------------------------
	// Versionverwaltung
	// -------------------------------------------
	(*
	 0 Ausgabestand 21.01.2015 
	 1 Ausgabestand 13.04.2017    SEQ Erweiterung => nach Update auf Shutlle betrieb : Version 1 
	    Neu hinzugekommen ist in der SEQ Schnittstelle:
	    - #SEQ.STATUS_TYPE_NEW 
	    - #SEQ.STATUS_TYPE_ASC_NEW 
	    - #SEQ.STATUS_EXTERN_OCCUPIED_SET 
	    - #SEQ.STATUS_EXTERN_OCCUPIED_RESET 
	    - #SEQ.STATUS_COLLISION_PROTECTION_DRIVE_SLOW 
	    - #SEQ.STATUS_COLLISION_PROTECTION_DRIVE_STOP 
	    - #SEQ.STATUS_ENABLE_SHUTTLE_FUNCTION_IN_RET 
	    - #SEQ.STATUS_ENABLE_SHUTTLE_FUNCTION_IN_ADV 
	    - #SEQ.STATUS_NAME
	    - #SEQ.STATUS_NEW_COMPONENT_RETRACTED_RET
	    - #SEQ.STATUS_NEW_COMPONENT_RETRACTED_ADV
	        
	    Typene mussen jetzt Zwischengespeichert werden, da er eventuell von den neuen eigefahren typen überschrieben wird,
	    in der Version 0 = Geht der Streckmeker erst bei Ankommen nächsten Belegtmeldung weg.
	    in der Version 1 = geht es schon mit #SEQ_(RET_ADV).STATUS_NEW_COMPONENT_RETRACTED_XXX weg (V1/V2 Umschaltung)
	    
	 *)
	 // ----------------
	 #SEQ.STATUS_VERSION := 1;
	 // ----------------
	 // REMOTE Version
	 // ----------------
	 #RET_Version := #SEQ_RET.STATUS_VERSION;
	 #ADV_Version := #SEQ_ADV.STATUS_VERSION;
	 
	 // ==========================================================================================================================
	 // Status Seite RET / Status Seite ADV
	 // ==========================================================================================================================
	 IF #SEQ_RET_CONNECTED THEN
	     #x_SEQ_RET := #SEQ_RET;
	 ELSE
	     #x_SEQ_RET := #x_SEQ_Temp;
	 END_IF;
	 
	 IF #SEQ_RET_MODE_REVERSE THEN
	     #x_SEQ_RETxxx.Status_Bereit_Einf_xxx := #x_SEQ_RET.STATUS_READY_IN_RET;
	     #x_SEQ_RETxxx.Status_Ausfoerdern_xxx := #x_SEQ_RET.STATUS_OUT_RET;
	     #x_SEQ_RETxxx.Status_Anwahl_Ueberfoerdern_xxx := #x_SEQ_RET.STATUS_SELECT_TRANSP_RET;
	     #x_SEQ_RETxxx.Status_button_RET := #x_SEQ_RET.STATUS_BUTTON_ADV;
	     #x_SEQ_RETxxx.Status_button_ADV := #x_SEQ_RET.STATUS_BUTTON_RET;
	     // Shuttle
	     #x_SEQ_RETxxx.Status_Enable_Shuttle_Funkction_in_xxx := #x_SEQ_RET.STATUS_ENABLE_SHUTTLE_FUNCTION_IN_ADV;
	     #x_SEQ_RETxxx.Status_new_component_retracted_xxx := #x_SEQ_RET.STATUS_NEW_COMPONENT_RETRACTED_ADV;
	 ELSE
	     #x_SEQ_RETxxx.Status_Bereit_Einf_xxx := #x_SEQ_RET.STATUS_READY_IN_ADV;
	     #x_SEQ_RETxxx.Status_Ausfoerdern_xxx := #x_SEQ_RET.STATUS_OUT_ADV;
	     #x_SEQ_RETxxx.Status_Anwahl_Ueberfoerdern_xxx := #x_SEQ_RET.STATUS_SELECT_TRANSP_ADV;
	     #x_SEQ_RETxxx.Status_button_RET := #x_SEQ_RET.STATUS_BUTTON_RET;
	     #x_SEQ_RETxxx.Status_button_ADV := #x_SEQ_RET.STATUS_BUTTON_ADV;
	     // Shuttle
	     #x_SEQ_RETxxx.Status_Enable_Shuttle_Funkction_in_xxx := #x_SEQ_RET.STATUS_ENABLE_SHUTTLE_FUNCTION_IN_RET;
	     #x_SEQ_RETxxx.Status_new_component_retracted_xxx := #x_SEQ_RET.STATUS_NEW_COMPONENT_RETRACTED_RET;
	 END_IF;
	 
	 IF #SEQ_ADV_CONNECTED THEN
	     #x_SEQ_ADV := #SEQ_ADV;
	 ELSE
	     #x_SEQ_ADV := #x_SEQ_Temp;
	 END_IF;
	 
	 IF #SEQ_ADV_MODE_REVERSE THEN
	     #x_SEQ_ADVxxx.Status_Bereit_Einf_xxx := #x_SEQ_ADV.STATUS_READY_IN_ADV;
	     #x_SEQ_ADVxxx.Status_Ausfoerdern_xxx := #x_SEQ_ADV.STATUS_OUT_ADV;
	     #x_SEQ_ADVxxx.Status_Anwahl_Ueberfoerdern_xxx := #x_SEQ_ADV.STATUS_SELECT_TRANSP_ADV;
	     #x_SEQ_ADVxxx.Status_button_RET := #x_SEQ_ADV.STATUS_BUTTON_ADV;
	     #x_SEQ_ADVxxx.Status_button_ADV := #x_SEQ_ADV.STATUS_BUTTON_RET;
	     // Shuttle
	     #x_SEQ_ADVxxx.Status_Enable_Shuttle_Funkction_in_xxx := #x_SEQ_ADV.STATUS_ENABLE_SHUTTLE_FUNCTION_IN_RET;
	     #x_SEQ_ADVxxx.Status_new_component_retracted_xxx := #x_SEQ_ADV.STATUS_NEW_COMPONENT_RETRACTED_RET;
	 ELSE
	     #x_SEQ_ADVxxx.Status_Bereit_Einf_xxx := #x_SEQ_ADV.STATUS_READY_IN_RET;
	     #x_SEQ_ADVxxx.Status_Ausfoerdern_xxx := #x_SEQ_ADV.STATUS_OUT_RET;
	     
	     #x_SEQ_ADVxxx.Status_Anwahl_Ueberfoerdern_xxx := #x_SEQ_ADV.STATUS_SELECT_TRANSP_RET;
	     #x_SEQ_ADVxxx.Status_button_RET := #x_SEQ_ADV.STATUS_BUTTON_RET;
	     #x_SEQ_ADVxxx.Status_button_ADV := #x_SEQ_ADV.STATUS_BUTTON_ADV;
	     // Shuttle
	     #x_SEQ_ADVxxx.Status_Enable_Shuttle_Funkction_in_xxx := #x_SEQ_ADV.STATUS_ENABLE_SHUTTLE_FUNCTION_IN_ADV;
	     #x_SEQ_ADVxxx.Status_new_component_retracted_xxx := #x_SEQ_ADV.STATUS_NEW_COMPONENT_RETRACTED_ADV;
	 END_IF;
	 
	 // -------------------------------------------
	 // Auf Hand gehen Seite RET oder Seite ADV möchte Ueberfoerdern 
	 // -------------------------------------------
	 #extern_manual :=
	 (#x_SEQ_ADVxxx.Status_Anwahl_Ueberfoerdern_xxx AND #SEQ_ADV.STATUS_MANUAL)
	 OR
	 (#x_SEQ_RETxxx.Status_Anwahl_Ueberfoerdern_xxx AND #SEQ_RET.STATUS_MANUAL)
	 ;
	 // Automatig Start
	 #automatic_FG := #fg.OUT.AUT_START OR #fg.OUT.RESEQ_START;
	 
	 // -------------------------------------------
	 // Automatik / Hand / Manuell
	 // -------------------------------------------
	 #manual := (#fg.OUT.MAN AND #fg.OUT.MAN_RELEASE) OR #extern_manual;
	 #automatic := #automatic_FG AND NOT #extern_manual AND #AUTOMATIC_COMPOSITE;
	 #automatic_dry_run := #fg.OUT.DRY_RUN_MODE_ACTIVE;
	 #seoc := #fg.OUT.SEOC AND NOT #CONF.DISABLE_SEOC; // Halt nach Taktende
	 #controlled_stop := #fg.OUT.REQ_CONTROLLED_STOP AND #CONF.ENABLE_CONTROLLED_STOP; // Controlled Stop
	 
	 // -------------------------------------------
	 // Quittierung Positiv / Positive Acknowledgement
	 // -------------------------------------------
	 #M.Quitt := #fg.OUT.QUIT_EDGE;
	 #M.Quitt_POS := #M.Quitt AND NOT #M.Quitt_PHM;
	 #M.Quitt_PHM := #M.Quitt;
	 // -------------------------------------------
	 // Überbrückung Verriegelung / Endschalter überbrücken
	 // -------------------------------------------
	 #M.si_endpos_ignored_mode_active := #manual AND #DEV_01.ACTUATOR_SELECT AND #fg.OUT.ENDPOS_IGNORED_MODE_ACTIVE AND NOT #CONF.DISABLE_ENDPOS_IGNORED_MODE_ACTIVE;
	 #M.si_service_mode := #manual
	 AND (
	 (#fg.OUT.SERVICE_MODE_ACTIVE AND NOT #CONF.DISABLE_INTERLOCK_BRIDGE)
	 OR
	 #M.si_endpos_ignored_mode_active
	 OR
	 (#x_SEQ_ADVxxx.Status_Anwahl_Ueberfoerdern_xxx AND #SEQ_ADV.STATUS_MANUAL AND #SEQ_ADV.STATUS_SERVICE_MODE_ACTIVE)
	 OR
	 (#x_SEQ_RETxxx.Status_Anwahl_Ueberfoerdern_xxx AND #SEQ_RET.STATUS_MANUAL AND #SEQ_RET.STATUS_SERVICE_MODE_ACTIVE)
	 )
	 ;
	 #M.reset_release := #manual AND (#fg.OUT.SERVICE_MODE_ACTIVE OR #M.si_endpos_ignored_mode_active);
	 
	 #M.si_interlocking_ret := (#INTERLOCKING_RET AND NOT #Error.Error_Spaltkontrolle) OR #M.si_service_mode;
	 // (#INTERLOCKING_RET AND #POSITION_EXISTS_RET) OR #M.SI_gebrueckt;
	 #M.si_interlocking_adv := (#INTERLOCKING_ADV AND NOT #Error.Error_Spaltkontrolle) OR #M.si_service_mode;
	 #M.si_interlocking_transport_ret := (#INTERLOCKING_TRANSPORT_RET AND NOT #Error.Error_Spaltkontrolle) OR #M.si_service_mode;
	 #M.si_interlocking_transport_adv := (#INTERLOCKING_TRANSPORT_ADV AND NOT #Error.Error_Spaltkontrolle) OR #M.si_service_mode;
	 
	 
	 // ==========================================================================================================================
	 // Bauteillos fahren / DRY RUN AKTIV
	 // ==========================================================================================================================
	 // Dry run Negativ
	 #automatic_dry_run_NEG := NOT #automatic_dry_run AND NOT #REM.AUTOMATIC_DRY_RUN_NHM;
	 #REM.AUTOMATIC_DRY_RUN_NHM := NOT #automatic_dry_run;
	 
	 IF #automatic_dry_run AND #CONF.DRY_RUN_ENABLE THEN
	     
	     //     -------------         -------------      -------------
	     //     : RET    ADV:  E-->  : RET    ADV: A-->  : RET    ADV:
	     //     -------------         -------------      --------------
	     // 
	     // ------------------------------  
	     // Einfahren RET
	     // ------------------------------
	     #TIME_DRY_RUN_IN_FAST_RET(IN := #M.Auto_Einfoerdern_RET OR #M.Auto_Einfoerdern_new_Component_ADV,
	                               PT := #CONF.DRY_RUN_TIME_IN_FAST,
	                               ET => #Temp_Zeitwert);
	     
	     #TIME_DRY_RUN_IN_SLOW_RET(IN := #TIME_DRY_RUN_IN_FAST_RET.Q,
	                               PT := #CONF.DRY_RUN_TIME_IN_SLOW,
	                               ET => #Temp_Zeitwert);
	     // ------------------------------
	     // Ausfahren ADV
	     // ------------------------------
	     #TIME_DRY_RUN_OUT_ADV(IN := #M.Ausfoerdern_ADV AND #M.control_3_ADV,
	                           PT := #CONF.DRY_RUN_TIME_OUT,
	                           ET => #Temp_Zeitwert);
	     
	     
	     //     -------------         -------------      -------------
	     //     : RET    ADV:  <--A  : RET    ADV: <--E  : RET    ADV:
	     //     -------------         -------------      --------------
	     //     
	     // ------------------------------
	     // Einfahren ADV
	     // ------------------------------
	     #TIME_DRY_RUN_IN_FAST_ADV(IN := #M.Auto_Einfoerdern_ADV OR #M.Auto_Einfoerdern_new_Component_RET,
	                               PT := #CONF.DRY_RUN_TIME_IN_FAST,
	                               ET => #Temp_Zeitwert);
	     
	     #TIME_DRY_RUN_IN_SLOW_ADV(IN := #TIME_DRY_RUN_IN_FAST_ADV.Q,
	                               PT := #CONF.DRY_RUN_TIME_IN_SLOW,
	                               ET => #Temp_Zeitwert);
	     
	     
	     // ------------------------------
	     // Ausfahren RET
	     // ------------------------------
	     #TIME_DRY_RUN_OUT_RET(IN := #M.Ausfoerdern_RET AND #M.control_3_RET,
	                           PT := #CONF.DRY_RUN_TIME_OUT,
	                           ET => #Temp_Zeitwert);
	     // --------------------------------------------------------------------
	     // Eingange Manipulieren RET
	     // --------------------------------------------------------------------
	     IF (#POSITION_EXISTS_RET AND #TIME_DRY_RUN_IN_FAST_ADV.Q AND #TIME_DRY_RUN_IN_SLOW_ADV.Q AND #M.CONTROL_RET_TIME)
	         OR (#M.occupied_set_POS AND #CONF.DRY_RUN_ENABLE_OCCUPIED_SET_ADV_OR_RET)
	         OR (#M.button_invert_occupied_POS AND #REM.Belegt AND #CONF.DRY_RUN_ENABLE_OCCUPIED_SET_ADV_OR_RET)
	     THEN
	         #DRY_RUN_BG00_PROXI_POS_RET := TRUE;
	         #DRY_RUN_BG01_PROXI_POS_ADV := FALSE;
	     END_IF;
	     // --------------------------------
	     IF #TIME_DRY_RUN_OUT_RET.IN OR #M.reset_POS
	         OR (#M.occupied_reset_POS AND NOT #CONF.DRY_RUN_ENABLE_OCCUPIED_SET_ADV_OR_RET)
	         OR (#M.button_invert_occupied_POS AND NOT #REM.Belegt AND #CONF.DRY_RUN_ENABLE_OCCUPIED_SET_ADV_OR_RET)
	     THEN
	         #DRY_RUN_BG00_PROXI_POS_RET := FALSE;
	         #DRY_RUN_BG01_PROXI_POS_ADV := FALSE;
	     END_IF;
	     
	     #IN_BG00_PROXI_POS_RET := #DRY_RUN_BG00_PROXI_POS_RET;
	     #IN_BG02_PROXI_FS_RET := #POSITION_EXISTS_RET AND #NUMBER_OF_SPEEDS >= 02 AND #TIME_DRY_RUN_IN_FAST_ADV.Q;
	     #IN_BG04_SHUTTLE_IN_RET :=
	     #POSITION_EXISTS_RET
	     AND #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET
	     AND (
	     (#NUMBER_OF_SPEEDS >= 02 AND #IN_BG02_PROXI_FS_RET)
	     OR
	     (#NUMBER_OF_SPEEDS = 1 AND #IN_BG00_PROXI_POS_RET)
	     );
	     // --------------------------------------------------------------------
	     // Eingange Manipulieren ADV
	     // --------------------------------------------------------------------
	     IF (#TIME_DRY_RUN_IN_FAST_RET.Q AND #TIME_DRY_RUN_IN_SLOW_RET.Q AND #M.CONTROL_ADV_TIME)
	         OR (#M.occupied_set_POS AND NOT #CONF.DRY_RUN_ENABLE_OCCUPIED_SET_ADV_OR_RET)
	         OR (#M.button_invert_occupied_POS AND #REM.Belegt AND NOT #CONF.DRY_RUN_ENABLE_OCCUPIED_SET_ADV_OR_RET)
	     THEN
	         #DRY_RUN_BG00_PROXI_POS_RET := FALSE;
	         #DRY_RUN_BG01_PROXI_POS_ADV := TRUE;
	     END_IF;
	     // --------------------------------
	     IF #TIME_DRY_RUN_OUT_ADV.IN OR #M.reset_POS
	         OR (#M.occupied_reset_POS AND #CONF.DRY_RUN_ENABLE_OCCUPIED_SET_ADV_OR_RET)
	         OR (#M.button_invert_occupied_POS AND NOT #REM.Belegt AND NOT #CONF.DRY_RUN_ENABLE_OCCUPIED_SET_ADV_OR_RET)
	     THEN
	         #DRY_RUN_BG00_PROXI_POS_RET := FALSE;
	         #DRY_RUN_BG01_PROXI_POS_ADV := FALSE;
	     END_IF;
	     
	     #IN_BG01_PROXI_POS_ADV := #DRY_RUN_BG01_PROXI_POS_ADV;
	     #IN_BG03_PROXI_FS_ADV := #NUMBER_OF_SPEEDS >= 02 AND #TIME_DRY_RUN_IN_FAST_RET.Q;
	     #IN_BG05_SHUTTLE_IN_ADV :=
	     #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV
	     AND (
	     (#NUMBER_OF_SPEEDS >= 02 AND #IN_BG03_PROXI_FS_ADV)
	     OR
	     (#NUMBER_OF_SPEEDS = 01 AND #IN_BG01_PROXI_POS_ADV)
	     );
	     
	 ELSE
	     
	     
	     #DRY_RUN_BG00_PROXI_POS_RET := FALSE;
	     #DRY_RUN_BG01_PROXI_POS_ADV := FALSE;
	     
	     #IN_BG00_PROXI_POS_RET := #BG00_PROXI_POS_RET;
	     #IN_BG02_PROXI_FS_RET := #BG02_PROXI_FS_RET;
	     #IN_BG04_SHUTTLE_IN_RET := #BG04_SHUTTLE_IN_RET;
	     #IN_BG05_SHUTTLE_IN_ADV := #BG05_SHUTTLE_IN_ADV;
	     #IN_BG03_PROXI_FS_ADV := #BG03_PROXI_FS_ADV;
	     #IN_BG01_PROXI_POS_ADV := #BG01_PROXI_POS_ADV;
	     
	 END_IF;
	 
	 
	
	// -------------------------------------------
	// RESET_EXTERN 
	// -------------------------------------------
	 #Reset_External := #RESET_EXTERN AND (#manual OR #CONF.ENABLE_RESET_EXTERN_AUTO_MODE);
	 
	 // -------------------------------------------
	 // Fehler Belegtsensor und Belegtmeldung nicht plausibel
	 // -------------------------------------------
	 IF #CONF.ENABLE_OCUUPIED_CHECK THEN
	     
	     IF #HMI.IN.button_reset OR #HMI.IN.button_invert_occupied OR #Reset_External THEN
	         IF (#LC_OCCUPIED XOR #REM.Belegt) AND NOT (#automatic_dry_run AND #CONF.DRY_RUN_ENABLE) THEN
	             #Error.Error_Occupied_Check := TRUE;
	         END_IF;
	     END_IF;
	 END_IF;
	 
	 // -------------------------------------------
	 // Sperrmerker ruecksetzen / blocking_flag reset
	 // -------------------------------------------
	 #M.reset :=
	 (#M.reset_release AND #HMI.IN.button_reset AND NOT #Error.Error_Occupied_Check)
	 OR (#Reset_External AND NOT #Error.Error_Occupied_Check)
	 OR #automatic_dry_run_NEG;
	 
	 #M.reset_POS := #M.reset AND NOT #M.reset_PHM;
	 #M.reset_PHM := #M.reset;
	 
	 IF #M.reset_POS THEN
	     #HMI.IN.button_slowly := FALSE;
	     #M.slowly_RET_Save := FALSE;
	     #M.slowly_ADV_Save := FALSE;
	     #HMI.IN.button_transport_RET := FALSE;
	     #HMI.IN.button_transport_ADV := FALSE;
	     #REM.Wegmerker_RET := FALSE;
	     #REM.Wegmerker_ADV := FALSE;
	     #M.Ausfoerdern_RET := FALSE;
	     #M.Ausfoerdern_ADV := FALSE;
	     #REM.Belegt := FALSE;
	     #REM.Belegt_Lacktraversen := FALSE;
	     #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET := FALSE;
	     #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV := FALSE;
	     
	     #REM.NEW_COMPONENT_RETRACTED_RET := FALSE;
	     #REM.NEW_COMPONENT_RETRACTED_ADV := FALSE;
	     
	     #ERROR_CONTROLL_DRIVE_IN_OFF := FALSE;
	     
	     #SEQ.STATUS_TYPE_NEW := 0;
	     #SEQ.STATUS_TYPE_ASC_NEW := '';
	     
	     #SEQ.STATUS_TYPE_UNIT_NEW.REFERENZ := 0;
	     #SEQ.STATUS_TYPE_UNIT_NEW.ERROR_TYPE := FALSE;
	     #SEQ.STATUS_TYPE_UNIT_NEW.RESTORE := FALSE;
	     
	     IF NOT #IN_BG00_PROXI_POS_RET AND NOT #IN_BG01_PROXI_POS_ADV THEN
	         #SEQ.STATUS_TYPE := 0;
	         #SEQ.STATUS_TYPE_ASC := '';
	     END_IF;
	     
	 END_IF;
	 
	 // ==========================================================================================================================
	 //  Endposition und Stratposition
	 // mit dem Parameter "#mode_reverse" wird die Endposition und Stratposition festgelegt.
	 // "#mode_reverse" = 0 Normalfall ist Position ADV die Endposition und Stratposition
	 // "#mode_reverse" = 1            ist Position RET die Endposition und Stratposition
	 // ==========================================================================================================================
	 IF #PERIPHERI_OK THEN
	     // Statement section IF
	     IF #POSITION_EXISTS_RET THEN
	         // #Entprellzeit RET
	         #TIME_Entprellzeit_RET(IN := NOT #IN_BG00_PROXI_POS_RET,
	                                PT := T#500MS,
	                                Q => #Hilfsbit1,
	                                ET => #Temp_Zeitwert);
	         IF #IN_BG00_PROXI_POS_RET THEN
	             #x_B_pos_RET := true;
	         END_IF;
	         IF NOT #IN_BG00_PROXI_POS_RET AND #Hilfsbit1 THEN
	             #x_B_pos_RET := false;
	         END_IF;
	         #x_B_fs_RET := #IN_BG02_PROXI_FS_RET;
	     ELSE
	         #x_B_pos_RET := false;
	         #x_B_fs_RET := false;
	     END_IF;
	     
	     // #Entprellzeit ADV
	     #TIME_Entprellzeit_ADV(IN := NOT #IN_BG01_PROXI_POS_ADV,
	                            PT := T#500MS,
	                            Q => #Hilfsbit1,
	                            ET => #Temp_Zeitwert);
	     IF #IN_BG01_PROXI_POS_ADV THEN
	         #x_B_pos_ADV := true;
	     END_IF;
	     IF NOT #IN_BG01_PROXI_POS_ADV AND #Hilfsbit1 THEN
	         #x_B_pos_ADV := false;
	     END_IF;
	     #x_B_fs_ADV := #IN_BG03_PROXI_FS_ADV;
	     
	 END_IF;
	 
	 // ------------------------------------------------------------
	 // Positionier-Sensoren Positiv / Neagtiv
	 // ------------------------------------------------------------
	 // positiv
	 #x_B_fs_RET_POS := #x_B_fs_RET AND NOT #x_B_fs_RET_PHM;
	 #x_B_fs_RET_PHM := #x_B_fs_RET;
	 #x_B_pos_RET_POS := #x_B_pos_RET AND NOT #x_B_pos_RET_PHM;
	 #x_B_pos_RET_PHM := #x_B_pos_RET;
	 
	 #x_B_fs_ADV_POS := #x_B_fs_ADV AND NOT #x_B_fs_ADV_PHM;
	 #x_B_fs_ADV_PHM := #x_B_fs_ADV;
	 #x_B_pos_ADV_POS := #x_B_pos_ADV AND NOT #x_B_pos_ADV_PHM;
	 #x_B_pos_ADV_PHM := #x_B_pos_ADV;
	 
	 // negativ
	 #x_B_fs_RET_NEG := NOT #x_B_fs_RET AND NOT #x_B_fs_RET_NHM;
	 #x_B_fs_RET_NHM := NOT #x_B_fs_RET;
	 #x_B_pos_RET_NEG := NOT #x_B_pos_RET AND NOT #x_B_pos_RET_NHM;
	 #x_B_pos_RET_NHM := NOT #x_B_pos_RET;
	 
	 #x_B_fs_ADV_NEG := NOT #x_B_fs_ADV AND NOT #x_B_fs_ADV_NHM;
	 #x_B_fs_ADV_NHM := NOT #x_B_fs_ADV;
	 #x_B_pos_ADV_NEG := NOT #x_B_pos_ADV AND NOT #x_B_pos_ADV_NHM;
	 #x_B_pos_ADV_NHM := NOT #x_B_pos_ADV;
	 
	 // negativ (nicht endprellt)
	 #x_B_pos_RET_NEG1 := NOT #IN_BG00_PROXI_POS_RET AND NOT #x_B_pos_RET_NHM1;
	 #x_B_pos_RET_NHM1 := NOT #IN_BG00_PROXI_POS_RET;
	 
	 #x_B_pos_ADV_NEG1 := NOT #IN_BG01_PROXI_POS_ADV AND NOT #x_B_pos_ADV_NHM1;
	 #x_B_pos_ADV_NHM1 := NOT #IN_BG01_PROXI_POS_ADV;
	 
	 // ------------------------------------------------------------
	 // Belgt Positiv RET/ADV
	 // ------------------------------------------------------------
	 #x_SEQ_RET_STATUS_OCCUPIED_POS := #x_SEQ_RET.STATUS_OCCUPIED AND NOT #x_SEQ_RET_STATUS_OCCUPIED_PHM;
	 #x_SEQ_RET_STATUS_OCCUPIED_PHM := #x_SEQ_RET.STATUS_OCCUPIED;
	 
	 #x_SEQ_ADV_STATUS_OCCUPIED_POS := #x_SEQ_ADV.STATUS_OCCUPIED AND NOT #x_SEQ_ADV_STATUS_OCCUPIED_PHM;
	 #x_SEQ_ADV_STATUS_OCCUPIED_PHM := #x_SEQ_ADV.STATUS_OCCUPIED;
	 
	 // ==========================================================================================================================
	 // Auswerten der Stellgerät / DEV drive engine
	 // ==========================================================================================================================
	 #BUTTON_TRANSPORT_RET_OR_ADV_POS := (#HMI.IN.button_transport_RET OR #HMI.IN.button_transport_ADV) AND NOT #BUTTON_TRANSPORT_RET_OR_ADV_PHM;
	 #BUTTON_TRANSPORT_RET_OR_ADV_PHM := (#HMI.IN.button_transport_RET OR #HMI.IN.button_transport_ADV);
	 
	 IF #BUTTON_TRANSPORT_RET_OR_ADV_POS
	     OR #DRV_REMOTE_SEQ.IN.HMI_BUTTON_DEV_RET
	     OR #DRV_REMOTE_SEQ.IN.HMI_BUTTON_DEV_CEN
	     OR #DRV_REMOTE_SEQ.IN.HMI_BUTTON_DEV_ADV
	     OR #DRV_REMOTE_SEQ.IN.HMI_BUTTON_DEV_LOADING
	     OR #DRV_REMOTE_SEQ.IN.HMI_BUTTON_DEV_UNLOADING
	 THEN
	     IF NOT #DEV_01.ACTUATOR_SELECT THEN
	         #HMI.IN.SELECT := TRUE;
	     END_IF;
	 END_IF;
	 
	 #DEV_01_FB(SELECTED => #DEV_01.ACTUATOR_SELECT,
	            MAN_ADV => #temp_button_ADV,
	            MAN_RET => #temp_button_RET,
	            FG := #fg,
	            GLOB := #GLOB,
	            GROUP := #DEV_01.GROUP,
	            HMI_SELECT := #HMI.IN.SELECT,
	            HMI_BUTTON_ADV := #HMI.IN.BUTTON_ADV,
	            HMI_BUTTON_RET := #HMI.IN.BUTTON_RET,
	            HMI_REVERSE := #HMI.IN.REVERSE
	 );
	 
	 // Taste aus HMI ADV / RET / CENT
	 #DEV_01.BUTTON_ADV := #temp_button_ADV OR (#DEV_01.ACTUATOR_SELECT AND #DRV_REMOTE_SEQ.IN.COMMAND_EXTERNAL AND #DRV_REMOTE_SEQ.IN.HMI_BUTTON_DEV_ADV);
	 #DEV_01.BUTTON_RET := #temp_button_RET OR (#DEV_01.ACTUATOR_SELECT AND #DRV_REMOTE_SEQ.IN.COMMAND_EXTERNAL AND #DRV_REMOTE_SEQ.IN.HMI_BUTTON_DEV_RET);
	 
	 // Taste aus HMI Schnell langsam
	 IF #DRV_REMOTE_SEQ.IN.COMMAND_EXTERNAL THEN
	     IF #DRV_REMOTE_SEQ.IN.HMI_BUTTON_SLOW_SELECTED THEN
	         #DRV_REMOTE_SEQ.IN.HMI_BUTTON_SLOW_SELECTED := FALSE;
	         IF #HMI.IN.button_slowly THEN
	             #HMI.IN.button_slowly := FALSE;
	         ELSE
	             #HMI.IN.button_slowly := TRUE;
	         END_IF;
	     END_IF;
	 END_IF;
	 
	 // ==========================================================================================================================
	 // ==========================================================================================================================
	 // Ablauf
	 // ==========================================================================================================================
	 // ==========================================================================================================================
	 // ------------------------------------------------------------
	 // Transport endet mit erreichen ( Stop Position oder Umschaltung V2/V1 )
	 // ------------------------------------------------------------
	 // RET
	 #Transport_retracted_ends_with_fs_pos_RET := #NUMBER_OF_SPEEDS = 2 AND (#CONF.TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_RET OR #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET);
	 // ADV
	 #Transport_retracted_ends_with_fs_pos_ADV := #NUMBER_OF_SPEEDS = 2 AND (#CONF.TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_ADV OR #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV);
	 
	 // ------------------------------------------------------------
	 //  mein Shuttle ist angekommen in RET /ADV
	 //-------------------------------------------------------------
	 #RET_my_Shuttle_Stop := #x_SEQ_RETxxx.Status_new_component_retracted_xxx OR (#RET_Version = 0 AND #x_SEQ_RET.STATUS_OCCUPIED);
	 #ADV_my_Shuttle_Stop := #x_SEQ_ADVxxx.Status_new_component_retracted_xxx OR (#ADV_Version = 0 AND #x_SEQ_ADV.STATUS_OCCUPIED);
	 
	 #NEW_SHUTTLE_STOP_IN_FS_RET := #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET AND #REM.NEW_COMPONENT_RETRACTED_RET;
	 #NEW_SHUTTLE_STOP_IN_FS_ADV := #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV AND #REM.NEW_COMPONENT_RETRACTED_ADV;
	 // ------------------------------------------------------------
	 //  Auto New Shuttle Stopen
	 // -----------------------------------------------------------
	 IF #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET AND #REM.NEW_COMPONENT_RETRACTED_RET AND #x_B_pos_RET THEN
	     #NEW_SHUTTLE_STOP_IN_POS_RET := TRUE;
	 END_IF;
	 
	 IF NOT #REM.Wegmerker_RET AND #x_B_pos_RET OR #M.reset_POS THEN
	     #NEW_SHUTTLE_STOP_IN_POS_RET := FALSE;
	 END_IF;
	 
	 IF #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV AND #REM.NEW_COMPONENT_RETRACTED_ADV AND #x_B_pos_ADV THEN
	     #NEW_SHUTTLE_STOP_IN_POS_ADV := TRUE;
	 END_IF;
	 IF NOT #REM.Wegmerker_ADV AND #x_B_pos_ADV OR #M.reset_POS THEN
	     #NEW_SHUTTLE_STOP_IN_POS_ADV := FALSE;
	 END_IF;
	 
	 // ------------------------------------------------------------
	 // RET : Shuttle Betrieb neu Fahrzeug kommt Strecke
	 // ------------------------------------------------------------
	 #x_B_NEW_COMPONENT_RETRACTE_RET :=
	 (
	 ((#NUMBER_OF_SPEEDS = 1 OR NOT #Transport_retracted_ends_with_fs_pos_RET) AND #x_B_pos_RET)
	 OR
	 (#NUMBER_OF_SPEEDS = 2 AND #x_B_fs_RET AND #Transport_retracted_ends_with_fs_pos_RET)
	 )
	 AND ((#CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET AND #IN_BG04_SHUTTLE_IN_RET) OR NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET)
	 ;
	 #x_B_NEW_COMPONENT_RETRACTE_RET_POS := #x_B_NEW_COMPONENT_RETRACTE_RET AND NOT #REM.x_B_SHUTTLE_IN_RET_PHM;
	 #REM.x_B_SHUTTLE_IN_RET_PHM := #x_B_NEW_COMPONENT_RETRACTE_RET;
	 #x_B_NEW_COMPONENT_RETRACTE_RET_NEG := NOT #x_B_NEW_COMPONENT_RETRACTE_RET AND NOT #REM.x_B_SHUTTLE_IN_RET_NHM;
	 #REM.x_B_SHUTTLE_IN_RET_NHM := NOT #x_B_NEW_COMPONENT_RETRACTE_RET;
	 
	 IF (#x_B_NEW_COMPONENT_RETRACTE_RET_NEG AND #M.CONTROL_ADV_TIME) OR (#x_B_pos_RET AND #M.CONTROL_RET_TIME) THEN
	     #REM.NEW_COMPONENT_RETRACTED_RET := FALSE;
	 END_IF;
	 
	 IF (#x_B_NEW_COMPONENT_RETRACTE_RET_POS AND #M.CONTROL_RET_TIME) OR (#x_B_NEW_COMPONENT_RETRACTE_RET AND #M.reset_POS) THEN
	     #REM.NEW_COMPONENT_RETRACTED_RET := TRUE;
	 END_IF;
	 
	 //---------------------------------------------------
	 // ADV : Shuttle Betrieb neu Fahrzeug kommt Strecke
	 // -----------------------------------------------------------
	 #x_B_NEW_COMPONENT_RETRACTE_ADV :=
	 (
	 ((#NUMBER_OF_SPEEDS = 1 OR NOT #Transport_retracted_ends_with_fs_pos_ADV) AND #x_B_pos_ADV)
	 OR
	 (#NUMBER_OF_SPEEDS = 2 AND #x_B_fs_ADV AND #Transport_retracted_ends_with_fs_pos_ADV)
	 )
	 
	 AND ((#CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV AND #IN_BG05_SHUTTLE_IN_ADV) OR NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV)
	 ;
	 #x_B_NEW_COMPONENT_RETRACTE_ADV_POS := #x_B_NEW_COMPONENT_RETRACTE_ADV AND NOT #REM.x_B_SHUTTLE_IN_ADV_PHM;
	 #REM.x_B_SHUTTLE_IN_ADV_PHM := #x_B_NEW_COMPONENT_RETRACTE_ADV;
	 #x_B_NEW_COMPONENT_RETRACTE_ADV_NEG := NOT #x_B_NEW_COMPONENT_RETRACTE_ADV AND NOT #REM.x_B_SHUTTLE_IN_ADV_NHM;
	 #REM.x_B_SHUTTLE_IN_ADV_NHM := NOT #x_B_NEW_COMPONENT_RETRACTE_ADV;
	 
	 IF (#x_B_NEW_COMPONENT_RETRACTE_ADV_NEG AND #M.CONTROL_RET_TIME) OR (#x_B_pos_ADV AND #M.CONTROL_ADV_TIME) THEN
	     #REM.NEW_COMPONENT_RETRACTED_ADV := FALSE;
	 END_IF;
	 
	 IF (#x_B_NEW_COMPONENT_RETRACTE_ADV_POS AND #M.CONTROL_ADV_TIME) OR (#x_B_NEW_COMPONENT_RETRACTE_ADV AND #M.reset_POS) THEN
	     #REM.NEW_COMPONENT_RETRACTED_ADV := TRUE;
	 END_IF;
	 
	 // ------------------------------------------------------------
	 // Anwahl Überfördern 
	 // ------------------------------------------------------------
	 IF NOT #manual OR NOT #DEV_01.ACTUATOR_SELECT THEN
	     #HMI.IN.button_transport_RET := false;
	     #HMI.IN.button_transport_ADV := false;
	 END_IF;
	 
	 #M.Anwahl_Ueberfoerdern_RET := #HMI.IN.button_transport_RET AND NOT #HMI.IN.button_transport_ADV;
	 #M.Anwahl_Ueberfoerdern_ADV := #HMI.IN.button_transport_ADV AND NOT #HMI.IN.button_transport_RET;
	 
	 // ------------------------------------------------------------
	 //  Wegmerker Seite RET
	 // ------------------------------------------------------------
	 // ###WJ##
	 // IF (#POSITION_EXISTS_RET AND #x_B_pos_RET_NEG AND #M.CONTROL_RET_TIME AND #SEQ_RET_CONNECTED)
	 IF (#POSITION_EXISTS_RET AND #x_B_pos_RET_NEG AND #CONTROL_RET AND #SEQ_RET_CONNECTED)
	     OR (NOT #POSITION_EXISTS_RET AND #CONF.DRIVE_RIDE_RET_IN_AUTOMATIC AND #x_B_pos_ADV_NEG AND #M.CONTROL_RET_TIME AND #SEQ_RET_CONNECTED)
	 THEN
	     #REM.Wegmerker_RET := True;
	 END_IF;
	 
	 IF #RET_my_Shuttle_Stop THEN
	     #REM.Wegmerker_RET := false;
	 END_IF;
	 
	 // Negativ
	 #REM.Wegmerker_RET_NEG := NOT #REM.Wegmerker_RET AND NOT #REM.Wegmerker_RET_NHM AND NOT #GLOB.SYS.FirstScan AND NOT #INIT_EDGE_POS;
	 #REM.Wegmerker_RET_NHM := NOT #REM.Wegmerker_RET;
	 // ------------------------------------------------------------
	 // Wegmerker Seite ADV
	 // -----------------------------------------------------------
	 // ###WJ##
	 // IF #x_B_pos_ADV_NEG AND #M.CONTROL_ADV_TIME AND #SEQ_ADV_CONNECTED THEN
	 IF #x_B_pos_ADV_NEG AND #CONTROL_ADV AND #SEQ_ADV_CONNECTED THEN
	     #REM.Wegmerker_ADV := True;
	 END_IF;
	 
	 IF #ADV_my_Shuttle_Stop THEN
	     #REM.Wegmerker_ADV := false;
	 END_IF;
	 // Negativ
	 #REM.Wegmerker_ADV_NEG := NOT #REM.Wegmerker_ADV AND NOT #REM.Wegmerker_ADV_NHM AND NOT #GLOB.SYS.FirstScan AND NOT #INIT_EDGE_POS;
	 #REM.Wegmerker_ADV_NHM := NOT #REM.Wegmerker_ADV;
	 
	 // ------------------------------------------------------------------------------
	 //  Belegt
	 // ------------------------------------------------------------------------------
	 // ------------------------------------------------------------
	 //  Belegt extern : Set / Reset
	 // ------------------------------------------------------------
	 #M.occupied_set_POS := (#OCCUPIED_SET OR #SEQ.STATUS_EXTERN_OCCUPIED_SET) AND NOT #M.occupied_set_PHM;
	 #M.occupied_set_PHM := #OCCUPIED_SET OR #SEQ.STATUS_EXTERN_OCCUPIED_SET;
	 
	 IF #M.occupied_set_POS THEN
	     #REM.Belegt := true;
	     IF #EXISTS_TRAVERSE AND NOT #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET AND NOT #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV THEN
	         #REM.Belegt_Lacktraversen := true;
	     END_IF;
	 END_IF;
	 
	 #M.occupied_reset_POS := (#OCCUPIED_RESET OR #SEQ.STATUS_EXTERN_OCCUPIED_RESET) AND NOT #M.occupied_reset_PHM;
	 #M.occupied_reset_PHM := #OCCUPIED_RESET OR #SEQ.STATUS_EXTERN_OCCUPIED_RESET;
	 
	 IF #M.occupied_reset_POS THEN
	     #REM.Belegt := false;
	     #REM.Belegt_Lacktraversen := false;
	 END_IF;
	 
	 // -------------------------------------------
	 // Belegt Manipulieren / occupied manipulation
	 // -------------------------------------------
	 #M.button_invert_occupied_POS := #HMI.IN.button_invert_occupied AND NOT #Error.Error_Occupied_Check AND NOT #M.button_invert_occupied_PHM;
	 #M.button_invert_occupied_PHM := #HMI.IN.button_invert_occupied AND NOT #Error.Error_Occupied_Check;
	 #HMI.IN.button_invert_occupied := false;
	 IF #M.button_invert_occupied_POS THEN
	     IF #REM.Belegt THEN
	         #REM.Belegt := false;
	         #REM.Belegt_Lacktraversen := false;
	     ELSE
	         #REM.Belegt := true;
	         IF #EXISTS_TRAVERSE AND NOT #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET AND NOT #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV THEN
	             #REM.Belegt_Lacktraversen := true;
	         END_IF;
	     END_IF;
	 END_IF;
	 
	 // ------------------------------------------------------------
	 // Belegt
	 // ------------------------------------------------------------
	 #HM_TYPE_SHIFT_EDGE_IN_RET :=
	 #x_B_pos_RET AND #M.CONTROL_RET_TIME
	 AND NOT #M.Anwahl_Ueberfoerdern_RET AND NOT #M.Anwahl_Ueberfoerdern_ADV
	 AND NOT #M.Ausfoerdern_RET AND NOT #M.Ausfoerdern_ADV
	 ;
	 #HM_TYPE_SHIFT_EDGE_IN_ADV :=
	 #x_B_pos_ADV AND #M.CONTROL_ADV_TIME
	 AND NOT #M.Anwahl_Ueberfoerdern_RET AND NOT #M.Anwahl_Ueberfoerdern_ADV
	 AND NOT #M.Ausfoerdern_RET AND NOT #M.Ausfoerdern_ADV
	 ;
	 
	 IF #HM_TYPE_SHIFT_EDGE_IN_RET
	     OR #HM_TYPE_SHIFT_EDGE_IN_ADV
	     OR (#x_B_pos_RET AND (#manual OR #Reset_External) AND #M.reset_POS)
	     OR (#x_B_pos_ADV AND (#manual OR #Reset_External) AND #M.reset_POS)
	     OR (#M.occupied_set_POS)
	 THEN
	     #REM.Belegt := true;
	     
	 END_IF;
	 
	 // Belegt Positiv / Negativ
	 // ---------------
	 #M.Belegt_POS := #REM.Belegt AND NOT #M.Belegt_PHM;
	 #M.Belegt_PHM := #REM.Belegt;
	 #M.Belegt_NEG := NOT #REM.Belegt AND NOT #M.Belegt_NHM;
	 #M.Belegt_NHM := NOT #REM.Belegt;
	 // ------------------------------------------------------------
	 // nicht Belegt
	 // ------------------------------------------------------------
	 #M.Belegt_Reset_HM := NOT #REM.Wegmerker_RET AND NOT #REM.Wegmerker_ADV;
	 #M.Belegt_Reset_HM_POS := #M.Belegt_Reset_HM AND NOT #M.Belegt_Reset_HM_PHM AND NOT #GLOB.SYS.FirstScan AND NOT #INIT_EDGE_POS;
	 #M.Belegt_Reset_HM_PHM := #M.Belegt_Reset_HM;
	 
	 IF #M.Belegt_Reset_HM_POS
	     AND NOT #x_B_pos_ADV
	     AND NOT #x_B_fs_ADV
	     AND NOT #x_B_pos_RET
	     AND NOT #x_B_fs_RET
	 THEN
	     #REM.Belegt := false;
	 END_IF;
	 
	 // ------------------------------------------------------------
	 // Lacktraversen / Pain Bar
	 // ------------------------------------------------------------
	 // Belegt wegen Lacktraversen (bei der Ausfördern / Überfördern)
	 IF #EXISTS_TRAVERSE THEN
	     // Lacktraversen setzen
	     IF (#x_B_pos_RET_POS AND #M.CONTROL_RET_TIME AND #REM.Belegt)
	         OR (#x_B_pos_ADV_POS AND #M.CONTROL_ADV_TIME AND #REM.Belegt)
	         OR (#x_B_pos_RET AND (#manual OR #Reset_External) AND #M.reset_POS)
	         OR (#x_B_pos_ADV AND (#manual OR #Reset_External) AND #M.reset_POS)
	     THEN
	         #REM.Belegt_Lacktraversen := true;
	     END_IF;
	     IF (#x_B_pos_RET_NEG AND #M.CONTROL_ADV_TIME AND NOT #REM.Wegmerker_RET AND #manual)
	         OR (#x_B_pos_ADV_NEG AND #M.CONTROL_RET_TIME AND NOT #REM.Wegmerker_ADV AND #manual)
	         //  OR #REM.NEW_COMPONENT_RETRACTED_RET
	         //  OR #REM.NEW_COMPONENT_RETRACTED_ADV
	     THEN
	         #REM.Belegt_Lacktraversen := FALSE;
	     END_IF;
	     
	     // Lacktraversen löschen
	     IF (#REM.Wegmerker_ADV_NEG AND #M.CONTROL_ADV_TIME) OR (#REM.Wegmerker_RET_NEG AND #M.CONTROL_RET_TIME) THEN
	         #REM.Belegt_Lacktraversen := FALSE;
	     END_IF;
	     
	     
	 ELSE
	     #REM.Belegt_Lacktraversen := false;
	 END_IF;
	 
	 // ------------------------------------------------------------
	 //  Leer / EMPTY 
	 // ------------------------------------------------------------
	 #M.EMPTY :=
	 NOT #x_B_pos_RET
	 AND NOT #x_B_fs_RET
	 AND NOT #x_B_fs_ADV
	 AND NOT #x_B_pos_ADV
	 AND NOT #M.Ausfoerdern_RET
	 AND NOT #M.Ausfoerdern_ADV
	 AND NOT #M.Auto_Einfoerdern_new_Component_RET
	 AND NOT #M.Auto_Einfoerdern_new_Component_ADV
	 AND NOT #M.slowly_RET_Save
	 AND NOT #M.slowly_ADV_Save
	 AND NOT #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET
	 AND NOT #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV
	 AND NOT #REM.Belegt
	 ;
	 
	 // ==========================================================================================================================
	 // Typen schieben Extern
	 // ==========================================================================================================================
	 // ------------------------------------------------------------
	 //  Meine typen wurde geschoben (Reinkopiert)
	 // ------------------------------------------------------------
	 IF (#SEQ.STATUS_TYPE_NEW <> 0 OR #SEQ.STATUS_TYPE_ASC_NEW <> '') AND (#SEQ.STATUS_TYPE = 0 AND #SEQ.STATUS_TYPE_ASC = '') THEN
	     #SEQ.STATUS_TYPE := #SEQ.STATUS_TYPE_NEW;
	     #SEQ.STATUS_TYPE_ASC := #SEQ.STATUS_TYPE_ASC_NEW;
	     #SEQ.STATUS_TYPE_NEW := 0;
	     #SEQ.STATUS_TYPE_ASC_NEW := '';
	 END_IF;
	 // ------------------------------------------------------------
	 IF #SEQ.STATUS_TYPE_UNIT_NEW.REFERENZ <> 0 THEN
	     // Auch der in Zwischenpuufer gehaltene Type muss Online existieren sonst (Typfach Fehler)
	     // Wenn Fach duch Type Deco aufgerufen ist das fach noch leer . duch Copy wird es Belegt ,  (Daher "DATA_EXIST" + "DATA_EXIST_ONLINE" setzen) 
	     IF #TYPE_DATA_CTRL.DATA[#SEQ.STATUS_TYPE_UNIT_NEW.REFERENZ].DATA_EXIST_ONLINE THEN
	         ;
	     ELSE
	         #TYPE_DATA_CTRL.DATA[#SEQ.STATUS_TYPE_UNIT_NEW.REFERENZ].DATA_EXIST_ONLINE := TRUE;
	         #TYPE_DATA_CTRL.DATA[#SEQ.STATUS_TYPE_UNIT_NEW.REFERENZ].DATA_EXIST := TRUE;
	     END_IF;
	     // Esrt schieben wenn Fach frei ist     
	     IF #UNIT.REFERENZ = 0 THEN
	         #UNIT := #SEQ.STATUS_TYPE_UNIT_NEW;
	         #SEQ.STATUS_TYPE_UNIT_NEW.REFERENZ := 0;
	         #SEQ.STATUS_TYPE_UNIT_NEW.RESTORE := FALSE;
	         #SEQ.STATUS_TYPE_UNIT_NEW.ERROR_TYPE := FALSE;
	     END_IF;
	     
	 END_IF;
	 
	 // ==========================================================================================================================
	 //  Typen Löschen nur REFERENZ
	 // ==========================================================================================================================
	 IF #M.occupied_reset_POS AND NOT #REM.Belegt AND NOT #M.Ausfoerdern_RET AND NOT #M.Ausfoerdern_ADV THEN
	     #SEQ.STATUS_TYPE := 0;
	     #SEQ.STATUS_TYPE_ASC := '';
	     
	     #UNIT.REFERENZ := 0;
	     #UNIT.RESTORE := FALSE;
	     #UNIT.ERROR_TYPE := FALSE;
	 END_IF;
	 
	 //----------------------------------------------------------------------------------------------------------------------------
	 //  Type
	 //----------------------------------------------------------------------------------------------------------------------------
	 #SEQ.STATUS_TYPE_UNIT := #UNIT;
	 // Referenz auf Datensatz Merken
	 #TEMP_UNIT_REFERENZ := #UNIT.REFERENZ;
	 //-------------------------------------------------------------
	 // Typen aus Type DB rausholen
	 //-------------------------------------------------------------
	 #SEQ.STATUS_TYPE_TYPE_NR := #TYPE_DATA_CTRL.DATA[#UNIT.REFERENZ].TYPE_NR;
	 //----------------------------------------------------------------------------------------------------------------------------
	 //  Typen schieben Intern POS => RET
	 //----------------------------------------------------------------------------------------------------------------------------
	 #SEQ.STATUS_TYPE_SHIFT_EDGE_OUT_RET := #REM.Wegmerker_RET_NEG AND NOT #M.reset_POS;
	 
	 IF #SEQ.STATUS_TYPE_SHIFT_EDGE_OUT_RET THEN
	     #x_SEQ_RET.STATUS_TYPE_TYPE_NR_NEW := #SEQ.STATUS_TYPE_TYPE_NR;
	     #x_SEQ_RET.STATUS_TYPE_NEW := #SEQ.STATUS_TYPE;
	     #x_SEQ_RET.STATUS_TYPE_ASC_NEW := #SEQ.STATUS_TYPE_ASC;
	     
	     #SEQ.STATUS_TYPE_TYPE_NR := 0;
	     #SEQ.STATUS_TYPE := 0;
	     #SEQ.STATUS_TYPE_ASC := '';
	     // -----------------------------------------
	     #x_SEQ_RET.STATUS_TYPE_UNIT_NEW := #SEQ.STATUS_TYPE_UNIT;
	     #UNIT.REFERENZ := 0;
	     #UNIT.ERROR_TYPE := FALSE;
	     #UNIT.RESTORE := FALSE;
	     
	 END_IF;
	 //----------------------------------------------------------------------------------------------------------------------------
	 //  Typen schieben Intern POS => ADV
	 //----------------------------------------------------------------------------------------------------------------------------
	 #SEQ.STATUS_TYPE_SHIFT_EDGE_OUT_ADV := #REM.Wegmerker_ADV_NEG AND NOT #M.reset_POS;
	 
	 IF #SEQ.STATUS_TYPE_SHIFT_EDGE_OUT_ADV THEN
	     
	     #x_SEQ_ADV.STATUS_TYPE_TYPE_NR_NEW := #SEQ.STATUS_TYPE_TYPE_NR;
	     #x_SEQ_ADV.STATUS_TYPE_NEW := #SEQ.STATUS_TYPE;
	     #x_SEQ_ADV.STATUS_TYPE_ASC_NEW := #SEQ.STATUS_TYPE_ASC;
	     
	     #SEQ.STATUS_TYPE_TYPE_NR := 0;
	     #SEQ.STATUS_TYPE := 0;
	     #SEQ.STATUS_TYPE_ASC := '';
	     // -----------------------------------------
	     #x_SEQ_ADV.STATUS_TYPE_UNIT_NEW := #SEQ.STATUS_TYPE_UNIT;
	     #UNIT.REFERENZ := 0;
	     #UNIT.ERROR_TYPE := FALSE;
	     #UNIT.RESTORE := FALSE;
	     
	 END_IF;
	 
	 //--------------------------------------------------------------------------
	 // Auch der in Zwischenpuufer gehaltene Type muss Online existieren sonst (Typfach Fehler)
	 // Wenn Fach duch Type Deco aufgerufen ist das fach noch Belegt , duch das loeschen wird es nicht mehr Belegt (Daher "DATA_EXIST" + "DATA_EXIST_ONLINE" rucksetzen) 
	 //--------------------------------------------------------------------------
	 IF #TEMP_UNIT_REFERENZ > 0 AND (#SEQ.STATUS_TYPE_SHIFT_EDGE_OUT_RET OR #SEQ.STATUS_TYPE_SHIFT_EDGE_OUT_ADV) THEN
	     IF #TYPE_DATA_CTRL.DATA[#TEMP_UNIT_REFERENZ].DATA_EXIST_ONLINE THEN
	         #TYPE_DATA_CTRL.DATA[#TEMP_UNIT_REFERENZ].DATA_EXIST_ONLINE := FALSE;
	         //##WJ## 09.01.2019  #TYPE_DATA_CTRL.DATA[#TEMP_UNIT_REFERENZ].DATA_EXIST := FALSE;
	     END_IF;
	 END_IF;
	 
	 //----------------------------------------------------------------------------------------------------------------------------
	 //  Typen Löschen
	 //----------------------------------------------------------------------------------------------------------------------------
	 #TYPE_DELETE_SEQ.DELETE := #M.reset_POS AND NOT #REM.Belegt AND NOT #M.Ausfoerdern_RET AND NOT #M.Ausfoerdern_ADV AND #CONF.ENABLE_TYPE_DELETE AND NOT #INIT_EDGE_POS;
	 
	 IF #TYPE_DELETE_SEQ.DELETE THEN
	     #SEQ.STATUS_TYPE := 0;
	     #SEQ.STATUS_TYPE_ASC := '';
	 END_IF;
	 
	 #TYPE_DELETE(DIAG => #DIAG_TEMP.TYPE_DELETE,
	              UNIT := #UNIT,
	              SEQ := #TYPE_DELETE_SEQ,
	              GLOB_DB := #GLOB,
	              TYPE_GLOB_DB := #TYPE_GLOB,
	              TYPE_DATA_CTRL_DB := #TYPE_DATA_CTRL);
	 
	 // ------------------------------------------------------------
	 //  Typen Intern Eingabe über HMI
	 // ------------------------------------------------------------
	 // TYPE
	 IF #SEQ.STATUS_TYPE <> #M.STATUS_TYPE THEN
	     // #HMI.OUT.SEQ.STATUS_TYPE := #SEQ.STATUS_TYPE;
	     ;
	 ELSE
	     IF #HMI.OUT.SEQ.STATUS_TYPE <> #M.HMI_TYPE THEN
	         #SEQ.STATUS_TYPE := #HMI.OUT.SEQ.STATUS_TYPE;
	     END_IF;
	 END_IF;
	 
	 //  Typen Intern  TYPE_ASC
	 IF #SEQ.STATUS_TYPE_ASC <> #M.STATUS_TYPE_ASC THEN
	     // #HMI.OUT.SEQ.STATUS_TYPE_ASC := #SEQ.STATUS_TYPE_ASC;
	     ;
	 ELSE
	     IF #HMI.OUT.SEQ.STATUS_TYPE_ASC <> #M.HMI_TYPE_ASC THEN
	         #SEQ.STATUS_TYPE_ASC := #HMI.OUT.SEQ.STATUS_TYPE_ASC;
	     END_IF;
	 END_IF;
	 
	 #M.STATUS_TYPE := #SEQ.STATUS_TYPE;
	 #M.HMI_TYPE := #HMI.OUT.SEQ.STATUS_TYPE;
	 #M.STATUS_TYPE_ASC := #SEQ.STATUS_TYPE_ASC;
	 #M.HMI_TYPE_ASC := #HMI.OUT.SEQ.STATUS_TYPE_ASC;
	 
	 // ==========================================================================================================================
	 // Ausgabe
	 // ==========================================================================================================================
	 // --------------------------------------------------------------------------------------------------------
	 // Anlaufwarnung
	 // --------------------------------------------------------------------------------------------------------
	 #START_UP_WARNING_READY_TO_START :=
	 (#automatic AND (#M.control_2_RET OR #M.control_2_ADV))
	 OR
	 (
	 NOT #M.Auto_Einfoerdern_RET
	 AND NOT #M.Auto_Einfoerdern_ADV
	 AND NOT #NEW_SHUTTLE_STOP_IN_FS_ADV
	 AND NOT #NEW_SHUTTLE_STOP_IN_FS_ADV
	 AND (NOT #M.Auto_Ausfoerdern_HM_RET OR #NEW_SHUTTLE_STOP_IN_POS_RET)
	 AND (NOT #M.Auto_Ausfoerdern_HM_ADV OR #NEW_SHUTTLE_STOP_IN_POS_ADV)
	 AND (NOT #M.Ausfoerdern_RET OR #NEW_SHUTTLE_STOP_IN_POS_RET)
	 AND (NOT #M.Ausfoerdern_ADV OR #NEW_SHUTTLE_STOP_IN_POS_ADV)
	 )
	 ;
	 
	 #Start_up_warning_releas_to_start_RET := NOT #CONF.ENABLE_START_UP_WARNING_FUNCTION OR #manual OR #START_UP_WARNING_RELEASE_TO_START;
	 #Start_up_Warning_releas_to_start_ADV := NOT #CONF.ENABLE_START_UP_WARNING_FUNCTION OR #manual OR #START_UP_WARNING_RELEASE_TO_START;
	 
	 // ------------------------------------------------------------
	 //  bei Belegtmeldung automatisch vorfahren bis Endlage RET
	 // ------------------------------------------------------------
	 IF #PERIPHERI_OK AND #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET AND #POSITION_EXISTS_RET
	     AND (#M.occupied_set_POS OR #M.button_invert_occupied_POS AND #REM.Belegt)
	 THEN
	     #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET := TRUE;
	 END_IF;
	 IF #x_B_pos_RET OR NOT #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET OR NOT #REM.Belegt THEN
	     #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET := FALSE;
	 END_IF;
	 // ------------------------------------------------------------
	 //  bei Belegtmeldung automatisch vorfahren bis Endlage ADV
	 // ------------------------------------------------------------
	 IF #PERIPHERI_OK AND #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV
	     AND (#M.occupied_set_POS OR #M.button_invert_occupied_POS AND #REM.Belegt)
	 THEN
	     #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV := TRUE;
	 END_IF;
	 IF #x_B_pos_ADV OR NOT #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV OR NOT #REM.Belegt THEN
	     #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV := FALSE;
	 END_IF;
	 
	 // ------------------------------------------------------------
	 //  Auto Ausfördern Transport RET HM
	 // ------------------------------------------------------------
	 #M.Auto_Ausfoerdern_HM_RET :=
	 #automatic
	 // AND NOT #fg.OUT.RUN_EMPTY_MODE_ACTIVE
	 AND NOT #seoc            // Halt nach Taktende
	 AND NOT #controlled_stop // Controlled Stop
	 AND #x_SEQ_RET.STATUS_AUTOMATIC
	 AND #x_SEQ_RETxxx.Status_Bereit_Einf_xxx
	 AND NOT #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET
	 AND NOT #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV
	 AND #START_TRANSPORT_RET
	 AND NOT #START_TRANSPORT_ADV
	 AND (NOT #Error.Typedaten_nicht_plausible_oder_leer OR #CONF.TYPE_RELEASE_PART_NO_CHECK)
	 AND #REM.Belegt
	 AND (#x_B_pos_RET OR #x_B_pos_ADV)
	 AND NOT #NEW_SHUTTLE_STOP_IN_POS_RET
	 AND NOT #NEW_SHUTTLE_STOP_IN_POS_ADV
	 AND NOT #RET_my_Shuttle_Stop
	 // AND NOT #ADV_my_Shuttle_Stop
	 ;
	 // ------------------------------------------------------------
	 //  Auto Ausfördern Transport ADV HM
	 // ------------------------------------------------------------
	 #M.Auto_Ausfoerdern_HM_ADV :=
	 #automatic
	 // AND NOT #fg.OUT.RUN_EMPTY_MODE_ACTIVE
	 AND NOT #seoc            // Halt nach Taktende
	 AND NOT #controlled_stop // Controlled Stop
	 AND #x_SEQ_ADV.STATUS_AUTOMATIC
	 AND #x_SEQ_ADVxxx.Status_Bereit_Einf_xxx
	 AND NOT #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET
	 AND NOT #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV
	 AND NOT #START_TRANSPORT_RET
	 AND #START_TRANSPORT_ADV
	 AND (NOT #Error.Typedaten_nicht_plausible_oder_leer OR #CONF.TYPE_RELEASE_PART_NO_CHECK)
	 AND #REM.Belegt
	 AND (#x_B_pos_RET OR #x_B_pos_ADV)
	 AND NOT #NEW_SHUTTLE_STOP_IN_POS_RET
	 AND NOT #NEW_SHUTTLE_STOP_IN_POS_ADV
	 // AND NOT #RET_my_Shuttle_Stop
	 AND NOT #ADV_my_Shuttle_Stop
	 ;
	 // ------------------------------------------------------------
	 //  Ausfördern Transport (Wegemerker)
	 // ------------------------------------------------------------ 
	 #M.Ausfoerdern_RET := #M.Ausfoerdern_RET;
	 #M.Ausfoerdern_ADV := #M.Ausfoerdern_ADV;
	 
	 IF (#M.Auto_Ausfoerdern_HM_RET AND #M.si_interlocking_transport_ret)
	     OR (
	     #REM.Wegmerker_RET
	     AND (NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV OR (NOT #NEW_SHUTTLE_STOP_IN_POS_RET AND NOT #REM.NEW_COMPONENT_RETRACTED_RET))
	     )
	 THEN
	     #M.Ausfoerdern_RET := true;
	 END_IF;
	 
	 IF #RET_my_Shuttle_Stop OR #Error.Typedaten_nicht_plausible_oder_leer THEN
	     #M.Ausfoerdern_RET := FALSE;
	 END_IF;
	 
	 IF (#M.Auto_Ausfoerdern_HM_ADV AND #M.si_interlocking_transport_adv)
	     OR (
	     #REM.Wegmerker_ADV
	     AND (NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV OR (NOT #NEW_SHUTTLE_STOP_IN_POS_ADV AND NOT #REM.NEW_COMPONENT_RETRACTED_ADV))
	     )
	 THEN
	     #M.Ausfoerdern_ADV := true;
	 END_IF;
	 IF #ADV_my_Shuttle_Stop OR #Error.Typedaten_nicht_plausible_oder_leer THEN
	     #M.Ausfoerdern_ADV := FALSE;
	 END_IF;
	 
	 // ------------------------------------------------------------
	 //  Auto Einfördern neue Bauteil V2->V1
	 // ------------------------------------------------------------ 
	 #M.Auto_Einfoerdern_new_Component_RET := #automatic AND #REM.NEW_COMPONENT_RETRACTED_RET;
	 #M.Auto_Einfoerdern_new_Component_ADV := #automatic AND #REM.NEW_COMPONENT_RETRACTED_ADV;
	 
	 // ------------------------------------------------------------
	 //  Auto Einfördern Transport 
	 // ------------------------------------------------------------ 
	 #M.Auto_Einfoerdern_RET := #SEQ_RET.STATUS_AUTOMATIC
	 AND #x_SEQ_RETxxx.Status_Ausfoerdern_xxx AND NOT #x_SEQ_RET.STATUS_DRIVE_ERROR
	 AND #M.si_interlocking_transport_ret
	 AND NOT #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET
	 AND NOT #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV
	 AND NOT #NEW_SHUTTLE_STOP_IN_POS_RET;
	 ;
	 #M.Auto_Einfoerdern_ADV := #SEQ_ADV.STATUS_AUTOMATIC
	 AND #x_SEQ_ADVxxx.Status_Ausfoerdern_xxx AND NOT #x_SEQ_ADV.STATUS_DRIVE_ERROR
	 AND #M.si_interlocking_transport_adv
	 AND NOT #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET
	 AND NOT #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV
	 AND NOT #NEW_SHUTTLE_STOP_IN_POS_ADV;
	 ;
	 
	 // ------------------------------------------------------------
	 //  Auto Durchfahren 
	 // ------------------------------------------------------------ 
	 // RET
	 #M.Auto_Durchfahren_1_RET :=
	 (#CONF.DRIVE_THROUGH_RET AND NOT #seoc AND NOT #controlled_stop)
	 AND NOT #M.Error_no_Anst_RET_ADV
	 AND #x_SEQ_RET.STATUS_AUTOMATIC
	 AND #x_SEQ_ADV.STATUS_AUTOMATIC
	 AND (#M.Auto_Einfoerdern_ADV OR #M.Auto_Einfoerdern_new_Component_RET)
	 AND #x_SEQ_RETxxx.Status_Bereit_Einf_xxx
	 AND (NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET OR (#CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET AND NOT #REM.NEW_COMPONENT_RETRACTED_RET AND #REM.Wegmerker_RET))
	 AND #INTERLOCKING_TRANSPORT_RET
	 AND #START_TRANSPORT_RET
	 ;
	 
	 #M.Auto_Durchfahren_2_RET :=
	 #M.Auto_Durchfahren_1_RET
	 AND #M.slowly_RET_Save
	 ;
	 #M.Auto_Durchfahren_3_RET :=
	 #M.Auto_Durchfahren_1_RET
	 AND #M.Auto_Durchfahren_2_RET
	 AND #x_SEQ_RET.STATUS_DRIVE_RUNNING
	 ;
	 
	 #TIME_DRIVE_THROUGH_RET(IN := #x_SEQ_RET.STATUS_DRIVE_THROUGH_RET,
	                         PT := T#200mS,
	                         Q => #M.Auto_Durchfahren_Nachlauf_RET,
	                         ET => #Temp_Zeitwert);
	 
	 // ADV
	 #M.Auto_Durchfahren_1_ADV :=
	 (#CONF.DRIVE_THROUGH_ADV AND NOT #seoc AND NOT #controlled_stop)
	 AND NOT #M.Error_no_Anst_RET_ADV
	 AND #x_SEQ_RET.STATUS_AUTOMATIC
	 AND #x_SEQ_ADV.STATUS_AUTOMATIC
	 AND (#M.Auto_Einfoerdern_RET OR #M.Auto_Einfoerdern_new_Component_ADV)
	 AND #x_SEQ_ADVxxx.Status_Bereit_Einf_xxx
	 AND (NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV OR (#CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV AND NOT #REM.NEW_COMPONENT_RETRACTED_ADV AND #REM.Wegmerker_ADV))
	 AND #INTERLOCKING_TRANSPORT_ADV
	 AND #START_TRANSPORT_ADV
	 ;
	 
	 #M.Auto_Durchfahren_2_ADV :=
	 #M.Auto_Durchfahren_1_ADV
	 AND #M.slowly_ADV_Save
	 ;
	 
	 #M.Auto_Durchfahren_3_ADV :=
	 #M.Auto_Durchfahren_1_ADV
	 AND #M.Auto_Durchfahren_2_ADV
	 AND #x_SEQ_ADV.STATUS_DRIVE_RUNNING
	 ;
	 
	 #TIME_DRIVE_THROUGH_ADV(IN := #x_SEQ_RET.STATUS_DRIVE_THROUGH_ADV,
	                         PT := T#200mS,
	                         Q => #M.Auto_Durchfahren_Nachlauf_ADV,
	                         ET => #Temp_Zeitwert);
	 // ------------------------------------------------------------
	 //  Hand Ausfördern Transport 
	 // ------------------------------------------------------------
	 // normal
	 #M.Hand_Ueberfoerdern_RET_control_RET := #M.Anwahl_Ueberfoerdern_RET AND #DEV_01.BUTTON_RET AND #M.si_interlocking_transport_ret;
	 #M.Hand_Ueberfoerdern_ADV_control_ADV := #M.Anwahl_Ueberfoerdern_ADV AND #DEV_01.BUTTON_ADV AND #M.si_interlocking_transport_adv;
	 // entgegengesetzt (nur mit Schlüsselschalter)
	 #M.Hand_Ueberfoerdern_RET_control_ADV := #M.Anwahl_Ueberfoerdern_RET AND #DEV_01.BUTTON_ADV AND #M.si_interlocking_transport_ret AND #M.si_service_mode;
	 #M.Hand_Ueberfoerdern_ADV_control_RET := #M.Anwahl_Ueberfoerdern_ADV AND #DEV_01.BUTTON_RET AND #M.si_interlocking_transport_adv AND #M.si_service_mode;
	 // ------------------------------------------------------------
	 //  Hand Einfördern Transport
	 // ------------------------------------------------------------
	 // normal
	 #M.Hand_Einfoerdern_RET_control_ADV := #x_SEQ_RETxxx.Status_Anwahl_Ueberfoerdern_xxx AND #x_SEQ_RETxxx.Status_button_ADV AND #M.si_interlocking_transport_ret;
	 #M.Hand_Einfoerdern_ADV_control_RET := #x_SEQ_ADVxxx.Status_Anwahl_Ueberfoerdern_xxx AND #x_SEQ_ADVxxx.Status_button_RET AND #M.si_interlocking_transport_adv;
	 // entgegengesetzt (nur mit Schlüsselschalter)
	 #M.Hand_Einfoerdern_RET_control_RET := #x_SEQ_RETxxx.Status_Anwahl_Ueberfoerdern_xxx AND #x_SEQ_RETxxx.Status_button_RET AND #M.si_interlocking_transport_ret AND #M.si_service_mode;
	 #M.Hand_Einfoerdern_ADV_control_ADV := #x_SEQ_ADVxxx.Status_Anwahl_Ueberfoerdern_xxx AND #x_SEQ_ADVxxx.Status_button_ADV AND #M.si_interlocking_transport_adv AND #M.si_service_mode;
	 // --------------------------------------------------------------------------------------------------------
	 // Hilfs Merker für Abhängige Überfahren (Geschwindigkeit)
	 // --------------------------------------------------------------------------------------------------------
	 //-------------------------------------------------
	 // Abhängige Überfahren Seite RET oder Seite ADV Master (ausser bei Endschalter überbrücken)) 
	 //-------------------------------------------------
	 // Freigabe von Vorgänger Motor hat keine Fehler
	 // Release of predecessor engine has no errors
	 #Hilfsbit1 :=
	 NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET
	 OR
	 NOT #x_SEQ_ADVxxx.Status_Ausfoerdern_xxx
	 OR
	 (
	 #x_SEQ_ADVxxx.Status_Ausfoerdern_xxx AND NOT #x_SEQ_ADV.STATUS_DRIVE_ERROR AND NOT #NEW_SHUTTLE_STOP_IN_POS_RET
	 );
	 
	 //---------------- RET HM
	 #M.Ausf_RET_Dependent_Drive_2_RET :=
	 (#automatic AND #M.Ausfoerdern_RET AND NOT #RET_my_Shuttle_Stop AND NOT #NEW_SHUTTLE_STOP_IN_POS_RET)
	 OR (#manual AND #M.Hand_Ueberfoerdern_RET_control_RET)
	 ;
	 //---------------- RET
	 #M.Ausf_RET_Dependent_Drive_1_RET := #M.Ausf_RET_Dependent_Drive_2_RET
	 AND
	 (
	 (#automatic AND #x_SEQ_RET.STATUS_DRIVE_RUNNING AND #Hilfsbit1)
	 OR
	 (#manual AND (#x_SEQ_RET.STATUS_DRIVE_RUNNING OR #M.si_endpos_ignored_mode_active))
	 )
	 ;
	 
	 // Freigabe von Vorgänger Motor hat keine Fehler
	 // Release of predecessor engine has no errors
	 #Hilfsbit1 :=
	 NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV
	 OR
	 NOT #x_SEQ_RETxxx.Status_Ausfoerdern_xxx
	 OR
	 (
	 #x_SEQ_RETxxx.Status_Ausfoerdern_xxx AND NOT #x_SEQ_RET.STATUS_DRIVE_ERROR AND NOT #NEW_SHUTTLE_STOP_IN_POS_ADV
	 );
	 
	 //---------------- ADV HM
	 
	 #M.Ausf_ADV_Dependent_Drive_2_ADV :=
	 (#automatic AND #M.Ausfoerdern_ADV AND NOT #ADV_my_Shuttle_Stop AND NOT #NEW_SHUTTLE_STOP_IN_POS_ADV)
	 OR (#manual AND #M.Hand_Ueberfoerdern_ADV_control_ADV)
	 ;
	 //---------------- ADV
	 #M.Ausf_ADV_Dependent_Drive_1_ADV := #M.Ausf_ADV_Dependent_Drive_2_ADV
	 AND
	 (
	 (#automatic AND #x_SEQ_ADV.STATUS_DRIVE_RUNNING AND #Hilfsbit1)
	 OR
	 (#manual AND (#x_SEQ_ADV.STATUS_DRIVE_RUNNING OR #M.si_endpos_ignored_mode_active))
	 )
	 ;
	 
	 #M.Einf_RET_Dependent_Drive_2_RET := #manual AND #M.Hand_Einfoerdern_RET_control_RET;
	 #M.Einf_RET_Dependent_Drive_1_RET := #M.Einf_RET_Dependent_Drive_2_RET AND #x_SEQ_RET.STATUS_DRIVE_RUNNING;
	 
	 #M.Einf_ADV_Dependent_Drive_2_ADV := #manual AND #M.Hand_Einfoerdern_ADV_control_ADV;
	 #M.Einf_ADV_Dependent_Drive_1_ADV := #M.Einf_ADV_Dependent_Drive_2_ADV AND #x_SEQ_ADV.STATUS_DRIVE_RUNNING;
	 //------------------------------------------------- 
	 // ICH Master 
	 //-------------------------------------------------
	 #M.Einf_RET_Anst_ADV := (#automatic AND #M.Auto_Einfoerdern_RET)
	 OR (#manual AND #M.Hand_Einfoerdern_RET_control_ADV)
	 ;
	 #M.Einf_ADV_Anst_RET := (#automatic AND #M.Auto_Einfoerdern_ADV)
	 OR (#manual AND #M.Hand_Einfoerdern_ADV_control_RET)
	 ;
	 // entgegengesetzt (nur mit Schlüsselschalter)
	 #M.Ausf_ADV_Anst_RET := (#manual AND #M.Hand_Ueberfoerdern_ADV_control_RET);
	 #M.Ausf_RET_Anst_ADV := (#manual AND #M.Hand_Ueberfoerdern_RET_control_ADV);
	 
	 // --------------------------------------------------------------------------------------------------------
	 // rück - retract
	 // --------------------------------------------------------------------------------------------------------
	 //-----------------------------------------------------------
	 // Control 1 
	 //-----------------------------------------------------------
	 #M.control_1_RET := #M.Auto_Einfoerdern_new_Component_RET
	 OR #M.Ausf_RET_Dependent_Drive_2_RET
	 OR #M.Einf_RET_Dependent_Drive_2_RET
	 OR #M.Ausf_ADV_Anst_RET
	 OR #M.Einf_ADV_Anst_RET
	 // Vorfahren bei Belegt
	 OR #automatic AND #M.si_interlocking_ret AND #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET
	 // Durchfahren Transport 
	 OR #automatic AND #M.si_interlocking_ret AND #M.si_interlocking_transport_adv AND #M.Auto_Durchfahren_Nachlauf_RET
	 // Hand Normal
	 OR (#manual AND ((NOT #M.Anwahl_Ueberfoerdern_RET AND NOT #M.Anwahl_Ueberfoerdern_ADV AND #DEV_01.BUTTON_RET)))  // Hand Normal
	 ;
	 //-----------------------------------------------------------
	 // Control 2 mit Anlaufwarnug Start
	 //-----------------------------------------------------------
	 #M.control_2_RET := #M.control_1_RET
	 AND (NOT #M.Error_no_Anst_RET_ADV OR #M.si_service_mode)
	 AND (NOT #x_B_pos_RET OR #M.Ausf_RET_Dependent_Drive_2_RET OR #M.si_endpos_ignored_mode_active)
	 AND NOT #M.CONTROL_ADV_TIME
	 AND #M.si_interlocking_ret
	 ;
	 
	 //  Nachlaufzeit bei 0= keine (Endanschlag - Ausrichten)
	 IF #CONF.TIME_FOLLOW_UP_RET <> t#0s THEN
	     #TIME_FOLLOW_UP_RET(IN := #M.control_2_RET,
	                         PT := #CONF.TIME_FOLLOW_UP_RET,
	                         Q => #Hilfsbit1,
	                         ET => #Temp_Zeitwert);
	 ELSE
	     #Hilfsbit1 := false;
	 END_IF;
	 #M.TIME_FOLLOW_UP_RET := #x_B_pos_RET AND NOT #M.control_2_RET AND #Hilfsbit1;
	 
	 //-----------------------------------------------------------
	 // Control 3 mit Abhängigkeiten von vorgeschalteten Motor (Motor läuft nur wenn nachgeschalteten Moto ein)
	 //-----------------------------------------------------------
	 #M.control_3_RET :=
	 ((#POWER_ON AND #M.control_2_RET) OR #M.TIME_FOLLOW_UP_RET)
	 AND
	 (
	 (#M.Ausf_RET_Dependent_Drive_2_RET AND #M.Ausf_RET_Dependent_Drive_1_RET)
	 OR
	 (#M.Einf_RET_Dependent_Drive_2_RET AND #M.Einf_RET_Dependent_Drive_1_RET)
	 OR
	 (NOT #M.Ausf_RET_Dependent_Drive_2_RET AND NOT #M.Einf_RET_Dependent_Drive_2_RET)
	 )
	 ;
	 
	 #CONTROL_RET := #M.control_3_RET AND #Start_up_Warning_releas_to_start_ADV;
	 
	 
	 // Motor ansteuerung nachlauf intern ( Durch die Massenträgheit könnter das Bauteil auf den Geber rauffahren)
	 // Intern nur Diesse Bit abfragen "M.CONTROL_xxx_TIME "
	 #TIME_CONTROL_RET(IN := #CONTROL_RET,
	                   PT := #CONF.TIME_AFTER_RUN_UP_POS_ACTIVE_RET,
	                   Q => #M.CONTROL_RET_TIME,
	                   ET => #Temp_Zeitwert);
	 
	 // --------------------------------------------------------------------------------------------------------
	 // vor - advance
	 // --------------------------------------------------------------------------------------------------------
	 //-----------------------------------------------------------
	 // Control 1 
	 //-----------------------------------------------------------
	 #M.control_1_ADV := #M.Auto_Einfoerdern_new_Component_ADV
	 OR #M.Ausf_ADV_Dependent_Drive_2_ADV
	 OR #M.Einf_ADV_Dependent_Drive_2_ADV
	 OR #M.Ausf_RET_Anst_ADV
	 OR #M.Einf_RET_Anst_ADV
	 // Vorfahren bei Belegt
	 OR #automatic AND #M.si_interlocking_adv AND #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV
	 // Durchfahren Transport 
	 OR #automatic AND #M.si_interlocking_adv AND #M.si_interlocking_transport_ret AND #M.Auto_Durchfahren_Nachlauf_ADV
	 // Hand Normal
	 OR (#manual AND ((NOT #M.Anwahl_Ueberfoerdern_RET AND NOT #M.Anwahl_Ueberfoerdern_ADV AND #DEV_01.BUTTON_ADV)))  // Hand Normal
	 ;
	 //-----------------------------------------------------------
	 // Control 2 mit Anlaufwarnug Start
	 //-----------------------------------------------------------
	 #M.control_2_ADV := #M.control_1_ADV
	 AND (NOT #M.Error_no_Anst_RET_ADV OR #M.si_service_mode)
	 AND (NOT #x_B_pos_ADV OR #M.Ausf_ADV_Dependent_Drive_2_ADV OR #M.si_endpos_ignored_mode_active)
	 AND NOT #M.CONTROL_RET_TIME
	 AND #M.si_interlocking_adv
	 ;
	 //  Nachlaufzeit bei 0= keine (Endanschlag - Ausrichten)
	 IF #CONF.TIME_FOLLOW_UP_ADV <> t#0s THEN
	     #TIME_FOLLOW_UP_ADV(IN := #M.control_2_ADV,
	                         PT := #CONF.TIME_FOLLOW_UP_ADV,
	                         Q => #Hilfsbit1,
	                         ET => #Temp_Zeitwert);
	 ELSE
	     #Hilfsbit1 := false;
	 END_IF;
	 
	 #M.TIME_FOLLOW_UP_ADV := #x_B_pos_ADV AND NOT #M.control_2_ADV AND #Hilfsbit1;
	 
	 //-----------------------------------------------------------
	 // Control 3 mit Abhängigkeiten von vorgeschalteten Motor (Motor läuft nur wenn nachgeschalteten Moto ein)
	 //-----------------------------------------------------------
	 #M.control_3_ADV :=
	 ((#POWER_ON AND #M.control_2_ADV) OR #M.TIME_FOLLOW_UP_ADV)
	 AND
	 (
	 (#M.Ausf_ADV_Dependent_Drive_2_ADV AND #M.Ausf_ADV_Dependent_Drive_1_ADV)
	 OR
	 (#M.Einf_ADV_Dependent_Drive_2_ADV AND #M.Einf_ADV_Dependent_Drive_1_ADV)
	 OR
	 (NOT #M.Ausf_ADV_Dependent_Drive_2_ADV AND NOT #M.Einf_ADV_Dependent_Drive_2_ADV)
	 )
	 ;
	 //-----------------------------------------------------------
	 // Control Output
	 //-----------------------------------------------------------
	 #CONTROL_ADV := #M.control_3_ADV AND #Start_up_Warning_releas_to_start_ADV;
	 
	 // Motor ansteuerung nachlauf intern ( Durch die Massenträgheit könnter das Bauteil auf den Geber rauffahren)
	 // Intern nur Diesse Bit abfragen "M.CONTROL_xxx_TIME "
	 #TIME_CONTROL_ADV(IN := #CONTROL_ADV,
	                   PT := #CONF.TIME_AFTER_RUN_UP_POS_ACTIVE_ADV,
	                   Q => #M.CONTROL_ADV_TIME,
	                   ET => #Temp_Zeitwert);
	 
	 // ------------------------------------------------------------
	 // Förderer Geschwindigkeit langsam rück
	 // ------------------------------------------------------------
	 // Setzen
	 IF NOT #M.Anwahl_Ueberfoerdern_RET AND NOT #M.Anwahl_Ueberfoerdern_ADV
	     AND (
	     (#x_B_fs_RET AND #M.CONTROL_RET_TIME)
	     OR (#x_B_fs_RET AND NOT #x_B_pos_RET_POS AND #M.reset_POS)
	     OR (#x_B_pos_RET_NEG1 AND #M.CONTROL_ADV_TIME)
	     )
	 THEN
	     #M.slowly_RET_Save := true;
	 END_IF;
	 
	 // error Umschaltung V2/V1 Bero nicht betätigt !
	 #M.slowly_RET_Error_fs_positions :=
	 #x_B_pos_RET_POS
	 AND NOT #x_B_fs_RET_POS
	 AND NOT #M.slowly_RET_Save
	 AND #M.CONTROL_RET_TIME
	 AND NOT #REM.Wegmerker_RET
	 // AND NOT #REM.Belegt_Lacktraversen
	 AND #NUMBER_OF_SPEEDS = 2
	 AND #POSITION_EXISTS_RET
	 ;
	 
	 // Reset
	 IF #x_B_pos_RET AND #M.CONTROL_RET_TIME
	     OR (#x_B_fs_RET_NEG AND #M.CONTROL_ADV_TIME)
	     OR #NUMBER_OF_SPEEDS = 1
	     OR NOT #POSITION_EXISTS_RET
	 THEN
	     #M.slowly_RET_Save := false;
	 END_IF;
	 
	 #M.slowly_RET_HM :=
	 (#M.slowly_RET_Save AND NOT #REM.Belegt_Lacktraversen AND NOT #M.Auto_Durchfahren_1_ADV)
	 OR #NEW_SHUTTLE_STOP_IN_FS_RET AND NOT #M.Auto_Durchfahren_1_ADV
	 OR #HMI.IN.button_slowly
	 OR #SEQ.STATUS_COLLISION_PROTECTION_DRIVE_SLOW
	 OR #M.si_endpos_ignored_mode_active AND #NUMBER_OF_SPEEDS = 2
	 OR #M.si_endpos_ignored_mode_active AND #NUMBER_OF_SPEEDS = 1 AND #CONF.BUTTON_SLOWLY_SHOW
	 // OR #NUMBER_OF_SPEEDS = 1
	 ;
	 #M.slowly_RET :=
	 #M.slowly_RET_HM
	 OR (#M.Ausf_RET_Dependent_Drive_1_RET AND NOT #x_SEQ_RET.STATUS_DRIVE_RUNNING_FAST)
	 OR (#M.Einf_RET_Dependent_Drive_1_RET AND NOT #x_SEQ_RET.STATUS_DRIVE_RUNNING_FAST)
	 OR (#M.Ausf_ADV_Anst_RET AND NOT #x_SEQ_ADV.STATUS_SELECT_TRANSP_FAST)
	 OR (#M.Einf_ADV_Anst_RET AND (NOT #x_SEQ_ADV.STATUS_SELECT_TRANSP_FAST AND NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET))
	 ;
	 
	 // ------------------------------------------------------------
	 // Förderer Geschwindigkeit langsam vor
	 // ------------------------------------------------------------
	 // Setzen
	 IF NOT #M.Anwahl_Ueberfoerdern_RET AND NOT #M.Anwahl_Ueberfoerdern_ADV
	     AND (
	     (#x_B_fs_ADV AND #M.CONTROL_ADV_TIME)
	     OR (#x_B_fs_ADV AND NOT #x_B_pos_ADV_POS AND #M.reset_POS)
	     OR (#x_B_pos_ADV_NEG1 AND #M.CONTROL_RET_TIME)
	     )
	 THEN
	     #M.slowly_ADV_Save := true;
	 END_IF;
	 
	 // error Umschaltung V2/V1 Bero nicht betätigt !
	 #M.slowly_ADV_Error_fs_positions :=
	 #x_B_pos_ADV_POS
	 AND NOT #x_B_fs_ADV_POS
	 AND NOT #M.slowly_ADV_Save
	 AND #M.CONTROL_ADV_TIME
	 AND NOT #REM.Wegmerker_ADV
	 // AND NOT #REM.Belegt_Lacktraversen
	 AND #NUMBER_OF_SPEEDS = 2
	 ;
	 
	 // Reset  
	 IF #x_B_pos_ADV AND #M.CONTROL_ADV_TIME
	     OR (#x_B_fs_ADV_NEG AND #M.CONTROL_RET_TIME)
	     OR #NUMBER_OF_SPEEDS = 1
	 THEN
	     #M.slowly_ADV_Save := false;
	 END_IF;
	 
	 #M.slowly_ADV_HM :=
	 (#M.slowly_ADV_Save AND NOT #REM.Belegt_Lacktraversen AND NOT #M.Auto_Durchfahren_1_ADV)
	 OR #NEW_SHUTTLE_STOP_IN_FS_ADV AND NOT #M.Auto_Durchfahren_1_ADV
	 OR #HMI.IN.button_slowly
	 OR #SEQ.STATUS_COLLISION_PROTECTION_DRIVE_SLOW
	 OR #M.si_endpos_ignored_mode_active AND #NUMBER_OF_SPEEDS = 2
	 OR #M.si_endpos_ignored_mode_active AND #NUMBER_OF_SPEEDS = 1 AND #CONF.BUTTON_SLOWLY_SHOW
	 // OR #NUMBER_OF_SPEEDS = 1
	 ;
	 
	 #M.slowly_ADV :=
	 #M.slowly_ADV_HM
	 OR (#M.Ausf_ADV_Dependent_Drive_1_ADV AND NOT #x_SEQ_ADV.STATUS_DRIVE_RUNNING_FAST)
	 OR (#M.Einf_ADV_Dependent_Drive_1_ADV AND NOT #x_SEQ_ADV.STATUS_DRIVE_RUNNING_FAST)
	 OR (#M.Ausf_RET_Anst_ADV AND NOT #x_SEQ_RET.STATUS_SELECT_TRANSP_FAST)
	 OR (#M.Einf_RET_Anst_ADV AND (NOT #x_SEQ_RET.STATUS_SELECT_TRANSP_FAST AND NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV))
	 ;
	 // ------------------------------------------------------------
	 // Förderer Geschwindigkeit schnell
	 // ------------------------------------------------------------
	 #CONTROL_FAST :=
	 #POWER_ON
	 AND NOT #M.Error_no_Anst_RET_ADV
	 AND (
	 (#CONTROL_RET AND NOT #M.slowly_RET AND NOT #M.TIME_FOLLOW_UP_RET)
	 OR
	 (#CONTROL_ADV AND NOT #M.slowly_ADV AND NOT #M.TIME_FOLLOW_UP_ADV)
	 )
	 ;
	 // ------------------------------------------------------------
	 // Ansteuerung Antrieb Fehler rücksetzen
	 // ------------------------------------------------------------                        
	 #CONTROL_RESET := #fg.OUT.QUIT_PULSE;
	 // ------------------------------------------------------------
	 // Grundstellung / Home
	 // ------------------------------------------------------------  
	 #M.HOME_POSITION :=
	 (
	 (NOT #REM.Belegt AND #M.EMPTY)
	 OR (#REM.Belegt AND (#x_B_pos_RET OR #x_B_pos_ADV OR #CONF.ENABLE_HOME_WITHOUT_STOP_POSITION))
	 )
	 AND NOT #M.CONTROL_RET_TIME
	 AND NOT #M.CONTROL_ADV_TIME
	 AND NOT #REM.Wegmerker_RET
	 AND NOT #REM.Wegmerker_ADV
	 // AND NOT #REM.NEW_COMPONENT_RETRACTED_RET
	 // AND NOT #REM.NEW_COMPONENT_RETRACTED_ADV
	 AND NOT #M.Auto_Ausfoerdern_HM_RET
	 AND NOT #M.Auto_Ausfoerdern_HM_ADV
	 AND NOT #M.slowly_RET_Save
	 AND NOT #M.slowly_ADV_Save
	 ;
	 
	 #HOME_POSITION := #M.HOME_POSITION;
	 // ==========================================================================================================================
	 // ==========================================================================================================================
	 // Error
	 // ==========================================================================================================================
	 // ==========================================================================================================================
	 // -------------------------------------------
	 // Quittung
	 // -------------------------------------------
	 
	 IF #M.Quitt_POS THEN
	     #Error.Konfigurationsfehler_FG_Ebene := FALSE;
	     #Error.Konfigurationsfehler_SG_Ebene := FALSE;
	     #Error.Parametrierfehler := FALSE;
	     #Error.Power_off := FALSE;
	     #Error.Error_Endschalter_ueberbrueckt := FALSE;
	     #Error.Error_Interlock_ueberbrueckt := FALSE;
	     #Error.Typedaten_nicht_plausible_oder_leer := FALSE;
	     #Error.Error_Spaltkontrolle := FALSE;
	     #Error.Error_drive := FALSE;
	     #Error.Error_peripheri := FALSE;
	     #Error.Error_Endlagen := FALSE;
	     
	     #Error.Error_Endlagen_Parrstoerung := FALSE;
	     #Error.Error_Interlock := FALSE;
	     #Error.Error_Time_change_position := FALSE;
	     #Error.Error_Time_change_position_too_early := FALSE;
	     #Error.Error_Position_controlle_PROXI_POS_RET := FALSE;
	     #Error.Error_Position_controlle_PROXI_FS_RET := FALSE;
	     #Error.Error_Position_controlle_PROXI_FS_ADV := FALSE;
	     #Error.Error_Position_controlle_PROXI_POS_ADV := FALSE;
	     #Error.Error_collision_protection_RET := FALSE;
	     #Error.Error_collision_protection_ADV := FALSE;
	     #Error.Error_unsecured_position_EMPTY := FALSE;
	     #Error.Error_unsecured_position_OCCUPIED := FALSE;
	     #Error.Error_controll_drive_in := FALSE;
	     #Error.Error_Occupied_Check := FALSE;
	     
	 END_IF;
	 
	 IF #M.reset_POS THEN
	     #Error.Error_Endlagen_SL := FALSE;
	 END_IF;
	 
	 // -------------------------------------------
	 // #Error Power off
	 // -------------------------------------------
	 #Error.Power_off := NOT #POWER_ON AND NOT #fg.OUT."ERROR_SAFETY";
	 //--------------------------------------------
	 // Error Antriebe 
	 //--------------------------------------------
	 #Error.Error_drive := NOT #DRIVE_OK OR (#DRV_REMOTE_SEQ.IN.COMMAND_EXTERNAL AND #DRV_REMOTE_SEQ.IN.FAULT);
	 //--------------------------------------------
	 // Error Peripheri
	 //--------------------------------------------
	 #Error.Error_peripheri := NOT #PERIPHERI_OK;
	 // -------------------------------------------
	 // Error Endschalter überbrückt
	 // -------------------------------------------
	 #Error.Error_Endschalter_ueberbrueckt := #M.si_endpos_ignored_mode_active;
	 // -------------------------------------------
	 // Error Sicherheit gebrückt
	 // -------------------------------------------
	 #Error.Error_Interlock_ueberbrueckt := #M.si_service_mode;
	 // -------------------------------------------
	 // Typedaten nicht plausible oder leer
	 // -------------------------------------------
	 #Hilfsbit1 := #CONF.TYPE_ENABLE_CHECK
	 AND
	 (
	 (
	 #REM.Belegt
	 AND (#SEQ.STATUS_TYPE = 0 AND #SEQ.STATUS_TYPE_UNIT.REFERENZ = 0)
	 )
	 OR
	 (
	 NOT #REM.Belegt AND NOT #REM.NEW_COMPONENT_RETRACTED_RET AND NOT #REM.NEW_COMPONENT_RETRACTED_ADV
	 AND (#SEQ.STATUS_TYPE <> 0 OR #SEQ.STATUS_TYPE_UNIT.REFERENZ <> 0)
	 )
	 )
	 ;
	 
	 #TIME_TYPEDATA_PLAUSIBLE_ERRO_OFF(IN := #Hilfsbit1,
	                                   PT := T#1s,
	                                   Q => #Error.Typedaten_nicht_plausible_oder_leer,
	                                   ET => #Temp_Zeitwert);
	 
	 // -------------------------------------------
	 // #Error Spaltkontrolle (Lichtschranke)
	 // -------------------------------------------
	 IF #ERROR_CLEARANCE THEN
	     // Statement section IF
	     #Error.Error_Spaltkontrolle := TRUE;
	 END_IF;
	 // -------------------------------------------
	 // Error Endlagen fehlt / Stoppposition überfahren !
	 //--------------------------------------------
	 // Stoppposition überfahren !
	 IF #automatic
	     AND (
	     #x_B_pos_RET_NEG AND #M.CONTROL_RET_TIME AND NOT #CONTROL_RET AND #SEQ_RET_CONNECTED
	     OR
	     #x_B_pos_ADV_NEG AND #M.CONTROL_ADV_TIME AND NOT #CONTROL_ADV AND #SEQ_ADV_CONNECTED
	     )
	 THEN
	     #Error.Error_Endlagen := true;
	 END_IF;
	 
	 // -------------------------------------------
	 // Error Endlagen Umschaltung V2/V1 fehlt
	 //--------------------------------------------
	 
	 // error Umschaltung V2/V1 Bero nicht betätigt !
	 IF #automatic
	     AND (#M.slowly_RET_Error_fs_positions OR #M.slowly_ADV_Error_fs_positions)
	 THEN
	     #Error.Error_Endlagen_SL := true;
	 END_IF;
	 
	 // -------------------------------------------
	 // Error Endlagen Parrstoerung
	 //--------------------------------------------
	 IF #automatic
	     AND #PERIPHERI_OK
	     AND #EXISTS_TRAVERSE
	     AND (#x_B_pos_RET AND #x_B_fs_RET AND #x_B_pos_ADV AND #x_B_fs_ADV)
	 THEN
	     #Error.Error_Endlagen_Parrstoerung := true;
	 END_IF;
	 // -------------------------------------------
	 // Error Verriegelung
	 //--------------------------------------------
	 #Error.Error_Interlock := false;
	 // -------------------------------------------
	 // Error Laufzeit / Error change position
	 //--------------------------------------------
	 IF #CONF.TIME_CHANGE_POSITION <> t#0s THEN
	     #Hilfsbit1 := #automatic
	     AND NOT #M.Quitt_POS
	     AND NOT #M.Belegt_POS
	     AND NOT #M.Belegt_NEG
	     // AND (#M.CONTROL_RET_TIME OR #M.CONTROL_ADV_TIME
	     AND (#M.control_2_RET OR #M.control_2_ADV
	     );
	     
	     #TIME_DEV_time_change_position_SE(IN := #Hilfsbit1,
	                                       PT := #CONF.TIME_CHANGE_POSITION,
	                                       Q => #Hilfsbit2,
	                                       ET => #Temp_Zeitwert);
	     
	     IF #Hilfsbit2 THEN
	         // Bit soll gesetz bleiben (nur nach Quittung => erneuter Anlauf)
	         #Error.Error_Time_change_position := true;
	     END_IF;
	     
	 ELSE
	     #Error.Error_Time_change_position := false;
	 END_IF;
	 
	 // -------------------------------------------
	 // Error Laufzeit min zeit / Error change position min time
	 //--------------------------------------------
	 IF #CONF.TIME_CHANGE_POSITION_MIN <> t#0s THEN
	     #Hilfsbit1 := #automatic
	     AND NOT #M.Quitt_POS
	     AND NOT #M.Belegt_POS
	     AND NOT #M.Belegt_NEG
	     AND (#M.control_2_RET OR #M.control_2_ADV
	     );
	     
	     // Travel started
	     IF #Hilfsbit1 THEN
	         #M.Travel_Started := true;
	     END_IF;
	     
	     
	     #TIME_DEV_time_change_position_Min(IN := #M.Travel_Started,
	                                        PT := #CONF.TIME_CHANGE_POSITION_MIN,
	                                        Q => #Hilfsbit2,
	                                        ET => #Temp_Zeitwert);
	     
	     IF #M.Travel_Started AND NOT #Hilfsbit2 AND #automatic AND #M.Belegt_POS THEN
	         // Bit soll gesetz bleiben (nur nach Quittung => erneuter Anlauf)
	         #Error.Error_Time_change_position_too_early := true;
	     END_IF;
	     
	     // Reset travel started
	     IF #M.Belegt_POS THEN
	         #M.Travel_Started := false;
	     END_IF;
	    
	 ELSE
	     #Error.Error_Time_change_position_too_early := false;
	 END_IF;
	 
	 
	 //--------------------------------------------
	 // Positonsüberwachung RET 
	 //--------------------------------------------
	 IF #CONF.TIME_POS_CONTROLL_PROXI_POS_RET <> t#0s AND #POSITION_EXISTS_RET THEN
	     #Hilfsbit1 := #automatic
	     AND NOT #M.Quitt_POS
	     AND (#CONTROL_RET OR #CONTROL_ADV)
	     AND #IN_BG00_PROXI_POS_RET
	     ;
	     
	     #TIME_POS_CONTROLL_PROXI_POS_RET(IN := #Hilfsbit1,
	                                      PT := #CONF.TIME_POS_CONTROLL_PROXI_POS_RET,
	                                      Q => #Hilfsbit2,
	                                      ET => #Temp_Zeitwert);
	     
	     IF #Hilfsbit2 THEN
	         #Error.Error_Position_controlle_PROXI_POS_RET := TRUE;
	     END_IF;
	     
	 ELSE
	     #Error.Error_Position_controlle_PROXI_POS_RET := FALSE;
	 END_IF;
	 
	 //--------------------------------------------
	 // Positonsüberwachung FS_RET
	 //--------------------------------------------
	 IF #CONF.TIME_POS_CONTROLL_PROXI_FS_RET <> t#0s AND #POSITION_EXISTS_RET AND #NUMBER_OF_SPEEDS = 2 THEN
	     #Hilfsbit1 := #automatic
	     AND NOT #M.Quitt_POS
	     AND (#CONTROL_RET OR #CONTROL_ADV)
	     AND (#IN_BG02_PROXI_FS_RET OR #M.slowly_RET_Save)
	     ;
	     
	     #TIME_POS_CONTROLL_PROXI_FS_RET(IN := #Hilfsbit1,
	                                     PT := #CONF.TIME_POS_CONTROLL_PROXI_FS_RET,
	                                     Q => #Hilfsbit2,
	                                     ET => #Temp_Zeitwert);
	     
	     IF #Hilfsbit2 THEN
	         #Error.Error_Position_controlle_PROXI_FS_RET := TRUE;
	     END_IF;
	     
	 ELSE
	     #Error.Error_Position_controlle_PROXI_FS_RET := FALSE;
	 END_IF;
	 //--------------------------------------------
	 // Positonsüberwachung ADV
	 //--------------------------------------------
	 IF #CONF.TIME_POS_CONTROLL_PROXI_POS_ADV <> t#0s THEN
	     #Hilfsbit1 := #automatic
	     AND NOT #M.Quitt_POS
	     AND (#CONTROL_ADV OR #CONTROL_ADV)
	     AND #IN_BG01_PROXI_POS_ADV
	     ;
	     
	     #TIME_POS_CONTROLL_PROXI_POS_ADV(IN := #Hilfsbit1,
	                                      PT := #CONF.TIME_POS_CONTROLL_PROXI_POS_ADV,
	                                      Q => #Hilfsbit2,
	                                      ET => #Temp_Zeitwert);
	     
	     IF #Hilfsbit2 THEN
	         #Error.Error_Position_controlle_PROXI_POS_ADV := TRUE;
	     END_IF;
	     
	 ELSE
	     #Error.Error_Position_controlle_PROXI_POS_ADV := FALSE;
	 END_IF;
	 //--------------------------------------------
	 // Positonsüberwachung FS_ADV 
	 //--------------------------------------------
	 IF #CONF.TIME_POS_CONTROLL_PROXI_FS_ADV <> t#0s AND #NUMBER_OF_SPEEDS = 2 THEN
	     #Hilfsbit1 := #automatic
	     AND NOT #M.Quitt_POS
	     AND (#CONTROL_ADV OR #CONTROL_ADV)
	     AND (#IN_BG03_PROXI_FS_ADV OR #M.slowly_ADV_Save)
	     ;
	     
	     #TIME_POS_CONTROLL_PROXI_FS_ADV(IN := #Hilfsbit1,
	                                     PT := #CONF.TIME_POS_CONTROLL_PROXI_FS_ADV,
	                                     Q => #Hilfsbit2,
	                                     ET => #Temp_Zeitwert);
	     
	     IF #Hilfsbit2 THEN
	         #Error.Error_Position_controlle_PROXI_FS_ADV := TRUE;
	     END_IF;
	     
	 ELSE
	     #Error.Error_Position_controlle_PROXI_FS_ADV := FALSE;
	 END_IF;
	 //--------------------------------------------
	 // Kollisionsschutz Motor Stop
	 //--------------------------------------------
	 IF #SEQ.STATUS_COLLISION_PROTECTION_DRIVE_STOP AND #REM.Wegmerker_RET THEN
	     #Error.Error_collision_protection_RET := TRUE;
	 END_IF;
	 
	 IF #SEQ.STATUS_COLLISION_PROTECTION_DRIVE_STOP AND (#REM.Wegmerker_ADV OR NOT #Error.Error_collision_protection_RET) THEN
	     #Error.Error_collision_protection_ADV := TRUE;
	 END_IF;
	 
	 //--------------------------------------------
	 // Error Undefenierte Stellung OCCUPIED
	 //--------------------------------------------
	 #Error.Error_unsecured_position_Warnung_OCCUPIED :=
	 NOT #M.EMPTY
	 AND #REM.Belegt
	 AND #PERIPHERI_OK
	 AND NOT #x_B_pos_RET
	 AND NOT #x_B_pos_ADV
	 AND NOT #M.CONTROL_RET_TIME
	 AND NOT #M.CONTROL_ADV_TIME
	 AND NOT #Error.Error_Time_change_position
	 AND NOT #Error.Error_Time_change_position_too_early
	 AND NOT #M.Ausfoerdern_ADV
	 AND NOT #M.Ausfoerdern_RET
	 AND NOT #M.Auto_Einfoerdern_ADV
	 AND NOT #M.Auto_Einfoerdern_new_Component_ADV
	 AND NOT #M.Auto_Einfoerdern_RET
	 AND NOT #M.Auto_Einfoerdern_new_Component_RET
	 AND NOT #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET
	 AND NOT #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV
	 ;
	 IF #CONF.TIME_UNDEFECTED_POSITION <> t#0s THEN
	     
	     #TIME_UNDEFECTED_POSITION_OCCUPIED(IN := #automatic AND #Error.Error_unsecured_position_Warnung_OCCUPIED,
	                                        PT := #CONF.TIME_UNDEFECTED_POSITION,
	                                        Q => #Hilfsbit2,
	                                        ET => #Temp_Zeitwert);
	     
	     // Bei Aktivierung Undefenierte Stellung Error (Error Setzen)
	     IF #CONF.ENABLE_UNDEFECTED_POSITION_ERROR THEN
	         IF #Hilfsbit2 THEN
	             #Error.Error_unsecured_position_OCCUPIED := TRUE;
	         END_IF;
	     ELSE
	         #Error.Error_unsecured_position_OCCUPIED := #Hilfsbit2;
	     END_IF;
	     
	 END_IF;
	 
	 //--------------------------------------------
	 // Error Undefenierte Stellung Empty
	 //--------------------------------------------
	 #Error.Error_unsecured_position_Warnung_EMPTY :=
	 NOT #M.EMPTY
	 AND NOT #REM.Belegt
	 AND NOT #M.Ausfoerdern_ADV
	 AND NOT #M.Ausfoerdern_RET
	 AND NOT #M.Auto_Einfoerdern_ADV
	 AND NOT #M.Auto_Einfoerdern_new_Component_ADV
	 AND NOT #M.Auto_Einfoerdern_RET
	 AND NOT #M.Auto_Einfoerdern_new_Component_RET
	 AND NOT #HMI.OUT.Anwahl_Einfoerdern_ADV
	 AND NOT #HMI.OUT.Anwahl_Einfoerdern_RET
	 AND NOT #M.Anwahl_Ueberfoerdern_ADV
	 AND NOT #M.Anwahl_Ueberfoerdern_RET
	 ;
	 
	 IF #CONF.TIME_UNDEFECTED_POSITION <> t#0s THEN
	     
	     #TIME_UNDEFECTED_POSITION_EMPTY(IN := #automatic AND #Error.Error_unsecured_position_Warnung_EMPTY,
	                                     PT := #CONF.TIME_UNDEFECTED_POSITION,
	                                     Q => #Hilfsbit2,
	                                     ET => #Temp_Zeitwert);
	     
	     // Bei Aktivierung Undefenierte Stellung Error (Error Setzen)
	     IF #CONF.ENABLE_UNDEFECTED_POSITION_ERROR THEN
	         IF #Hilfsbit2 THEN
	             #Error.Error_unsecured_position_EMPTY := TRUE;
	         END_IF;
	     ELSE
	         #Error.Error_unsecured_position_EMPTY := #Hilfsbit2;
	     END_IF;
	     
	 END_IF;
	 
	 //--------------------------------------------
	 // Error Einlaufzeit
	 //--------------------------------------------
	 // Fahrzeug RET /ADV in Position angemkommen
	 #Hilfsbit2 :=
	 #x_SEQ_RET.STATUS_NEW_COMPONENT_RETRACTED_RET
	 OR #x_SEQ_RET.STATUS_NEW_COMPONENT_RETRACTED_ADV
	 OR #x_SEQ_ADV.STATUS_NEW_COMPONENT_RETRACTED_RET
	 OR #x_SEQ_ADV.STATUS_NEW_COMPONENT_RETRACTED_ADV
	 ;
	 #error_controll_drive_in_off_neg := NOT #Hilfsbit2 AND NOT #ERROR_CONTROLL_DRIVE_IN_OFF_NHM;
	 #ERROR_CONTROLL_DRIVE_IN_OFF_NHM := NOT #Hilfsbit2;
	 
	 IF #error_controll_drive_in_off_neg THEN
	     #ERROR_CONTROLL_DRIVE_IN_OFF := TRUE;
	 END_IF;
	 IF NOT #SEQ.STATUS_PART_CHANGE AND #SEQ.STATUS_IN_POSITION THEN
	     #ERROR_CONTROLL_DRIVE_IN_OFF := FALSE;
	 END_IF;
	 
	 
	 #Hilfsbit1 :=
	 #automatic
	 AND NOT #ERROR_CONTROLL_DRIVE_IN_OFF
	 AND
	 (
	 (
	 #x_SEQ_RETxxx.Status_Ausfoerdern_xxx
	 AND (NOT #x_SEQ_RET.STATUS_DRIVE_RUNNING OR #x_SEQ_RET.STATUS_DRIVE_ERROR)
	 AND NOT #x_B_NEW_COMPONENT_RETRACTE_ADV
	 AND #SEQ_RET_CONNECTED
	 AND #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV
	 AND #CONTROL_ADV
	 )
	 OR
	 (
	 #x_SEQ_ADVxxx.Status_Ausfoerdern_xxx
	 AND (NOT #x_SEQ_ADV.STATUS_DRIVE_RUNNING OR #x_SEQ_ADV.STATUS_DRIVE_ERROR)
	 AND NOT #x_B_NEW_COMPONENT_RETRACTE_RET
	 AND #SEQ_ADV_CONNECTED
	 AND #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET
	 AND #CONTROL_RET
	 )
	 )
	 ;
	 
	 #TIME_CONTROLL_DRIVE_IN(IN := #Hilfsbit1,
	                         PT := T#2S,
	                         ET => #Temp_Zeitwert);
	 
	 
	 IF #TIME_CONTROLL_DRIVE_IN.Q THEN
	     #Error.Error_controll_drive_in := TRUE;
	 END_IF;
	 
	 
	 // ============================================================================================================
	 // Error 
	 // ============================================================================================================
	 //-----------------------------------------------------------------------------------------------------
	 // RefernzDB für die Meldungen eintragen
	 //-----------------------------------------------------------------------------------------------------
	 #GetMessList(FAMILY := 'CVFL',
	              DIAG => #DIAG_TEMP.GetMessList,
	              GLOB := #GLOB,
	              REF_DB => #MessHandler.LIST_PTR[0].DB);
	 
	 #MessHandler.LIST_PTR[0].NR := 0;
	 #MessHandler.ERROR_CLASS := 0;
	 #MessHandler.IPST_PRIO := ' ';
	 #MessHandler.IPST_SEND := TRUE; // Meldung soll zu IPS-T gesendet werden  
	 #MessHandler.OPERAND := '';
	 // ----------------------------------------------------------------------------      
	 //  Error LISTE
	 // ----------------------------------------------------------------------------  
	 IF #Error.Konfigurationsfehler_FG_Ebene THEN
	     #MessHandler.LIST_PTR[0].NR := 1;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Konfigurationsfehler_SG_Ebene THEN
	     #MessHandler.LIST_PTR[0].NR := 2;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Parametrierfehler THEN
	     #MessHandler.LIST_PTR[0].NR := 3;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Error_Spaltkontrolle THEN
	     #MessHandler.LIST_PTR[0].NR := 4;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Error_collision_protection_RET THEN
	     #MessHandler.LIST_PTR[0].NR := 35;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Error_collision_protection_ADV THEN
	     #MessHandler.LIST_PTR[0].NR := 36;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	     
	     
	 ELSIF #Error.Error_peripheri THEN
	     #MessHandler.LIST_PTR[0].NR := 12;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.MESSAGE;
	     #MessHandler.IPST_PRIO := 'M';
	     
	 ELSIF #Error.Error_Position_controlle_PROXI_POS_RET THEN
	     #MessHandler.LIST_PTR[0].NR := 13;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	     // #Operand in der Meldung einbauen mitgeben 
	     "MESS_HANDLE_READ_OPERAND_FC"(OPERAND := GetSymbolName(size := 0, variable := #BG00_PROXI_POS_RET),
	                                   MESSAGE := #MessHandler,
	                                   IFACE := #Mess.IFACE);
	     
	 ELSIF #Error.Error_Position_controlle_PROXI_FS_RET THEN
	     #MessHandler.LIST_PTR[0].NR := 14;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	     // #Operand in der Meldung einbauen mitgeben 
	     "MESS_HANDLE_READ_OPERAND_FC"(OPERAND := GetSymbolName(size := 0, variable := #BG02_PROXI_FS_RET),
	                                   MESSAGE := #MessHandler,
	                                   IFACE := #Mess.IFACE);
	     
	 ELSIF #Error.Error_Position_controlle_PROXI_FS_ADV THEN
	     #MessHandler.LIST_PTR[0].NR := 15;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	     // #Operand in der Meldung einbauen mitgeben 
	     "MESS_HANDLE_READ_OPERAND_FC"(OPERAND := GetSymbolName(size := 0, variable := #BG03_PROXI_FS_ADV),
	                                   MESSAGE := #MessHandler,
	                                   IFACE := #Mess.IFACE);
	     
	 ELSIF #Error.Error_Position_controlle_PROXI_POS_ADV THEN
	     #MessHandler.LIST_PTR[0].NR := 16;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	     // #Operand in der Meldung einbauen mitgeben 
	     "MESS_HANDLE_READ_OPERAND_FC"(OPERAND := GetSymbolName(size := 0, variable := #BG01_PROXI_POS_ADV),
	                                   MESSAGE := #MessHandler,
	                                   IFACE := #Mess.IFACE);
	     
	 ELSIF #Error.Error_Endlagen THEN
	     #MessHandler.LIST_PTR[0].NR := 30;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Error_Endlagen_SL THEN
	     #MessHandler.LIST_PTR[0].NR := 31;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Error_Endlagen_Parrstoerung THEN
	     #MessHandler.LIST_PTR[0].NR := 32;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Error_Interlock THEN
	     #MessHandler.LIST_PTR[0].NR := 33;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Error_Time_change_position THEN
	     #MessHandler.LIST_PTR[0].NR := 34;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Error_Time_change_position_too_early THEN
	     #MessHandler.LIST_PTR[0].NR := 43;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Error_controll_drive_in THEN
	     #MessHandler.LIST_PTR[0].NR := 39;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	 ELSIF #Error.Error_Occupied_Check THEN
	     #MessHandler.LIST_PTR[0].NR := 40;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	     // -------------------------------------------
	     // Typedaten nicht plausible oder leer
	     // -------------------------------------------
	 ELSIF #Error.Typedaten_nicht_plausible_oder_leer THEN
	     #MessHandler.LIST_PTR[0].NR := 7;
	     IF #CONF.TYPE_RELEASE_PART_NO_CHECK THEN
	         // Weiterfahren auch bei negative Prüfung  (MELDUNG)
	         #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.MESSAGE;
	         ;
	         #MessHandler.IPST_PRIO := 'M';
	         #MessHandler.IPST_SEND := FALSE; // Meldung soll zu IPS-T gesendet werden
	     ELSE
	         // Weiterfahren auch bei negative Prüfung (STOP)
	         #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START;
	         #MessHandler.IPST_PRIO := 'T';
	         #MessHandler.IPST_SEND := TRUE; // Meldung soll zu IPS-T gesendet werden
	     END_IF;
	     //--------------------------------------------
	     // Error Undefenierte Stellung
	     //--------------------------------------------
	 ELSIF #CONF.ENABLE_UNDEFECTED_POSITION_ERROR AND (#Error.Error_unsecured_position_EMPTY OR #Error.Error_unsecured_position_OCCUPIED) THEN
	     #MessHandler.LIST_PTR[0].NR := 37;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.ERROR_NOT_DROP_START;
	     #MessHandler.IPST_PRIO := 'T';
	     
	     
	     //------------- Meldungen -----------------
	 ELSIF #Error.Error_drive THEN
	     #MessHandler.LIST_PTR[0].NR := 11;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.MESSAGE;
	     #MessHandler.IPST_PRIO := 'M';
	     IF #DRV_REMOTE_SEQ.IN.COMMAND_EXTERNAL THEN
	         #MessHandler.IPST_SEND := FALSE; // Meldung soll zu IPS-T gesendet werden
	     ELSE
	         #MessHandler.IPST_SEND := TRUE; // Meldung soll zu IPS-T gesendet werden   
	         ;
	     END_IF;
	 ELSIF #Error.Power_off THEN
	     #MessHandler.LIST_PTR[0].NR := 10;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.MESSAGE;
	     #MessHandler.IPST_PRIO := 'M';
	 ELSIF #Error.Error_Endschalter_ueberbrueckt THEN
	     #MessHandler.LIST_PTR[0].NR := 5;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.MESSAGE;
	     #MessHandler.IPST_PRIO := 'M';
	 ELSIF #Error.Error_Interlock_ueberbrueckt THEN
	     #MessHandler.LIST_PTR[0].NR := 6;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.MESSAGE;
	     #MessHandler.IPST_PRIO := 'M';
	     
	     // Warnung Automatik Verbund fehlt Automatik start
	 ELSIF #automatic_FG AND NOT #manual AND NOT #AUTOMATIC_COMPOSITE THEN
	     #MessHandler.LIST_PTR[0].NR := 38;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.MESSAGE;
	     #MessHandler.IPST_PRIO := 'M';
	     
	     // Warnung ausgeben bei annwahl Taste langsam
	 ELSIF #HMI.IN.button_slowly AND NOT #CONF.DISABLE_WARNING_BUTTON_SLOWLY AND #automatic THEN
	     #MessHandler.LIST_PTR[0].NR := 8;
	     #MessHandler.ERROR_CLASS := #GLOB.SYS.CONST.MESS.MESSAGE;
	     #MessHandler.IPST_PRIO := 'M';
	     
	 END_IF;
	 //-----------------------------------------------------------------------------------------------------
	 // Sammelstörmerker bilden
	 //-----------------------------------------------------------------------------------------------------
	 #WARNING := #MessHandler.ERROR_CLASS = #GLOB.SYS.CONST.MESS.MESSAGE OR #MessHandler.ERROR_CLASS = #GLOB.SYS.CONST.MESS.WARNING;
	 #FAULT := #MessHandler.LIST_PTR[0].NR <> 0 AND NOT #WARNING;
	 // --------------------------------------------------------    
	 //  Error Verursacht Antrieb STOP
	 // --------------------------------------------------------
	 #M.Error_no_Anst_RET_ADV :=
	 #Error.Konfigurationsfehler_FG_Ebene
	 OR #Error.Konfigurationsfehler_SG_Ebene
	 OR #Error.Parametrierfehler
	 OR #Error.Error_Spaltkontrolle
	 OR #Error.Power_off
	 OR #Error.Error_drive
	 OR #Error.Error_peripheri
	 OR #Error.Error_Endlagen
	 OR #Error.Error_Endlagen_SL
	 OR #Error.Error_Endlagen_Parrstoerung
	 OR #Error.Error_Interlock
	 OR #Error.Error_Time_change_position
	 OR #Error.Error_Time_change_position_too_early
	 OR #Error.Error_Position_controlle_PROXI_POS_RET
	 OR #Error.Error_Position_controlle_PROXI_FS_RET
	 OR #Error.Error_Position_controlle_PROXI_FS_ADV
	 OR #Error.Error_Position_controlle_PROXI_POS_ADV
	 OR #Error.Error_collision_protection_RET
	 OR #Error.Error_collision_protection_ADV
	 OR #Error.Error_controll_drive_in
	 OR (#CONF.ENABLE_UNDEFECTED_POSITION_ERROR AND #Error.Error_unsecured_position_OCCUPIED)
	 ;
	 
	 //**************************************************************************************************************************
	 //    Controlled Stop Rückmeldung
	 //**************************************************************************************************************************
	 "MODE_SET_CONTROLLED_STOP_REV2_FC"(RESET_CONTROLLED_STOP := #CONF.ENABLE_CONTROLLED_STOP AND NOT #M.HOME_POSITION,
	                                    INSTANCE_NAME := #INSTANCE_NAME,
	                                    DIAG => #DIAG_TEMP.MODE_SET_CONTROLLED_STOP_REV2_FC,
	                                    MESS_HANDLER := #MessHandler,
	                                    GLOB := #GLOB);
	 
	 //----------------------------------------------------------------------------------------------------------------------------
	 //MESS_HANDLE_FC + FB
	 //----------------------------------------------------------------------------------------------------------------------------
	 // Themen, die permanent in die MessHandlerstruktur eingetragen werden müssen
	 #MessHandler.OVERFLOW_PIC := #OVERFLOW_PIC;
	 #MessHandler.COMMISSIONING_MODE := false;
	 
	 IF "MESS_HANDLE_SINGLE_FC"(DIAG => #DIAG_TEMP.MESS_HANDLE_SINGLE_FC, MESSAGE := #MessHandler, IFACE := #Mess.IFACE, GLOB := #GLOB) THEN
	     // mit Eintrag der Meldung ins Aktivregister wird für einen Zyklus der nachfolgende Programmteil durchlaufen
	     
	     #MessHandler.CODE_VIEWER := 2#00000001;    // Bit 0 : Codeviewer zulassen 
	     #MessHandler.EPLAN_VIEWER := 2#00000001;    // Bit 0 : EPLAN Viewer zulassen 
	     #MessHandler.PN_DEVICE := 2#00000000;    // Bit 0 : kein Profinet Device 
	     
	     //Aufbereitung Thema Erstwertstörung. Diese bit wird mit "0" beschaltet wenn der Stellgerätebaustein eine 
	     //Fehlermeldung in Folge einen anderen Fehler absetzt. Bei "1" bedeutet das die Störung unabhängig von einen 
	     //anderen Störung aufgetreten ist
	     #MessHandler.FIRST_UP_FAULT := NOT #fg.OUT.ERROR_POWER_LOGIC
	     AND NOT #fg.OUT.ERROR_BUS
	     AND NOT #fg.OUT.ERROR_SAFETY
	     AND NOT #fg.OUT.ERROR_AIR;
	     
	     "MESS_HANDLE_READ_HEADER_FC"(TYPE := GetBlockName(0),
	                                  LOCATION := GetInstanceName(0),
	                                  MESSAGE := #MessHandler);
	     
	 END_IF;
	 //----------------------------------------------------------------------------------------------------------------------------
	 // Störung Eintragen und an IPST Senden
	 //----------------------------------------------------------------------------------------------------------------------------
	 #Mess(DIAG => #DIAG_TEMP.MESS_HANDLE_SINGLE_FB,
	       MESS_HANDLER := #MessHandler,
	       CONF := #MESS_CONF,
	       GLOB := #GLOB);
	 
	 //----------------------------------------------------------------------------------------------------------------------------
	 // Störung Ausgabe am HMI
	 //----------------------------------------------------------------------------------------------------------------------------
	 #HMI.OUT.ERROR_AZ := "MESS_GET_MESS_DETAIL_WINDOW_REV2_FC"(MESS_HANDLER := #MessHandler,
	                                                            REFRESH := #CONF.HMI_ALWAYS_REFRESH,
	                                                            GLOB := #GLOB);
	 //----------------------------------------------------------------------------------------------------------------------------
	 //Ausgaben Diagnosewort
	 //----------------------------------------------------------------------------------------------------------------------------
	 "TOOL_DIAG_MESSHANDLER_REV2_FC"(ID := 0,
	                                 DIAG_INOUT := #DIAG,
	                                 MESS := #MessHandler);
	 
	 // Diagnoseword unterlagerter Bausteine
	 "TOOL_DIAG_WORD_FC"(ID := 1,
	                     DIAG_NEW := #DIAG_TEMP.MODE_FG_GET_DATA_FC,
	                     DIAG_INOUT := #DIAG);
	 
	 "TOOL_DIAG_WORD_FC"(ID := 2,
	                     DIAG_NEW := #DIAG_TEMP.GetMessList,
	                     DIAG_INOUT := #DIAG);
	 // ...................
	 "TOOL_DIAG_WORD_FC"(ID := 3,
	                     DIAG_NEW := #DIAG_TEMP.MESS_HANDLE_SINGLE_FC,
	                     DIAG_INOUT := #DIAG);
	 
	 "TOOL_DIAG_WORD_FC"(ID := 4,
	                     DIAG_NEW := #DIAG_TEMP.MESS_HANDLE_SINGLE_FB,
	                     DIAG_INOUT := #DIAG);
	 
	 "TOOL_DIAG_WORD_FC"(ID := 5,
	                     DIAG_NEW := #DIAG_TEMP.TYPE_DELETE,
	                     DIAG_INOUT := #DIAG);
	 // ...................
	 "TOOL_DIAG_WORD_FC"(ID := 6,
	                     DIAG_NEW := #DIAG_TEMP.TYPE_REG1_REG2_FB_RET,
	                     DIAG_INOUT := #DIAG);
	 
	 "TOOL_DIAG_WORD_FC"(ID := 7,
	                     DIAG_NEW := #DIAG_TEMP.TYPE_REG1_REG2_FB_ADV,
	                     DIAG_INOUT := #DIAG);
	 
	 "TOOL_DIAG_WORD_FC"(ID := 8,
	                     DIAG_NEW := #DIAG_TEMP.MODE_SET_CONTROLLED_STOP_REV2_FC,
	                     DIAG_INOUT := #DIAG);
	 
	 // ==========================================================================================================================
	 // ==========================================================================================================================
	 // Extern
	 // ==========================================================================================================================
	 //****************************************************************************************************************************
	 // Daten zurück in MODE_FG_DB schreiben - Status in der Ebene setzen (MODE)
	 //****************************************************************************************************************************
	 // Status (Rücksetzen)
	 IF #Error.Power_off THEN
	     #GLOB.MODE.FG[#fg.FG_NR].IN.ERROR_POWER_LOGIC := TRUE;
	 END_IF;
	 
	 IF #Error.Error_peripheri THEN
	     #GLOB.MODE.FG[#fg.FG_NR].IN.ERROR_BUS := TRUE;
	 END_IF;
	 
	 IF NOT #M.EMPTY THEN
	     #GLOB.MODE.FG[#fg.FG_NR].IN.FG_EMPTY := FALSE;
	 END_IF;
	 
	 IF NOT #HOME_POSITION THEN
	     #GLOB.MODE.FG[#fg.FG_NR].IN.FG_HOME := FALSE;
	 END_IF;
	 
	 // ==========================================================================================================================
	 // Status extern
	 // ==========================================================================================================================
	 #SEQ.STATUS_READY_IN_RET := #M.si_interlocking_adv AND #M.si_interlocking_transport_ret
	 AND (
	 (NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV AND #M.EMPTY)
	 OR (
	 #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV
	 AND (#M.EMPTY OR NOT #M.EMPTY
	 AND (#M.Auto_Ausfoerdern_HM_ADV OR #REM.Wegmerker_ADV)))
	 )
	 ;
	 
	 #SEQ.STATUS_READY_IN_ADV := #M.si_interlocking_ret AND #M.si_interlocking_transport_adv
	 AND (
	 (NOT #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET AND #M.EMPTY)
	 OR (
	 #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET
	 AND (#M.EMPTY OR NOT #M.EMPTY
	 AND (#M.Auto_Ausfoerdern_HM_RET OR #REM.Wegmerker_RET)))
	 )
	 ;
	 
	 
	 #SEQ.STATUS_OUT_RET := #M.Ausfoerdern_RET;
	 #SEQ.STATUS_OUT_ADV := #M.Ausfoerdern_ADV;
	 
	 #SEQ.STATUS_ENABLE_SHUTTLE_FUNCTION_IN_RET := #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET;
	 #SEQ.STATUS_ENABLE_SHUTTLE_FUNCTION_IN_ADV := #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV;
	 #SEQ.STATUS_NEW_COMPONENT_RETRACTED_RET := #REM.NEW_COMPONENT_RETRACTED_RET;
	 #SEQ.STATUS_NEW_COMPONENT_RETRACTED_ADV := #REM.NEW_COMPONENT_RETRACTED_ADV;
	 
	 #SEQ.STATUS_DRIVE_THROUGH_RET := #M.Auto_Durchfahren_2_RET;
	 #SEQ.STATUS_DRIVE_THROUGH_ADV := #M.Auto_Durchfahren_2_ADV;
	 #SEQ.STATUS_SELECT_TRANSP_RET := #M.Anwahl_Ueberfoerdern_RET;
	 #SEQ.STATUS_SELECT_TRANSP_ADV := #M.Anwahl_Ueberfoerdern_ADV;
	 #SEQ.STATUS_SELECT_TRANSP_FAST := (#M.CONTROL_RET_TIME AND NOT #M.slowly_RET_HM) OR (#M.CONTROL_ADV_TIME AND NOT #M.slowly_ADV_HM);
	 #SEQ.STATUS_BUTTON_RET := #DEV_01.BUTTON_RET;
	 #SEQ.STATUS_BUTTON_ADV := #DEV_01.BUTTON_ADV;
	 #SEQ.STATUS_SERVICE_MODE_ACTIVE := #M.si_service_mode;
	 #SEQ.STATUS_EMPTY := #M.EMPTY;
	 #SEQ.STATUS_OCCUPIED := #REM.Belegt;
	 IF #DRV_REMOTE_SEQ.IN.COMMAND_EXTERNAL THEN
	     // #DRV_REMOTE_SEQ.IN.STATUS  : O_X0=MOTOR_TURNING//X1=MOTOR_F2(FAST)/X2......usw. (Position)
	     #SEQ.STATUS_DRIVE_RUNNING := (#M.CONTROL_RET_TIME OR #M.CONTROL_ADV_TIME) AND (#CONTROL_RET OR #CONTROL_ADV) AND #DRV_REMOTE_SEQ.IN.STATUS.%X0;
	     #SEQ.STATUS_DRIVE_RUNNING_FAST := #CONTROL_FAST AND #DRV_REMOTE_SEQ.IN.STATUS.%X1;
	 ELSE
	     #SEQ.STATUS_DRIVE_RUNNING := (#M.CONTROL_RET_TIME OR #M.CONTROL_ADV_TIME) AND (#CONTROL_RET OR #CONTROL_ADV);
	     #SEQ.STATUS_DRIVE_RUNNING_FAST := #CONTROL_FAST;
	 END_IF;
	 #SEQ.STATUS_AUTOMATIC := #automatic;
	 #SEQ.STATUS_MANUAL := #manual;
	 #SEQ.STATUS_DRIVE_ERROR := #M.Error_no_Anst_RET_ADV;
	 #SEQ.STATUS_RESET_EDGE_POS := #M.reset_POS;
	 #SEQ.STATUS_EXTERN_OCCUPIED_SET := FALSE;
	 #SEQ.STATUS_EXTERN_OCCUPIED_RESET := FALSE;
	 #SEQ.STATUS_NAME := #RegisterText;
	 // --------------------------------------------------------------------------------------------------------
	 // Überwachung der Bauteilkontrollen ausblenden 
	 // --------------------------------------------------------------------------------------------------------
	 #SEQ.STATUS_PART_CHANGE :=
	 (#SEQ_RET_CONNECTED AND #M.Ausfoerdern_RET)
	 OR
	 (#SEQ_ADV_CONNECTED AND #M.Ausfoerdern_ADV)
	 OR
	 (#SEQ_RET_CONNECTED AND #x_SEQ_RETxxx.Status_Ausfoerdern_xxx)
	 OR
	 (#SEQ_ADV_CONNECTED AND #x_SEQ_ADVxxx.Status_Ausfoerdern_xxx)
	 OR
	 (#REM.NEW_COMPONENT_RETRACTED_RET OR #REM.NEW_COMPONENT_RETRACTED_ADV)
	 ;
	 // --------------------------------------------------------------------------------------------------------
	 // Status in Position (Out Status)
	 // --------------------------------------------------------------------------------------------------------
	 #SEQ.STATUS_IN_POSITION :=
	 (#x_B_pos_RET OR #x_B_pos_ADV)
	 AND NOT #SEQ.STATUS_PART_CHANGE
	 AND #SEQ.STATUS_OCCUPIED
	 ;
	 // ==========================================================================================================================
	 // Satus extern RET - Schreiben
	 // ==========================================================================================================================
	 IF #SEQ_RET_CONNECTED THEN
	     #SEQ_RET.STATUS_TYPE_NEW := #x_SEQ_RET.STATUS_TYPE_NEW;
	     #SEQ_RET.STATUS_TYPE_ASC_NEW := #x_SEQ_RET.STATUS_TYPE_ASC_NEW;
	     #SEQ_RET.STATUS_TYPE := #x_SEQ_RET.STATUS_TYPE;
	     
	     #SEQ_RET.STATUS_TYPE_ASC := #x_SEQ_RET.STATUS_TYPE_ASC;
	     #SEQ_RET.STATUS_TYPE_UNIT_NEW := #x_SEQ_RET.STATUS_TYPE_UNIT_NEW;
	     #SEQ_RET.STATUS_TYPE_UNIT := #x_SEQ_RET.STATUS_TYPE_UNIT;
	 END_IF;
	 
	 // ==========================================================================================================================
	 // Satus extern ADV- Schreiben
	 // ==========================================================================================================================
	 IF #SEQ_ADV_CONNECTED THEN
	     #SEQ_ADV.STATUS_TYPE_NEW := #x_SEQ_ADV.STATUS_TYPE_NEW;
	     #SEQ_ADV.STATUS_TYPE_ASC_NEW := #x_SEQ_ADV.STATUS_TYPE_ASC_NEW;
	     #SEQ_ADV.STATUS_TYPE := #x_SEQ_ADV.STATUS_TYPE;
	     #SEQ_ADV.STATUS_TYPE_ASC := #x_SEQ_ADV.STATUS_TYPE_ASC;
	     
	     #SEQ_ADV.STATUS_TYPE_UNIT_NEW := #x_SEQ_ADV.STATUS_TYPE_UNIT_NEW;
	     #SEQ_ADV.STATUS_TYPE_UNIT := #x_SEQ_ADV.STATUS_TYPE_UNIT;
	 END_IF;
	 
	 // ==========================================================================================================================
	 // Ansteuerung Externer FU (REMOTE)
	 // ==========================================================================================================================
	 // Output to FU
	 #DRV_REMOTE_SEQ.OUT.COMMAND_EXTERNAL := true;
	 #DRV_REMOTE_SEQ.OUT.COMMAND_RESET := #CONTROL_RESET;
	 #DRV_REMOTE_SEQ.OUT.COMMAND_F1_F2 := #CONTROL_FAST AND (#CONTROL_RET OR #CONTROL_ADV);
	 //............................................................... X0=RETRACT/X1=ADVANCE/X2=CENTER/X3=LOADING/X4=UNLOADING /X5=DRV SELECT.....usw. (Command)
	 #DRV_REMOTE_SEQ.OUT.COMMAND.%X0 := #CONTROL_RET;
	 #DRV_REMOTE_SEQ.OUT.COMMAND.%X1 := #CONTROL_ADV;
	 #DRV_REMOTE_SEQ.OUT.COMMAND.%X2 := FALSE;
	 // LOADING - Einfoerdern
	 //................................
	 
	 #Hilfsbit1 :=
	 #M.Auto_Durchfahren_1_RET
	 OR #M.Auto_Durchfahren_2_RET
	 OR #M.Auto_Durchfahren_3_RET
	 
	 OR #M.Auto_Durchfahren_1_ADV
	 OR #M.Auto_Durchfahren_2_ADV
	 OR #M.Auto_Durchfahren_3_ADV
	 ;
	 
	 #DRV_REMOTE_SEQ.OUT.COMMAND.%X3 :=
	 #automatic AND NOT #Hilfsbit1
	 AND
	 (
	 #M.Auto_Einfoerdern_RET OR #M.Auto_Einfoerdern_ADV
	 OR #M.Auto_Durchfahren_Nachlauf_RET OR #M.Auto_Durchfahren_Nachlauf_ADV
	 OR #M.Auto_Einfoerdern_new_Component_RET OR #M.Auto_Einfoerdern_new_Component_ADV
	 OR #M.TIME_FOLLOW_UP_RET OR #M.TIME_FOLLOW_UP_ADV
	 )
	 OR #manual AND (#M.Hand_Einfoerdern_RET_control_ADV OR #M.Hand_Einfoerdern_ADV_control_RET AND #POSITION_EXISTS_RET)
	 // entgegengesetzt (nur mit Schlüsselschalter)
	 OR #manual AND ((#M.Hand_Einfoerdern_RET_control_RET AND #POSITION_EXISTS_RET) OR #M.Hand_Einfoerdern_ADV_control_ADV) AND #M.si_service_mode
	 // Einfahren immer wenn keine Überfördern
	 OR #manual AND (NOT #M.Anwahl_Ueberfoerdern_RET AND NOT #M.Anwahl_Ueberfoerdern_ADV AND #DEV_01.BUTTON_RET AND #POSITION_EXISTS_RET)
	 OR #manual AND (NOT #M.Anwahl_Ueberfoerdern_RET AND NOT #M.Anwahl_Ueberfoerdern_ADV AND #DEV_01.BUTTON_ADV)
	 ;
	 
	 // UNLOADING
	 //................................
	 #DRV_REMOTE_SEQ.OUT.COMMAND.%X4 :=
	 // #M.Ausfoerdern_RET
	 #automatic AND ((#M.Ausfoerdern_RET AND #M.si_interlocking_transport_ret) OR #REM.Wegmerker_RET)
	 // #M.Ausfoerdern_ADV 
	 OR #automatic AND ((#M.Ausfoerdern_ADV AND #M.si_interlocking_transport_adv) OR #REM.Wegmerker_ADV)
	 // Duchfahrt
	 OR #automatic AND #Hilfsbit1
	 
	 OR #manual AND (#M.Hand_Ueberfoerdern_RET_control_RET OR #M.Hand_Ueberfoerdern_ADV_control_ADV)
	 // entgegengesetzt (nur mit Schlüsselschalter)
	 OR #manual AND (#M.Hand_Ueberfoerdern_RET_control_ADV OR #M.Hand_Ueberfoerdern_ADV_control_RET) AND #M.si_service_mode
	 ;
	 
	 // X5=DRV SELECT
	 //................................
	 #DRV_REMOTE_SEQ.OUT.COMMAND.%X5 := #DEV_01.ACTUATOR_SELECT;
	 
	 
	 //............................................................... X0=RETRACT/X1=ADVANCE/X2=CENTER/X3......usw. (Position)
	 #DRV_REMOTE_SEQ.OUT.POSITION.%X0 := #x_B_pos_RET;
	 #DRV_REMOTE_SEQ.OUT.POSITION.%X1 := #x_B_pos_ADV;
	 //............................................................... X0=RETRACT/X1=ADVANCE/X2=CENTER/X3......usw. (Ausführbarkeit )
	 #DRV_REMOTE_SEQ.OUT.INTERLOCK.%X0 := #M.si_interlocking_ret;
	 #DRV_REMOTE_SEQ.OUT.INTERLOCK.%X1 := #M.si_interlocking_adv;
	 //............................................................... X0=alle Error aus/X1=alles Error an/2X=nur Geräte Error /X3=Position_von DRV......usw. (Mode
	 #DRV_REMOTE_SEQ.OUT.REMOTE_MODE.%X0 := false;
	 #DRV_REMOTE_SEQ.OUT.REMOTE_MODE.%X1 := false;
	 #DRV_REMOTE_SEQ.OUT.REMOTE_MODE.%X2 := true;
	 #DRV_REMOTE_SEQ.OUT.REMOTE_MODE.%X3 := false;
	 
	 //............................................................... 
	 #DRV_REMOTE_SEQ.OUT.HMI_BUTTON_SLOW_SELECTED := #HMI.IN.button_slowly;
	 //............................................................... 
	 #DRV_REMOTE_SEQ.OUT.HMI_CONF_BUTTON_DEV_SLOW := #NUMBER_OF_SPEEDS >= 2;
	 #DRV_REMOTE_SEQ.OUT.HMI_CONF_BUTTON_DEV_RET := TRUE;
	 #DRV_REMOTE_SEQ.OUT.HMI_CONF_BUTTON_DEV_CEN := FALSE;
	 #DRV_REMOTE_SEQ.OUT.HMI_CONF_BUTTON_DEV_ADV := TRUE;
	 #DRV_REMOTE_SEQ.OUT.HMI_CONF_BUTTON_DEV_LOADING := FALSE;
	 #DRV_REMOTE_SEQ.OUT.HMI_CONF_BUTTON_DEV_UNLOADING := FALSE;
	 
	 
	 // ==========================================================================================================================
	 // ==========================================================================================================================
	 // HMI / Visu
	 // ==========================================================================================================================
	 // ==========================================================================================================================
	 //==============================================================================================================
	 // HMI Registerkarte
	 //==============================================================================================================
	 "HMI_REGISTER_HEADER_FC"(#HMI.REG.HEADER);
	 #HMI.REG.HEADER.IN.ACTIVE_REGISTER := 1; //  Nummer welches Register bei Eintritt aktiviert werden soll
	 
	 //--- Seite 1 -------------- INTERN
	 #HMI.REG.INTERN.INSTANCE_NAME := #INSTANCE_NAME;
	 // #HMI.REG.INTERN.CAPTION_NAME := CONCAT(IN1 := #ErrorText.LOCATION, IN2 := ''); // Registerkarte Name
	 #HMI.REG.INTERN.CAPTION_NAME := #RegisterText;  // Registerkarte Name
	 #HMI.REG.INTERN.SCREEN_NAME := '{SYMB}LFXXX_DEV_TL_{Detail_2}';   // HMI Symbol name Name
	 #HMI.REG.INTERN.ICON_NUMBER := 1053;                            // Registerkarte ICON Nummer
	 #HMI.REG.INTERN.FAULT := #FAULT;                         // Registerkarte soll Fehler  anzeigen 
	 #HMI.REG.INTERN.WARNING := #WARNING;                       // Registerkarte soll WARNING anzeigen 
	 #HMI.REG.INTERN.EXIST := true;                            // Registerkarte existiert
	 #HMI.REG.INTERN.COMMISSIONING := #CONF.COMMISSIONING_MODE;       // Registerkarte soll Inbetriebnahme Bit anzeigen
	 #HMI.REG.INTERN.PARAMETER_FAULT := #Error.Parametrierfehler;       // Registerkarte soll PARAMETER_ERROR anzeigen  ;
	 
	 "HMI_REGISTER_SHEET_HS_SS_FC"(NAME := '.INTERN',
	                               HEADER := #HMI.REG.HEADER,
	                               SHEET := #HMI.REG.INTERN);
	 
	 //--- Seite 2 -------------- je nach Anwendung : Instance wird von Externe Bausteine anparametriert und von ihm beschrieben und 
	 "HMI_REGISTER_SHEET_HS_SS_FC"(NAME := '.SHEET_02',
	                               HEADER := #HMI.REG.HEADER,
	                               SHEET := #HMI.REG.SHEET_02);
	 
	 //--- Seite 3 -------------- je nach Anwendung : Instance wird von Externe Bausteine anparametriert und von ihm beschrieben und 
	 "HMI_REGISTER_SHEET_HS_SS_FC"(NAME := '.SHEET_03',
	                               HEADER := #HMI.REG.HEADER,
	                               SHEET := #HMI.REG.SHEET_03);
	 
	 //--- Seite 4 -------------- je nach Anwendung : Instance wird von Externe Bausteine anparametriert und von ihm beschrieben und 
	 "HMI_REGISTER_SHEET_HS_SS_FC"(NAME := '.SHEET_04',
	                               HEADER := #HMI.REG.HEADER,
	                               SHEET := #HMI.REG.SHEET_04);
	 //--- Seite 5 -------------- je nach Anwendung : Instance wird von Externe Bausteine anparametriert und von ihm beschrieben und 
	 "HMI_REGISTER_SHEET_HS_SS_FC"(NAME := '.SHEET_DRV',
	                               HEADER := #HMI.REG.HEADER,
	                               SHEET := #HMI.REG.SHEET_DRV);
	
	 IF #DRV_REMOTE_SEQ.IN.COMMAND_EXTERNAL AND #DRV_REMOTE_SEQ.IN.REGISTER_SHEET.EXIST THEN
	     #HMI.REG.SHEET_DRV := #DRV_REMOTE_SEQ.IN.REGISTER_SHEET;
	 END_IF;
	 
	 //==============================================================================================================
	 // HMI Bodensystem
	 //==============================================================================================================
	 // Bei Registerkarte ausgabe ist das die Sammelausgabe
	 #HMI.OUT.Error := #HMI.REG.HEADER.OUT.FAULT;            // Registerkarte Sammelmeldung FAULT
	 #HMI.OUT.WARNING := #HMI.REG.HEADER.OUT.WARNING;
	 #HMI.OUT.COMMISSIONING := #HMI.REG.HEADER.OUT.COMMISSIONING;  // Registerkarte Sammelmeldung COMMISSIONING
	 #HMI.OUT.PARAMETER_ERROR := #HMI.REG.HEADER.OUT.PARAMETER_FAULT;  // Registerkarte Sammelmeldung PARAMETER_FAULT 
	 // -------------------------------------------
	 // #HMI.OUT.LOCATION := #ErrorText.LOCATION;// #LOCATION; [30] Zeichen  aus multiinstanz
	 #HMI.OUT.LOCATION := #RegisterText;
	 #HMI.OUT.DIAG := #DIAG;
	 // #HMI.OUT.Error                      := #Error.Error_Total_Area;
	 #HMI.OUT.ERROR_CLEARANCE := #Error.Error_Spaltkontrolle; // #Error Spaltkontrolle;
	 #HMI.OUT.manual := #manual;
	 #HMI.OUT.automatic := #automatic;
	 #HMI.OUT.Power_on := #POWER_ON;
	 #HMI.OUT.release_reset := #M.reset_release;
	 #HMI.OUT.SI_gebrueckt := #M.si_service_mode;
	 #HMI.OUT.Pos_RET_stop := #x_B_pos_RET;
	 #HMI.OUT.Pos_RET_slow := #x_B_fs_RET;
	 #HMI.OUT.Pos_ADV_stop := #x_B_pos_ADV;
	 #HMI.OUT.Pos_ADV_slow := #x_B_fs_ADV;
	 #HMI.OUT.contr_retr := #CONTROL_RET;
	 #HMI.OUT.contr_adv := #CONTROL_ADV;
	 #HMI.OUT.contr_active := #CONTROL_RET OR #CONTROL_ADV;
	 #HMI.OUT.contr_slow := NOT #CONTROL_FAST OR #NUMBER_OF_SPEEDS = 1;
	 #HMI.OUT.Wegmerker_RET := #REM.Wegmerker_RET;
	 #HMI.OUT.Wegmerker_ADV := #REM.Wegmerker_ADV;
	 #HMI.OUT.INTERLOCK_ADV := #M.si_interlocking_adv;
	 #HMI.OUT.INTERLOCK_RET := #M.si_interlocking_ret;
	 #HMI.OUT.home := #M.HOME_POSITION;
	 #HMI.OUT.empty := #M.EMPTY;
	 #HMI.OUT.occupied := #REM.Belegt;
	 #HMI.OUT.Traverse_comes := #REM.Belegt_Lacktraversen;
	 #HMI.OUT.SAVE_SLOWLY_RET := #M.slowly_RET_Save;
	 #HMI.OUT.SAVE_SLOWLY_ADV := #M.slowly_ADV_Save;
	 #HMI.OUT.Status_Bereit_Einf_RET := #SEQ.STATUS_READY_IN_RET;
	 #HMI.OUT.Status_Bereit_Einf_ADV := #SEQ.STATUS_READY_IN_ADV;
	 #HMI.OUT.Status_Ausfoerdern_RET := #SEQ.STATUS_OUT_RET;
	 #HMI.OUT.Status_Ausfoerdern_ADV := #SEQ.STATUS_OUT_ADV;
	 #HMI.OUT.Anwahl_Einfoerdern_RET := #x_SEQ_RETxxx.Status_Anwahl_Ueberfoerdern_xxx;
	 #HMI.OUT.Anwahl_Einfoerdern_ADV := #x_SEQ_ADVxxx.Status_Anwahl_Ueberfoerdern_xxx;
	 #HMI.OUT.interlock_transport_RET := #M.si_interlocking_transport_ret;
	 #HMI.OUT.interlock_transport_ADV := #M.si_interlocking_transport_adv;
	 #HMI.OUT.mode_reverse := FALSE; // Reserve z.Z. nicht gebraucht
	 #HMI.OUT.Type := 2;                      // 1= STROKE/Hub 2=floor Conveyor/Bodenförderer
	 #HMI.OUT.exists_V2 := #NUMBER_OF_SPEEDS = 2;  // 1= Motor mit 1 geschwindigkeit / 2=Motor mit 2 geschwindigkeit
	 #HMI.OUT.EXISTS_BUTTON_SLOWLY := #HMI.OUT.exists_V2 OR #CONF.BUTTON_SLOWLY_SHOW;
	 #HMI.OUT.exists_RET := #POSITION_EXISTS_RET;  // existiert rückwärts position
	 #HMI.OUT.exists_Traverse := #EXISTS_TRAVERSE;  // existiert Lacktraverse / exists Traverse
	 //.......................................................#LOCATION=[30] + [16]= 1234567890123456 (max 24)
	 #HMI.OUT.DevName := CONCAT(IN1 := #INSTANCE_NAME, IN2 := ' :drive engine');
	 #HMI.OUT.OP_RELEASE := #manual AND #fg.OUT.OP_RELEASE;
	 #HMI.OUT.ACTUATOR_HOME_POSTION := #M.HOME_POSITION;
	 // #HMI.OUT.COMMISSIONING           := false;
	 // #HMI.OUT.PARAMETER_ERROR         := #Error.Parametrierfehler  ;        
	 #HMI.OUT.ACTUATOR_SELECT := #DEV_01.ACTUATOR_SELECT; //  ACTUATOR_SELECT Stelgerät angewählt
	 #HMI.OUT.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET := #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET;
	 #HMI.OUT.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV := #REM.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV;
	 #HMI.OUT.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET_CONFIG := #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_RET;
	 #HMI.OUT.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV_CONFIG := #CONF.AT_OCCUPIED_SET_AUTO_DRIVE_UP_ADV;
	 #HMI.OUT.SEQ_NR := 0;
	 #HMI.OUT.SEQ_RET_connected := #SEQ_RET_CONNECTED;
	 #HMI.OUT.SEQ_RET_mode_reverse := #SEQ_RET_MODE_REVERSE;
	 #HMI.OUT.SEQ_ADV_connected := #SEQ_ADV_CONNECTED;
	 #HMI.OUT.SEQ_ADV_mode_reverse := #SEQ_ADV_MODE_REVERSE;
	 
	 
	 
	 #HMI.OUT.SLOWLY_SAVE_RET := #M.slowly_RET_Save;
	 #HMI.OUT.SLOWLY_SAVE_ADV := #M.slowly_ADV_Save;
	 // Durchfahren
	 #HMI.OUT.DRIVE_THROUGH_RET := #CONF.DRIVE_THROUGH_RET;
	 #HMI.OUT.DRIVE_THROUGH_ADV := #CONF.DRIVE_THROUGH_ADV;
	 // Einfahrt Ende 
	 #HMI.OUT.TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_RET := #Transport_retracted_ends_with_fs_pos_RET; // #CONF.TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_RET;
	 #HMI.OUT.TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_ADV := #Transport_retracted_ends_with_fs_pos_ADV; // #CONF.TRANSPORT_RETRACTED_ENDS_WITH_FS_POS_ADV;
	 // Shuttle
	 #HMI.OUT.ENABLE_SHUTTLE_FUNCTION_IN_ADV := #CONF.ENABLE_SHUTTLE_FUNCTION_IN_ADV;
	 #HMI.OUT.ENABLE_SHUTTLE_FUNCTION_IN_RET := #CONF.ENABLE_SHUTTLE_FUNCTION_IN_RET;
	 
	 #HMI.OUT.INPUT_SHUTTLE_IN_RET := #IN_BG04_SHUTTLE_IN_RET;
	 #HMI.OUT.INPUT_SHUTTLE_IN_ADV := #IN_BG05_SHUTTLE_IN_ADV;
	 #HMI.OUT.ENABLE_START_UP_WARNING_FUNCTION := #CONF.ENABLE_START_UP_WARNING_FUNCTION;
	 #HMI.OUT.START_UP_WARNING_RELEAS_TO_START := #START_UP_WARNING_RELEASE_TO_START;
	 #HMI.OUT.START_UP_WARNING_READY_TO_START := #START_UP_WARNING_READY_TO_START;
	 
	 //-----------------
	 //
	 #HMI.OUT.SEQ_RET := #SEQ_RET;
	 #HMI.OUT.SEQ := #SEQ;
	 #HMI.OUT.SEQ_ADV := #SEQ_ADV;
	 // Type Check
	 #HMI.OUT.TYPE_ENABLE_CHECK := #CONF.TYPE_ENABLE_CHECK;
	 #HMI.OUT.TYPE_RELEASE_PART_NO_CHECK := #CONF.TYPE_RELEASE_PART_NO_CHECK;
	 
	 // Status SK 0...n
	 //------------------------
	 //  0 =            empty                 - empty / Leer
	 //  1 = manual     Transport RET         - Transport RET (extend)
	 //  2 = manual     Transport ADV         - Transport ADV (extend)
	 //  3 = manual     Retract RET           - Einfahren / retract RET
	 //  4 = manual     Retract ADV           - Einfahren / retract ADV
	 //  5 = automatic  Transport RET         - Transport RET (extend)
	 //  6 = automatic  Transport ADV         - Transport ADV (extend)
	 //  7 = automatic  Retract RET           - Einfahren / retract RET
	 //  8 = automatic  Retract ADV           - Einfahren / retract ADV
	 //  9 =            occupied              - Belegt  / occupied
	 // 10 =            ...?...               - kein Status ? (grau)
	 // 11 =            ...?...               - kein Status ? (rot)
	 // 12-65535        Error                  - Error
	 
	 //--------------------------------------------
	 // Error Undefenierte Stellung
	 //--------------------------------------------
	 IF NOT #CONF.DISABLE_SHOW_UNDEFECTED_POSITION
	     AND
	     (
	     (#Error.Error_unsecured_position_Warnung_EMPTY OR #Error.Error_unsecured_position_EMPTY)
	     OR
	     (#Error.Error_unsecured_position_Warnung_OCCUPIED OR #Error.Error_unsecured_position_OCCUPIED)
	     ) THEN
	     #HMI.OUT.Status_SK := 11; // Grund ? (rot)  
	     
	 ELSE
	     #HMI.OUT.Status_SK := 10; // Grund ? (grau)  
	 END_IF;
	 
	 
	 IF #M.EMPTY THEN
	     #HMI.OUT.Status_SK := 0;
	 END_IF;
	 IF #REM.Belegt AND NOT #Error.Error_unsecured_position_Warnung_OCCUPIED THEN
	     #HMI.OUT.Status_SK := 9;
	 END_IF;
	 IF #M.Ausfoerdern_ADV THEN
	     #HMI.OUT.Status_SK := 6;
	 END_IF;
	 IF #M.Ausfoerdern_RET THEN
	     #HMI.OUT.Status_SK := 5;
	 END_IF;
	 IF #M.Auto_Einfoerdern_ADV OR #M.Auto_Einfoerdern_new_Component_ADV THEN
	     #HMI.OUT.Status_SK := 8;
	 END_IF;
	 IF #M.Auto_Einfoerdern_RET OR #M.Auto_Einfoerdern_new_Component_RET THEN
	     #HMI.OUT.Status_SK := 7;
	 END_IF;
	 IF #HMI.OUT.Anwahl_Einfoerdern_ADV THEN
	     #HMI.OUT.Status_SK := 4;
	 END_IF;
	 IF #HMI.OUT.Anwahl_Einfoerdern_RET THEN
	     #HMI.OUT.Status_SK := 3;
	 END_IF;
	 IF #M.Anwahl_Ueberfoerdern_ADV THEN
	     #HMI.OUT.Status_SK := 2;
	 END_IF;
	 IF #M.Anwahl_Ueberfoerdern_RET THEN
	     #HMI.OUT.Status_SK := 1;
	 END_IF;
	 
	 
	 // --------------------------------------------------------------------------------------------------------------------------------
	 // Gibt es einen Fehler in der Aufrufstruktur so dass die FG oder SG Nummer nicht gültig sind oder Parametrierfehler,
	 // so wird der Baustein verlassen und die Ausgänge in einen definierten Zustand gebracht.
	 // --------------------------------------------------------------------------------------------------------------------------------
	 IF #Error.Konfigurationsfehler_FG_Ebene OR #Error.Konfigurationsfehler_SG_Ebene OR #Error.Parametrierfehler THEN
	     #HMI.OUT.ACTUATOR_SELECT := false;
	     #CONTROL_RET := false;
	     #CONTROL_ADV := false;
	     #CONTROL_FAST := false;
	 END_IF;
	 
	 
	 
END_FUNCTION_BLOCK

